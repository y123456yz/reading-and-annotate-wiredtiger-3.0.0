<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>WiredTiger: Transactions  in Java</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="wiredtiger.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://wiredtiger.com/"><img alt="Logo" src="LogoFinal-header.png" alt="WiredTiger" /></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Version 3.0.0</span>
   </div>
   <div id="projectbrief"><!-- 3.0.0 --></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="banner">
  <a href="https://github.com/wiredtiger/wiredtiger">Fork me on GitHub</a>
  <a class="last" href="http://groups.google.com/group/wiredtiger-users">Join my user group</a>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li><a href="community.html"><span>Community</span></a></li>
      <li><a href="license.html"><span>License</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('transactions_lang_java.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Transactions in Java </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="transactions_acid_lang_java"></a>
ACID properties</h1>
<p>Transactions provide a powerful abstraction for multiple threads to operate on data concurrently because they have the following properties:</p>
<ul>
<li>Atomicity: all or none of a transaction is completed.</li>
<li>Consistency: if each transaction maintains some property when considered separately, then the combined effect of executing the transactions concurrently will maintain the same property.</li>
<li>Isolation: developers can reason about transactions as if they run single-threaded.</li>
<li>Durability: once a transaction commits, its updates cannot be lost.</li>
</ul>
<p>WiredTiger supports transactions with the following caveats to the ACID properties:</p>
<ul>
<li>the maximum level of isolation supported is snapshot isolation. See <a class="el" href="transactions_lang_java.html#transaction_isolation_lang_java">Isolation levels</a> for more details.</li>
<li>transactional updates are made durable by a combination of checkpoints and logging. See <a class="el" href="checkpoint_lang_java.html">Checkpoint durability in Java</a> for information on checkpoint durability and <a class="el" href="durability_lang_java.html">Commit-level durability in Java</a> for information on commit-level durability.</li>
<li>each transaction's uncommitted changes must fit in memory: for efficiency, WiredTiger does not write to the log until a transaction commits.</li>
</ul>
<h1><a class="anchor" id="transactions_api_lang_java"></a>
Transactional API</h1>
<p>In WiredTiger, transaction operations are methods off the Session class.</p>
<p>Applications call Session.begin_transaction to start a new transaction. Operations subsequently performed using that Session handle, including operations on any cursors open in that Session handle (whether opened before or after the Session.begin_transaction call), are part of the transaction and their effects committed by calling Session.commit_transaction, or discarded by calling Session.rollback_transaction.</p>
<p>If Session.commit_transaction returns an error for any reason, the transaction was rolled back, not committed.</p>
<p>When transactions are used, data operations can encounter a conflict and fail with the <a class="el" href="group__wt.html#ga5ee3c6fcd074e11efd118f3e68e91db8" title="Conflict between concurrent operations. ">WT_ROLLBACK</a> error. If this error occurs, transactions should be rolled back with Session.rollback_transaction and the operation retried.</p>
<p>The Session.rollback_transaction method implicitly resets all cursors in the session as if the Cursor.reset method was called, discarding any cursor position as well as any key and value.</p>
<div class="fragment"><div class="line">    cursor = session.open_cursor(<span class="stringliteral">&quot;table:mytable&quot;</span>, null, null);</div>
<div class="line">    ret = session.begin_transaction(null);</div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">     * Cursors may be opened before or after the transaction begins, and in</span></div>
<div class="line"><span class="comment">     * either case, subsequent operations are included in the transaction.</span></div>
<div class="line"><span class="comment">     * The begin_transaction call resets all open cursors.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line"></div>
<div class="line">    cursor.putKeyString(<span class="stringliteral">&quot;key&quot;</span>);</div>
<div class="line">    cursor.putValueString(<span class="stringliteral">&quot;value&quot;</span>);</div>
<div class="line">    <span class="keywordflow">switch</span> (ret = cursor.update()) {</div>
<div class="line">    <span class="keywordflow">case</span> 0:                    <span class="comment">/* Update success */</span></div>
<div class="line">        ret = session.commit_transaction(null);</div>
<div class="line">        <span class="comment">/*</span></div>
<div class="line"><span class="comment">         * The commit_transaction call resets all open cursors.</span></div>
<div class="line"><span class="comment">         * If commit_transaction fails, the transaction was rolled-back.</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> wiredtiger.WT_ROLLBACK:            <span class="comment">/* Update conflict */</span></div>
<div class="line">    <span class="keywordflow">default</span>:                <span class="comment">/* Other error */</span></div>
<div class="line">        ret = session.rollback_transaction(null);</div>
<div class="line">        <span class="comment">/* The rollback_transaction call resets all open cursors. */</span></div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">/* Cursors remain open and may be used for multiple transactions. */</span></div>
</div><!-- fragment --> <h1><a class="anchor" id="transactions_implicit_lang_java"></a>
Implicit transactions</h1>
<p>If a cursor is used when no explicit transaction is active in a session, reads are performed at the isolation level of the session, set with the <code>isolation</code> key to Connection.open_session, and successful updates are automatically committed before the update operation returns.</p>
<p>Any operation consisting of multiple related updates should be enclosed in an explicit transaction to ensure the updates are applied atomically.</p>
<p>If an implicit transaction successfully commits, the cursors in the Session remain positioned. If an implicit transaction fails, all cursors in the Session are reset, as if Cursor.reset were called, discarding any position or key/value information they may have.</p>
<p>See <a class="el" href="cursors_lang_java.html#cursors_transactions_lang_java">Cursors and Transactions</a> for more information.</p>
<h1><a class="anchor" id="transactions_concurrency_lang_java"></a>
Concurrency control</h1>
<p>WiredTiger uses optimistic concurrency control algorithms. This avoids the bottleneck of a centralized lock manager and ensures transactional operations do not block: reads do not block writes, and vice versa.</p>
<p>Further, writes do not block writes, although concurrent transactions updating the same value will fail with <a class="el" href="group__wt.html#ga5ee3c6fcd074e11efd118f3e68e91db8" title="Conflict between concurrent operations. ">WT_ROLLBACK</a>. Some applications may benefit from application-level synchronization to avoid repeated attempts to rollback and update the same value.</p>
<p>Operations in transactions may also fail with the <a class="el" href="group__wt.html#ga5ee3c6fcd074e11efd118f3e68e91db8" title="Conflict between concurrent operations. ">WT_ROLLBACK</a> error if some resource cannot be allocated after repeated attempts. For example, if the cache is not large enough to hold the updates required to satisfy transactional readers, an operation may fail and return <a class="el" href="group__wt.html#ga5ee3c6fcd074e11efd118f3e68e91db8" title="Conflict between concurrent operations. ">WT_ROLLBACK</a>.</p>
<h1><a class="anchor" id="transaction_isolation_lang_java"></a>
Isolation levels</h1>
<p>WiredTiger supports <code>read-uncommitted</code>, <code>read-committed</code> and <code>snapshot</code> isolation levels; the default isolation level is <code>read-committed</code>.</p>
<ul>
<li><code>read-uncommitted</code>: Transactions can see changes made by other transactions before those transactions are committed. Dirty reads, non-repeatable reads and phantoms are possible.</li>
<li><code>read-committed</code>: Transactions cannot see changes made by other transactions before those transactions are committed. Dirty reads are not possible; non-repeatable reads and phantoms are possible. Committed changes from concurrent transactions become visible when no cursor is positioned in the read-committed transaction.</li>
<li><code>snapshot</code>: Transactions read the versions of records committed before the transaction started. Dirty reads and non-repeatable reads are not possible; phantoms are possible.<br/>
<br/>
 Snapshot isolation is a strong guarantee, but not equivalent to a single-threaded execution of the transactions, known as serializable isolation. Concurrent transactions T1 and T2 running under snapshot isolation may both commit and produce a state that neither (T1 followed by T2) nor (T2 followed by T1) could have produced, if there is overlap between T1's reads and T2's writes, and between T1's writes and T2's reads.</li>
</ul>
<p>The transaction isolation level can be configured on a per-transaction basis:</p>
<div class="fragment"><div class="line">    <span class="comment">/* A single transaction configured for snapshot isolation. */</span></div>
<div class="line">    cursor = session.open_cursor(<span class="stringliteral">&quot;table:mytable&quot;</span>, null, null);</div>
<div class="line">    ret = session.begin_transaction(<span class="stringliteral">&quot;isolation=snapshot&quot;</span>);</div>
<div class="line">    cursor.putKeyString(<span class="stringliteral">&quot;some-key&quot;</span>);</div>
<div class="line">    cursor.putValueString(<span class="stringliteral">&quot;some-value&quot;</span>);</div>
<div class="line">    ret = cursor.update();</div>
<div class="line">    ret = session.commit_transaction(null);</div>
</div><!-- fragment --><p> Additionally, the default transaction isolation can be configured and re-configured on a per-session basis:</p>
<div class="fragment"><div class="line">    <span class="comment">/* Open a session configured for read-uncommitted isolation. */</span></div>
<div class="line">    session = conn.open_session(</div>
<div class="line">        <span class="stringliteral">&quot;isolation=read_uncommitted&quot;</span>);</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="comment">/* Re-configure a session for snapshot isolation. */</span></div>
<div class="line">    ret = session.reconfigure(<span class="stringliteral">&quot;isolation=snapshot&quot;</span>);</div>
</div><!-- fragment --> <h1><a class="anchor" id="transaction_named_snapshots_lang_java"></a>
Named Snapshots</h1>
<p>Applications can create named snapshots by calling Session.snapshot with a configuration that includes <code>"name=foo"</code>. This configuration creates a new named snapshot, as if a snapshot isolation transaction were started at the time of the Session.snapshot call.</p>
<p>Subsequent transactions can be started "as of" that snapshot by calling Session.begin_transaction with a configuration that includes <code>snapshot=foo</code>. That transaction will run at snapshot isolation as if the transaction started at the time of the Session.snapshot call that created the snapshot.</p>
<p>Named snapshots keep data pinned in cache as if a real transaction were running for the time that the named snapshot is active. The resources associated with named snapshots should be released by calling Session.snapshot with a configuration that includes <code>"drop="</code>. See Session.snapshot documentation for details of the semantics supported by the drop configuration.</p>
<p>Named snapshots are not durable: they do not survive Connection.close.</p>
<h1><a class="anchor" id="transaction_timestamps_lang_java"></a>
Application-specified Transaction Timestamps</h1>
<p>Some applications have their own notion of time, including an expected commit order for transactions that may be inconsistent with the order assigned by WiredTiger. We assume that applications can represent their notion of a timestamp as an unsigned integral value of some size that generally increases over time. For example, a simple 64-bit integer could be incremented to generate transaction timestamps, if that is sufficient for the application.</p>
<p>The application's timestamp size is specified as a number of bytes at build time, with <code>configure &ndash;with-timestamp-size=X</code>. The default timestamp size is 8 bytes (i.e., 64 bits). Setting a size of zero disables transaction timestamp functionality.</p>
<p>Applications can assign explicit commit timestamps to transactions, then read "as of" a timestamp. Timestamps are communicated to WiredTiger using a hexadecimal encoding, so the encoded value can be twice as long as the raw timestamp value.</p>
<p>WiredTiger also provides the ability to set a different commit timestamp for different set of updates in a single transaction. This can be done by calling Session.timestamp_transaction repeatedly to set a new commit timestamp between a set of updates for the current transaction. This gives the ability to commit several updates with different read "as of" timestamp in a single transaction.</p>
<p>Setting a read timestamp in Session.begin_transaction forces a transaction to run at snapshot isolation and ignore any commits with a newer timestamp.</p>
<p>Setting an oldest timestamp in Connection.set_timestamp indicates that future read timestamps will be at least as recent as the oldest timestamp, so WiredTiger can discard history before the specified point. It is critical that the oldest timestamp update frequently or the cache can become full of updates, reducing performance.</p>
<p>Setting a stable timestamp in Connection.set_timestamp indicates a known stable location that is sufficient for durability. During a checkpoint the state of a table will be saved only as of the stable timestamp. Newer updates after that stable timestamp will not be included in the checkpoint. That can be overridden in the call to Session.checkpoint. It is expected that the stable timestamp is updated frequently. Setting a stable location provides the ability, if needed, to rollback to this location by placing a call to Connection.rollback_to_stable. With the rollback, however, WiredTiger does not automatically reset the maximum commit timestamp it is tracking. The application should explicitly do so by setting a commit timestamp in Connection.set_timestamp.</p>
<p>Commit timestamps cannot be set in the past of any read timestamp that has been used. This is enforced by assertions in diagnostic builds, if applications violate this rule, data consistency can be violated.</p>
<p>The commits to a particular data item must be performed in timestamp order. Again, this is only checked in diagnostic builds and if applications violate this rule, data consistency can be violated.</p>
<h2><a class="anchor" id="Timestamp_lang_java"></a>
support in the extension API</h2>
<p>The extension API, used by modules that extend WiredTiger via Connection.get_extension_api, is not timestamp-aware. In particular, <a class="el" href="struct_w_t___e_x_t_e_n_s_i_o_n___a_p_i.html#ac7d3b24f8b9acb6716220931fd6f8bee" title="Return the oldest transaction ID not yet visible to a running transaction. ">WT_EXTENSION_API::transaction_oldest</a> and <a class="el" href="struct_w_t___e_x_t_e_n_s_i_o_n___a_p_i.html#a6894b928a1c41f7d194a6dff9bc36a85" title="Return if the current transaction can see the given transaction ID. ">WT_EXTENSION_API::transaction_visible</a> do not take timestamps into account. Extensions relying on these functions may not work correctly with timestamps. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Reference Guide</a></li><li class="navelem"><a class="el" href="programming_lang_java.html">Writing WiredTiger applications  in Java</a></li>
    <li class="footer">Copyright (c) 2008-2017 MongoDB, Inc.  All rights reserved.  Contact <a href="mailto:info@wiredtiger.com">info@wiredtiger.com</a> for more information.</li>
  </ul>
</div>
</body>
</html>
