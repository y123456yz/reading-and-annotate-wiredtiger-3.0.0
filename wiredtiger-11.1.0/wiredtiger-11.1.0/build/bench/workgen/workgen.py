# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _workgen
else:
    import _workgen

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _workgen.SWIG_PyInstanceMethod_New
_swig_new_static_method = _workgen.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _workgen.delete_SwigPyIterator
    value = _swig_new_instance_method(_workgen.SwigPyIterator_value)
    incr = _swig_new_instance_method(_workgen.SwigPyIterator_incr)
    decr = _swig_new_instance_method(_workgen.SwigPyIterator_decr)
    distance = _swig_new_instance_method(_workgen.SwigPyIterator_distance)
    equal = _swig_new_instance_method(_workgen.SwigPyIterator_equal)
    copy = _swig_new_instance_method(_workgen.SwigPyIterator_copy)
    next = _swig_new_instance_method(_workgen.SwigPyIterator_next)
    __next__ = _swig_new_instance_method(_workgen.SwigPyIterator___next__)
    previous = _swig_new_instance_method(_workgen.SwigPyIterator_previous)
    advance = _swig_new_instance_method(_workgen.SwigPyIterator_advance)
    __eq__ = _swig_new_instance_method(_workgen.SwigPyIterator___eq__)
    __ne__ = _swig_new_instance_method(_workgen.SwigPyIterator___ne__)
    __iadd__ = _swig_new_instance_method(_workgen.SwigPyIterator___iadd__)
    __isub__ = _swig_new_instance_method(_workgen.SwigPyIterator___isub__)
    __add__ = _swig_new_instance_method(_workgen.SwigPyIterator___add__)
    __sub__ = _swig_new_instance_method(_workgen.SwigPyIterator___sub__)
    def __iter__(self):
        return self

# Register SwigPyIterator in _workgen:
_workgen.SwigPyIterator_swigregister(SwigPyIterator)

import argparse,numbers,os,shutil,wiredtiger

class Track(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ops_in_progress = property(_workgen.Track_ops_in_progress_get, _workgen.Track_ops_in_progress_set)
    ops = property(_workgen.Track_ops_get, _workgen.Track_ops_set)
    rollbacks = property(_workgen.Track_rollbacks_get, _workgen.Track_rollbacks_set)
    latency_ops = property(_workgen.Track_latency_ops_get, _workgen.Track_latency_ops_set)
    latency = property(_workgen.Track_latency_get, _workgen.Track_latency_set)
    bucket_ops = property(_workgen.Track_bucket_ops_get, _workgen.Track_bucket_ops_set)
    min_latency = property(_workgen.Track_min_latency_get, _workgen.Track_min_latency_set)
    max_latency = property(_workgen.Track_max_latency_get, _workgen.Track_max_latency_set)

    def __init__(self, *args):
        _workgen.Track_swiginit(self, _workgen.new_Track(*args))
    __swig_destroy__ = _workgen.delete_Track
    add = _swig_new_instance_method(_workgen.Track_add)
    assign = _swig_new_instance_method(_workgen.Track_assign)
    average_latency = _swig_new_instance_method(_workgen.Track_average_latency)
    begin = _swig_new_instance_method(_workgen.Track_begin)
    clear = _swig_new_instance_method(_workgen.Track_clear)
    complete = _swig_new_instance_method(_workgen.Track_complete)
    complete_with_latency = _swig_new_instance_method(_workgen.Track_complete_with_latency)
    percentile_latency = _swig_new_instance_method(_workgen.Track_percentile_latency)
    subtract = _swig_new_instance_method(_workgen.Track_subtract)
    track_latency = _swig_new_instance_method(_workgen.Track_track_latency)
    _get_us = _swig_new_instance_method(_workgen.Track__get_us)
    _get_ms = _swig_new_instance_method(_workgen.Track__get_ms)
    _get_sec = _swig_new_instance_method(_workgen.Track__get_sec)

    def __longarray(self, size):
        result = longArray(size)
        result.__len__ = lambda: size
        return result

    def us(self):
        result = self.__longarray(1000)
        self._get_us(result)
        return result

    def ms(self):
        result = self.__longarray(1000)
        self._get_ms(result)
        return result

    def sec(self):
        result = self.__longarray(100)
        self._get_sec(result)
        return result


# Register Track in _workgen:
_workgen.Track_swigregister(Track)
class Stats(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    checkpoint = property(_workgen.Stats_checkpoint_get)
    insert = property(_workgen.Stats_insert_get)
    not_found = property(_workgen.Stats_not_found_get)
    read = property(_workgen.Stats_read_get)
    remove = property(_workgen.Stats_remove_get)
    update = property(_workgen.Stats_update_get)
    truncate = property(_workgen.Stats_truncate_get)

    def __init__(self, *args):
        _workgen.Stats_swiginit(self, _workgen.new_Stats(*args))
    __swig_destroy__ = _workgen.delete_Stats
    add = _swig_new_instance_method(_workgen.Stats_add)
    assign = _swig_new_instance_method(_workgen.Stats_assign)
    clear = _swig_new_instance_method(_workgen.Stats_clear)
    describe = _swig_new_instance_method(_workgen.Stats_describe)
    subtract = _swig_new_instance_method(_workgen.Stats_subtract)
    track_latency = _swig_new_instance_method(_workgen.Stats_track_latency)
    __str__ = _swig_new_instance_method(_workgen.Stats___str__)

# Register Stats in _workgen:
_workgen.Stats_swigregister(Stats)
class Context(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _verbose = property(_workgen.Context__verbose_get, _workgen.Context__verbose_set)
    _internal = property(_workgen.Context__internal_get, _workgen.Context__internal_set)

    def __init__(self):
        _workgen.Context_swiginit(self, _workgen.new_Context())
    __swig_destroy__ = _workgen.delete_Context
    describe = _swig_new_instance_method(_workgen.Context_describe)
    __str__ = _swig_new_instance_method(_workgen.Context___str__)

        # This will be the actual __init__ function after we shuffle names below!
    def Xinit(self, parser = None):
        self.__original_init__()
        self._internal_init(parser)

    def _internal_init(self, parser):
        self.default_home = "WT_TEST"
        self.default_config = "create"
        if not parser:
            parser = argparse.ArgumentParser("Execute workgen.")
        parser.add_argument("--home", dest="home", type=str,
          help="home directory for the run (default=%s)" % self.default_home)
        parser.add_argument("--keep", dest="keep", action="store_true",
          help="Run the workload on an existing home directory")
        parser.add_argument("--verbose", dest="verbose", action="store_true",
          help="Run the workload verbosely")
        self.parser = parser
        self._initialized = False

    def parse_arguments(self, parser):
        self.args = parser.parse_args()

    def wiredtiger_open_config(self, config):
        return config

    def wiredtiger_open(self, config = None):
        if config == None:
            config = self.default_config
        self.initialize()
        return wiredtiger.wiredtiger_open(self.args.home, self.wiredtiger_open_config(config))

    def initialize(self):
        if not self._initialized:
            self.parse_arguments(self.parser)
            if self.args.home == None:
               self.args.home = self.default_home
            self._initialized = True
            if not self.args.keep:
                shutil.rmtree(self.args.home, True)
                os.mkdir(self.args.home)
        return self


# Register Context in _workgen:
_workgen.Context_swigregister(Context)
class TableOptions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    key_size = property(_workgen.TableOptions_key_size_get, _workgen.TableOptions_key_size_set)
    value_size = property(_workgen.TableOptions_value_size_get, _workgen.TableOptions_value_size_set)
    value_compressibility = property(_workgen.TableOptions_value_compressibility_get, _workgen.TableOptions_value_compressibility_set)
    random_value = property(_workgen.TableOptions_random_value_get, _workgen.TableOptions_random_value_set)
    range = property(_workgen.TableOptions_range_get, _workgen.TableOptions_range_set)

    def __init__(self, *args):
        _workgen.TableOptions_swiginit(self, _workgen.new_TableOptions(*args))
    __swig_destroy__ = _workgen.delete_TableOptions
    describe = _swig_new_instance_method(_workgen.TableOptions_describe)
    help = _swig_new_instance_method(_workgen.TableOptions_help)
    help_description = _swig_new_instance_method(_workgen.TableOptions_help_description)
    help_type = _swig_new_instance_method(_workgen.TableOptions_help_type)
    __str__ = _swig_new_instance_method(_workgen.TableOptions___str__)

    def __setattr__(self, attr, val):
        if attr != 'this' and getattr(self, attr) == None:
            raise AttributeError("'" +"TableOptions" +
              "' object has no attribute '" + attr + "'")
        object.__setattr__(self, attr, val)


# Register TableOptions in _workgen:
_workgen.TableOptions_swigregister(TableOptions)
class Table(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    options = property(_workgen.Table_options_get, _workgen.Table_options_set)
    _uri = property(_workgen.Table__uri_get, _workgen.Table__uri_set)
    _internal = property(_workgen.Table__internal_get, _workgen.Table__internal_set)

    def __init__(self, *args):
        _workgen.Table_swiginit(self, _workgen.new_Table(*args))
    __swig_destroy__ = _workgen.delete_Table
    describe = _swig_new_instance_method(_workgen.Table_describe)
    __str__ = _swig_new_instance_method(_workgen.Table___str__)

# Register Table in _workgen:
_workgen.Table_swigregister(Table)
class ParetoOptions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    param = property(_workgen.ParetoOptions_param_get, _workgen.ParetoOptions_param_set)
    range_low = property(_workgen.ParetoOptions_range_low_get, _workgen.ParetoOptions_range_low_set)
    range_high = property(_workgen.ParetoOptions_range_high_get, _workgen.ParetoOptions_range_high_set)

    def __init__(self, *args):
        _workgen.ParetoOptions_swiginit(self, _workgen.new_ParetoOptions(*args))
    __swig_destroy__ = _workgen.delete_ParetoOptions
    describe = _swig_new_instance_method(_workgen.ParetoOptions_describe)
    help = _swig_new_instance_method(_workgen.ParetoOptions_help)
    help_description = _swig_new_instance_method(_workgen.ParetoOptions_help_description)
    help_type = _swig_new_instance_method(_workgen.ParetoOptions_help_type)
    DEFAULT = property(_workgen.ParetoOptions_DEFAULT_get, _workgen.ParetoOptions_DEFAULT_set)

# Register ParetoOptions in _workgen:
_workgen.ParetoOptions_swigregister(ParetoOptions)
cvar = _workgen.cvar

class Key(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    KEYGEN_AUTO = _workgen.Key_KEYGEN_AUTO
    KEYGEN_APPEND = _workgen.Key_KEYGEN_APPEND
    KEYGEN_PARETO = _workgen.Key_KEYGEN_PARETO
    KEYGEN_UNIFORM = _workgen.Key_KEYGEN_UNIFORM
    _keytype = property(_workgen.Key__keytype_get, _workgen.Key__keytype_set)
    _size = property(_workgen.Key__size_get, _workgen.Key__size_set)
    _pareto = property(_workgen.Key__pareto_get, _workgen.Key__pareto_set)

    def __init__(self, *args):
        _workgen.Key_swiginit(self, _workgen.new_Key(*args))
    __swig_destroy__ = _workgen.delete_Key
    describe = _swig_new_instance_method(_workgen.Key_describe)
    __str__ = _swig_new_instance_method(_workgen.Key___str__)

# Register Key in _workgen:
_workgen.Key_swigregister(Key)
class Value(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _size = property(_workgen.Value__size_get, _workgen.Value__size_set)

    def __init__(self, *args):
        _workgen.Value_swiginit(self, _workgen.new_Value(*args))
    __swig_destroy__ = _workgen.delete_Value
    describe = _swig_new_instance_method(_workgen.Value_describe)
    __str__ = _swig_new_instance_method(_workgen.Value___str__)

# Register Value in _workgen:
_workgen.Value_swigregister(Value)
class Operation(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    OP_CHECKPOINT = _workgen.Operation_OP_CHECKPOINT
    OP_INSERT = _workgen.Operation_OP_INSERT
    OP_LOG_FLUSH = _workgen.Operation_OP_LOG_FLUSH
    OP_NONE = _workgen.Operation_OP_NONE
    OP_NOOP = _workgen.Operation_OP_NOOP
    OP_REMOVE = _workgen.Operation_OP_REMOVE
    OP_SEARCH = _workgen.Operation_OP_SEARCH
    OP_SLEEP = _workgen.Operation_OP_SLEEP
    OP_UPDATE = _workgen.Operation_OP_UPDATE
    _optype = property(_workgen.Operation__optype_get, _workgen.Operation__optype_set)
    _internal = property(_workgen.Operation__internal_get, _workgen.Operation__internal_set)
    _table = property(_workgen.Operation__table_get, _workgen.Operation__table_set)
    _key = property(_workgen.Operation__key_get, _workgen.Operation__key_set)
    _value = property(_workgen.Operation__value_get, _workgen.Operation__value_set)
    _config = property(_workgen.Operation__config_get, _workgen.Operation__config_set)
    transaction = property(_workgen.Operation_transaction_get, _workgen.Operation_transaction_set)
    _group = property(_workgen.Operation__group_get, _workgen.Operation__group_set)
    _repeatgroup = property(_workgen.Operation__repeatgroup_get, _workgen.Operation__repeatgroup_set)
    _timed = property(_workgen.Operation__timed_get, _workgen.Operation__timed_set)

    def __init__(self, *args):
        _workgen.Operation_swiginit(self, _workgen.new_Operation(*args))
    __swig_destroy__ = _workgen.delete_Operation
    combinable = _swig_new_instance_method(_workgen.Operation_combinable)
    describe = _swig_new_instance_method(_workgen.Operation_describe)
    __str__ = _swig_new_instance_method(_workgen.Operation___str__)

    def __mul__(self, other):
        if not isinstance(other, numbers.Integral):
            raise Exception('Operation.__mul__ requires an integral number')
        op = Operation()
        op._group = OpList([self])
        op._repeatgroup = other
        return op

    __rmul__ = __mul__

    def __add__(self, other):
        if not isinstance(other, Operation):
            raise Exception('Operation.__sum__ requires an Operation')
        if not self.combinable():
            op = Operation()
            op._group = OpList([self, other])
            op._repeatgroup = 1
            return op
        else:
            self._group.append(other)
            return self


# Register Operation in _workgen:
_workgen.Operation_swigregister(Operation)
class ThreadOptions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_workgen.ThreadOptions_name_get, _workgen.ThreadOptions_name_set)
    session_config = property(_workgen.ThreadOptions_session_config_get, _workgen.ThreadOptions_session_config_set)
    throttle = property(_workgen.ThreadOptions_throttle_get, _workgen.ThreadOptions_throttle_set)
    throttle_burst = property(_workgen.ThreadOptions_throttle_burst_get, _workgen.ThreadOptions_throttle_burst_set)
    synchronized = property(_workgen.ThreadOptions_synchronized_get, _workgen.ThreadOptions_synchronized_set)

    def __init__(self, *args):
        _workgen.ThreadOptions_swiginit(self, _workgen.new_ThreadOptions(*args))
    __swig_destroy__ = _workgen.delete_ThreadOptions
    describe = _swig_new_instance_method(_workgen.ThreadOptions_describe)
    help = _swig_new_instance_method(_workgen.ThreadOptions_help)
    help_description = _swig_new_instance_method(_workgen.ThreadOptions_help_description)
    help_type = _swig_new_instance_method(_workgen.ThreadOptions_help_type)
    __str__ = _swig_new_instance_method(_workgen.ThreadOptions___str__)

    def __setattr__(self, attr, val):
        if attr != 'this' and getattr(self, attr) == None:
            raise AttributeError("'" +"ThreadOptions" +
              "' object has no attribute '" + attr + "'")
        object.__setattr__(self, attr, val)


# Register ThreadOptions in _workgen:
_workgen.ThreadOptions_swigregister(ThreadOptions)
class ThreadListWrapper(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _threads = property(_workgen.ThreadListWrapper__threads_get, _workgen.ThreadListWrapper__threads_set)

    def __init__(self, *args):
        _workgen.ThreadListWrapper_swiginit(self, _workgen.new_ThreadListWrapper(*args))
    extend = _swig_new_instance_method(_workgen.ThreadListWrapper_extend)
    append = _swig_new_instance_method(_workgen.ThreadListWrapper_append)
    multiply = _swig_new_instance_method(_workgen.ThreadListWrapper_multiply)

    def __mul__(self, other):
        if not isinstance(other, numbers.Integral):
            raise Exception('ThreadList.__mul__ requires an integral number')
        tlw = ThreadListWrapper(self)
        tlw.multiply(other)
        return tlw

    __rmul__ = __mul__

    def __add__(self, other):
        tlw = ThreadListWrapper(self)
        if isinstance(other, ThreadListWrapper):
            tlw.extend(other)
        elif isinstance(other, Thread):
            tlw.append(other)
        else:
            raise Exception('ThreadList.__sum__ requires an Thread or ThreadList')
        return tlw

    __swig_destroy__ = _workgen.delete_ThreadListWrapper

# Register ThreadListWrapper in _workgen:
_workgen.ThreadListWrapper_swigregister(ThreadListWrapper)
class Thread(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    options = property(_workgen.Thread_options_get, _workgen.Thread_options_set)
    _op = property(_workgen.Thread__op_get, _workgen.Thread__op_set)

    def __init__(self, *args):
        _workgen.Thread_swiginit(self, _workgen.new_Thread(*args))
    __swig_destroy__ = _workgen.delete_Thread
    describe = _swig_new_instance_method(_workgen.Thread_describe)
    __str__ = _swig_new_instance_method(_workgen.Thread___str__)

    def __mul__(self, other):
        if not isinstance(other, numbers.Integral):
            raise Exception('Thread.__mul__ requires an integral number')
        return ThreadListWrapper(ThreadList([self] * other))

    __rmul__ = __mul__

    def __add__(self, other):
        if type(self) != type(other):
            raise Exception('Thread.__sum__ requires an Thread')
        return ThreadListWrapper(ThreadList([self, other]))


# Register Thread in _workgen:
_workgen.Thread_swigregister(Thread)
class Transaction(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _rollback = property(_workgen.Transaction__rollback_get, _workgen.Transaction__rollback_set)
    use_commit_timestamp = property(_workgen.Transaction_use_commit_timestamp_get, _workgen.Transaction_use_commit_timestamp_set)
    use_prepare_timestamp = property(_workgen.Transaction_use_prepare_timestamp_get, _workgen.Transaction_use_prepare_timestamp_set)
    _begin_config = property(_workgen.Transaction__begin_config_get, _workgen.Transaction__begin_config_set)
    _commit_config = property(_workgen.Transaction__commit_config_get, _workgen.Transaction__commit_config_set)
    read_timestamp_lag = property(_workgen.Transaction_read_timestamp_lag_get, _workgen.Transaction_read_timestamp_lag_set)

    def __init__(self, *args):
        _workgen.Transaction_swiginit(self, _workgen.new_Transaction(*args))
    describe = _swig_new_instance_method(_workgen.Transaction_describe)
    __str__ = _swig_new_instance_method(_workgen.Transaction___str__)
    __swig_destroy__ = _workgen.delete_Transaction

# Register Transaction in _workgen:
_workgen.Transaction_swigregister(Transaction)
class WorkloadOptions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    max_latency = property(_workgen.WorkloadOptions_max_latency_get, _workgen.WorkloadOptions_max_latency_set)
    report_file = property(_workgen.WorkloadOptions_report_file_get, _workgen.WorkloadOptions_report_file_set)
    report_interval = property(_workgen.WorkloadOptions_report_interval_get, _workgen.WorkloadOptions_report_interval_set)
    run_time = property(_workgen.WorkloadOptions_run_time_get, _workgen.WorkloadOptions_run_time_set)
    sample_interval_ms = property(_workgen.WorkloadOptions_sample_interval_ms_get, _workgen.WorkloadOptions_sample_interval_ms_set)
    sample_rate = property(_workgen.WorkloadOptions_sample_rate_get, _workgen.WorkloadOptions_sample_rate_set)
    max_idle_table_cycle = property(_workgen.WorkloadOptions_max_idle_table_cycle_get, _workgen.WorkloadOptions_max_idle_table_cycle_set)
    sample_file = property(_workgen.WorkloadOptions_sample_file_get, _workgen.WorkloadOptions_sample_file_set)
    warmup = property(_workgen.WorkloadOptions_warmup_get, _workgen.WorkloadOptions_warmup_set)
    oldest_timestamp_lag = property(_workgen.WorkloadOptions_oldest_timestamp_lag_get, _workgen.WorkloadOptions_oldest_timestamp_lag_set)
    stable_timestamp_lag = property(_workgen.WorkloadOptions_stable_timestamp_lag_get, _workgen.WorkloadOptions_stable_timestamp_lag_set)
    timestamp_advance = property(_workgen.WorkloadOptions_timestamp_advance_get, _workgen.WorkloadOptions_timestamp_advance_set)
    max_idle_table_cycle_fatal = property(_workgen.WorkloadOptions_max_idle_table_cycle_fatal_get, _workgen.WorkloadOptions_max_idle_table_cycle_fatal_set)

    def __init__(self, *args):
        _workgen.WorkloadOptions_swiginit(self, _workgen.new_WorkloadOptions(*args))
    __swig_destroy__ = _workgen.delete_WorkloadOptions
    describe = _swig_new_instance_method(_workgen.WorkloadOptions_describe)
    help = _swig_new_instance_method(_workgen.WorkloadOptions_help)
    help_description = _swig_new_instance_method(_workgen.WorkloadOptions_help_description)
    help_type = _swig_new_instance_method(_workgen.WorkloadOptions_help_type)
    __str__ = _swig_new_instance_method(_workgen.WorkloadOptions___str__)

    def __setattr__(self, attr, val):
        if attr != 'this' and getattr(self, attr) == None:
            raise AttributeError("'" +"WorkloadOptions" +
              "' object has no attribute '" + attr + "'")
        object.__setattr__(self, attr, val)


# Register WorkloadOptions in _workgen:
_workgen.WorkloadOptions_swigregister(WorkloadOptions)
class Workload(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    options = property(_workgen.Workload_options_get, _workgen.Workload_options_set)
    stats = property(_workgen.Workload_stats_get)
    _context = property(_workgen.Workload__context_get, _workgen.Workload__context_set)
    _threads = property(_workgen.Workload__threads_get, _workgen.Workload__threads_set)

    def __init__(self, *args):
        _workgen.Workload_swiginit(self, _workgen.new_Workload(*args))
    __swig_destroy__ = _workgen.delete_Workload
    describe = _swig_new_instance_method(_workgen.Workload_describe)
    run = _swig_new_instance_method(_workgen.Workload_run)
    __str__ = _swig_new_instance_method(_workgen.Workload___str__)

# Register Workload in _workgen:
_workgen.Workload_swigregister(Workload)
class OpList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_workgen.OpList_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_workgen.OpList___nonzero__)
    __bool__ = _swig_new_instance_method(_workgen.OpList___bool__)
    __len__ = _swig_new_instance_method(_workgen.OpList___len__)
    __getslice__ = _swig_new_instance_method(_workgen.OpList___getslice__)
    __setslice__ = _swig_new_instance_method(_workgen.OpList___setslice__)
    __delslice__ = _swig_new_instance_method(_workgen.OpList___delslice__)
    __delitem__ = _swig_new_instance_method(_workgen.OpList___delitem__)
    __getitem__ = _swig_new_instance_method(_workgen.OpList___getitem__)
    __setitem__ = _swig_new_instance_method(_workgen.OpList___setitem__)
    pop = _swig_new_instance_method(_workgen.OpList_pop)
    append = _swig_new_instance_method(_workgen.OpList_append)
    empty = _swig_new_instance_method(_workgen.OpList_empty)
    size = _swig_new_instance_method(_workgen.OpList_size)
    swap = _swig_new_instance_method(_workgen.OpList_swap)
    begin = _swig_new_instance_method(_workgen.OpList_begin)
    end = _swig_new_instance_method(_workgen.OpList_end)
    rbegin = _swig_new_instance_method(_workgen.OpList_rbegin)
    rend = _swig_new_instance_method(_workgen.OpList_rend)
    clear = _swig_new_instance_method(_workgen.OpList_clear)
    get_allocator = _swig_new_instance_method(_workgen.OpList_get_allocator)
    pop_back = _swig_new_instance_method(_workgen.OpList_pop_back)
    erase = _swig_new_instance_method(_workgen.OpList_erase)

    def __init__(self, *args):
        _workgen.OpList_swiginit(self, _workgen.new_OpList(*args))
    push_back = _swig_new_instance_method(_workgen.OpList_push_back)
    front = _swig_new_instance_method(_workgen.OpList_front)
    back = _swig_new_instance_method(_workgen.OpList_back)
    assign = _swig_new_instance_method(_workgen.OpList_assign)
    resize = _swig_new_instance_method(_workgen.OpList_resize)
    insert = _swig_new_instance_method(_workgen.OpList_insert)
    reserve = _swig_new_instance_method(_workgen.OpList_reserve)
    capacity = _swig_new_instance_method(_workgen.OpList_capacity)
    __swig_destroy__ = _workgen.delete_OpList

# Register OpList in _workgen:
_workgen.OpList_swigregister(OpList)
class ThreadList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_workgen.ThreadList_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_workgen.ThreadList___nonzero__)
    __bool__ = _swig_new_instance_method(_workgen.ThreadList___bool__)
    __len__ = _swig_new_instance_method(_workgen.ThreadList___len__)
    __getslice__ = _swig_new_instance_method(_workgen.ThreadList___getslice__)
    __setslice__ = _swig_new_instance_method(_workgen.ThreadList___setslice__)
    __delslice__ = _swig_new_instance_method(_workgen.ThreadList___delslice__)
    __delitem__ = _swig_new_instance_method(_workgen.ThreadList___delitem__)
    __getitem__ = _swig_new_instance_method(_workgen.ThreadList___getitem__)
    __setitem__ = _swig_new_instance_method(_workgen.ThreadList___setitem__)
    pop = _swig_new_instance_method(_workgen.ThreadList_pop)
    append = _swig_new_instance_method(_workgen.ThreadList_append)
    empty = _swig_new_instance_method(_workgen.ThreadList_empty)
    size = _swig_new_instance_method(_workgen.ThreadList_size)
    swap = _swig_new_instance_method(_workgen.ThreadList_swap)
    begin = _swig_new_instance_method(_workgen.ThreadList_begin)
    end = _swig_new_instance_method(_workgen.ThreadList_end)
    rbegin = _swig_new_instance_method(_workgen.ThreadList_rbegin)
    rend = _swig_new_instance_method(_workgen.ThreadList_rend)
    clear = _swig_new_instance_method(_workgen.ThreadList_clear)
    get_allocator = _swig_new_instance_method(_workgen.ThreadList_get_allocator)
    pop_back = _swig_new_instance_method(_workgen.ThreadList_pop_back)
    erase = _swig_new_instance_method(_workgen.ThreadList_erase)

    def __init__(self, *args):
        _workgen.ThreadList_swiginit(self, _workgen.new_ThreadList(*args))
    push_back = _swig_new_instance_method(_workgen.ThreadList_push_back)
    front = _swig_new_instance_method(_workgen.ThreadList_front)
    back = _swig_new_instance_method(_workgen.ThreadList_back)
    assign = _swig_new_instance_method(_workgen.ThreadList_assign)
    resize = _swig_new_instance_method(_workgen.ThreadList_resize)
    insert = _swig_new_instance_method(_workgen.ThreadList_insert)
    reserve = _swig_new_instance_method(_workgen.ThreadList_reserve)
    capacity = _swig_new_instance_method(_workgen.ThreadList_capacity)
    __swig_destroy__ = _workgen.delete_ThreadList

# Register ThreadList in _workgen:
_workgen.ThreadList_swigregister(ThreadList)
class uint32Array(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements):
        _workgen.uint32Array_swiginit(self, _workgen.new_uint32Array(nelements))
    __swig_destroy__ = _workgen.delete_uint32Array
    __getitem__ = _swig_new_instance_method(_workgen.uint32Array___getitem__)
    __setitem__ = _swig_new_instance_method(_workgen.uint32Array___setitem__)
    cast = _swig_new_instance_method(_workgen.uint32Array_cast)
    frompointer = _swig_new_static_method(_workgen.uint32Array_frompointer)

# Register uint32Array in _workgen:
_workgen.uint32Array_swigregister(uint32Array)
class longArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements):
        _workgen.longArray_swiginit(self, _workgen.new_longArray(nelements))
    __swig_destroy__ = _workgen.delete_longArray
    __getitem__ = _swig_new_instance_method(_workgen.longArray___getitem__)
    __setitem__ = _swig_new_instance_method(_workgen.longArray___setitem__)
    cast = _swig_new_instance_method(_workgen.longArray_cast)
    frompointer = _swig_new_static_method(_workgen.longArray_frompointer)

# Register longArray in _workgen:
_workgen.longArray_swigregister(longArray)

# Shuffle the names of the __init__ function, we want ours (Xinit above), called first.
# This seems to be the most natural way to intercept a C++ constructor, and do
# Python-specific actions as part of the regular constructor.
Context.__original_init__ = Context.__init__
Context.__init__ = Context.Xinit


