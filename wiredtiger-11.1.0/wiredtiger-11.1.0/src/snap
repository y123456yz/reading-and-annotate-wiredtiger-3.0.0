block_cache/block_map.c:__wt_blkcache_map(WT_SESSION_IMPL *session, WT_BLOCK *block, void **mapped_regionp, size_t *lengthp,
block_cache/block_map.c:    if (block->verify)
block_cache/block_map.c:    if (block->os_cache_max != 0)
block_cache/block_map.c:    handle = block->fh->handle;
block_cache/block_map.c:__wt_blkcache_unmap(WT_SESSION_IMPL *session, WT_BLOCK *block, void *mapped_region, size_t length,
block_cache/block_map.c:    handle = block->fh->handle;
block_cache/block_map.c: *     Map address cookie referenced block into a buffer.
block_cache/block_map.c:    WT_BLOCK *block;
block_cache/block_map.c:    block = bm->block;
block_cache/block_map.c:    WT_RET(__wt_block_addr_unpack(
block_cache/block_map.c:      session, block, addr, addr_size, &objectid, &offset, &size, &checksum));
block_cache/block_map.c:    if (block->objectid != objectid)
block_cache/block_map.c:        WT_RET(__wt_blkcache_get_handle(session, block, objectid, &block));
block_cache/block_map.c:    /* Map the block if it's possible. */
block_cache/block_map.c:    handle = block->fh->handle;
block_cache/block_map.c:        WT_STAT_CONN_INCR(session, block_map_read);
block_cache/block_map.c:        WT_STAT_CONN_INCRV(session, block_byte_map_read, size);
block_cache/block_tier.c:  WT_SESSION_IMPL *session, const char *uri, uint32_t objectid, WT_BLOCK **blockp)
block_cache/block_tier.c:    WT_BLOCK *block;
block_cache/block_tier.c:    *blockp = NULL;
block_cache/block_tier.c:          __wt_block_open(session, object_name, objectid, cfg, false, readonly, false, 0, &block));
block_cache/block_tier.c:          ret = __wt_block_open(session, tmp->mem, objectid, cfg, false, true, true, 0, &block));
block_cache/block_tier.c:    *blockp = block;
block_cache/block_tier.c: *     Get a cached block handle for an object, creating it if it doesn't exist.
block_cache/block_tier.c:  WT_SESSION_IMPL *session, WT_BLOCK *current, uint32_t objectid, WT_BLOCK **blockp)
block_cache/block_tier.c:    *blockp = NULL;
block_cache/block_tier.c:            *blockp = current->related[i];
block_cache/block_tier.c:    /* Lock the block cache layer.  */
block_cache/block_tier.c:            *blockp = current->related[i];
block_cache/block_tier.c:    if (*blockp == NULL) {
block_cache/block_tier.c:        WT_ERR(__wt_blkcache_tiered_open(session, NULL, objectid, blockp));
block_cache/block_tier.c:        /* Save a reference in the block in which we started for fast subsequent access. */
block_cache/block_tier.c:        current->related[current->related_next++] = *blockp;
block_cache/block_cache.c: *     Allocate a block of memory in the cache.
block_cache/block_cache.c:        WT_RET_MSG(session, EINVAL, "NVRAM block cache type requires libmemkind");
block_cache/block_cache.c:        __wt_err(session, EINVAL, "NVRAM block cache type requires libmemkind");
block_cache/block_cache.c: *     Update the histogram of block accesses when the block is freed or on exit.
block_cache/block_cache.c:        blkcache->cache_references_removed_blocks[bucket]++;
block_cache/block_cache.c:        blkcache->cache_references_evicted_blocks[bucket]++;
block_cache/block_cache.c: *     Print a histogram showing how a type of block given in the header is reused.
block_cache/block_cache.c:    __wt_verbose(session, WT_VERB_BLKCACHE, "%s", "Reuses \t Number of blocks");
block_cache/block_cache.c: *     Estimate the overhead of using the cache. The overhead comes from block insertions and
block_cache/block_cache.c: *     Decide if the block should be evicted.
block_cache/block_cache.c:     * Keep track of the smallest number of references for blocks that have not been recently
block_cache/block_cache.c:     * In an NVRAM cache, don't evict if there is high overhead due to blocks being
block_cache/block_cache.c:        WT_STAT_CONN_INCR(session, block_cache_not_evicted_overhead);
block_cache/block_cache.c:     * Evict if the block has not been accessed for the amount of time corresponding to the evict
block_cache/block_cache.c:     * aggressive setting. Within the category of blocks that fit this criterion, choose those with
block_cache/block_cache.c: *     Periodically sweep the cache and evict unused blocks.
block_cache/block_cache.c:         * resident blocks.
block_cache/block_cache.c:         * Walk the cache, gathering statistics and evicting blocks that are within our target. We
block_cache/block_cache.c:         * sweep the cache every second, decrementing the frequency/recency counter of each block.
block_cache/block_cache.c:         * according to how soon we expect the blocks to become irrelevant. For example, if the
block_cache/block_cache.c:         * threshold is set to 1800 seconds (=30 minutes), blocks that were used once but then
block_cache/block_cache.c:         * As we cycle through the blocks, we keep track of the minimum number of references
block_cache/block_cache.c:         * observed for blocks whose frequency/recency counter has gone below the threshold. We will
block_cache/block_cache.c:         * evict blocks with the smallest counter before evicting those with a larger one.
block_cache/block_cache.c:                    WT_STAT_CONN_INCR(session, block_cache_blocks_evicted);
block_cache/block_cache.c:                    WT_STAT_CONN_DECRV(session, block_cache_bytes, blkcache_item->data_size);
block_cache/block_cache.c:                    WT_STAT_CONN_DECR(session, block_cache_blocks);
block_cache/block_cache.c:        WT_STAT_CONN_INCR(session, block_cache_eviction_passes);
block_cache/block_cache.c:    WT_BLOCK *block;
block_cache/block_cache.c:    __wt_spin_lock(session, &conn->block_lock);
block_cache/block_cache.c:        TAILQ_FOREACH (block, &conn->blockhash[bucket], hashq) {
block_cache/block_cache.c:            size += (size_t)block->size;
block_cache/block_cache.c:    __wt_spin_unlock(session, &conn->block_lock);
block_cache/block_cache.c:    WT_STAT_CONN_SET(session, block_cache_bypass_filesize, blkcache->estimated_file_size);
block_cache/block_cache.c: *     Get a block from the cache.
block_cache/block_cache.c:    WT_STAT_CONN_INCR(session, block_cache_lookups);
block_cache/block_cache.c:     * An NVRAM cache is slower than retrieving the block from the OS buffer cache, a DRAM cache is
block_cache/block_cache.c:     * of all file objects is likely to fit in the OS buffer cache, don't use the block cache.
block_cache/block_cache.c:        WT_STAT_CONN_INCR(session, block_cache_bypass_get);
block_cache/block_cache.c:        WT_STAT_CONN_INCR(session, block_cache_hits);
block_cache/block_cache.c:          session, WT_VERBOSE_DEBUG_2, "block found in cache", hash, addr, addr_size);
block_cache/block_cache.c:        WT_STAT_CONN_INCR(session, block_cache_misses);
block_cache/block_cache.c:          session, WT_VERBOSE_DEBUG_2, "block not found in cache", hash, addr, addr_size);
block_cache/block_cache.c: *     Put a block into the cache.
block_cache/block_cache.c:     * An NVRAM cache is slower than retrieving the block from the OS buffer cache, a DRAM cache is
block_cache/block_cache.c:     * of all file objects is likely to fit in the OS buffer cache, don't use the block cache.
block_cache/block_cache.c:        WT_STAT_CONN_INCR(session, block_cache_bypass_put);
block_cache/block_cache.c:        WT_STAT_CONN_INCR(session, block_cache_bypass_overhead_put);
block_cache/block_cache.c:     * In the case of a read, check if the block is already in the cache: it's possible because two
block_cache/block_cache.c:     * readers can attempt to cache the same overflow block because overflow blocks aren't cached at
block_cache/block_cache.c:     * block is single-threaded at a higher level, and as there should never be a collision, only
block_cache/block_cache.c:                WT_STAT_CONN_INCRV(session, block_cache_bytes_update, data->size);
block_cache/block_cache.c:                WT_STAT_CONN_INCR(session, block_cache_blocks_update);
block_cache/block_cache.c:                  session, WT_VERBOSE_DEBUG_2, "block already in cache", hash, addr, addr_size);
block_cache/block_cache.c:     * Set the recency timestamp on newly inserted blocks to the maximum value to reduce the chance
block_cache/block_cache.c:    WT_STAT_CONN_INCRV(session, block_cache_bytes, data->size);
block_cache/block_cache.c:    WT_STAT_CONN_INCR(session, block_cache_blocks);
block_cache/block_cache.c:        WT_STAT_CONN_INCRV(session, block_cache_bytes_insert_write, data->size);
block_cache/block_cache.c:        WT_STAT_CONN_INCR(session, block_cache_blocks_insert_write);
block_cache/block_cache.c:        WT_STAT_CONN_INCRV(session, block_cache_bytes_insert_read, data->size);
block_cache/block_cache.c:        WT_STAT_CONN_INCR(session, block_cache_blocks_insert_read);
block_cache/block_cache.c:      session, WT_VERBOSE_DEBUG_1, "block inserted in cache", hash, addr, addr_size);
block_cache/block_cache.c: *     Remove a block from the cache.
block_cache/block_cache.c:            WT_STAT_CONN_DECRV(session, block_cache_bytes, blkcache_item->data_size);
block_cache/block_cache.c:            WT_STAT_CONN_DECR(session, block_cache_blocks);
block_cache/block_cache.c:            WT_STAT_CONN_INCR(session, block_cache_blocks_removed);
block_cache/block_cache.c:              session, WT_VERBOSE_DEBUG_1, "block removed from cache", hash, addr, addr_size);
block_cache/block_cache.c: *     Initialize the block cache.
block_cache/block_cache.c:     "block_cache=(blkcache_eviction_aggression=1800,"
block_cache/block_cache.c://block_cache.enabled默认值false，block_cache.enabled使能true后block_cache的其他配置才有效
block_cache/block_cache.c:            WT_RET_MSG(session, ret, "block cache failed to initialize: memkind_create_pmem");
block_cache/block_cache.c:        WT_RET_MSG(session, EINVAL, "NVRAM block cache type requires libmemkind");
block_cache/block_cache.c:        WT_RET(__wt_spin_init(session, &blkcache->hash_locks[i], "block cache bucket locks"));
block_cache/block_cache.c:      "block cache initialized: type=%s, size=%" WT_SIZET_FMT " path=%s",
block_cache/block_cache.c: *     Destroy the block cache and free all memory.
block_cache/block_cache.c:      "block cache with %" PRIu64 " bytes used to be destroyed", blkcache->bytes_used);
block_cache/block_cache.c:    __wt_verbose(session, WT_VERB_BLKCACHE, "%s", "block cache eviction thread exited");
block_cache/block_cache.c:            /* Assert we never left a block pinned. */
block_cache/block_cache.c:                  "block cache reference count of %" PRIu32 " not zero on destroy",
block_cache/block_cache.c:    __blkcache_print_reference_hist(session, "All blocks", blkcache->cache_references);
block_cache/block_cache.c:      session, "Removed blocks", blkcache->cache_references_removed_blocks);
block_cache/block_cache.c:      session, "Evicted blocks", blkcache->cache_references_evicted_blocks);
block_cache/block_cache.c:     * Zeroing the structure has the effect of setting the block cache type to unconfigured.
block_cache/block_cache.c: *     block cache, making it ready for clean initialization.
block_cache/block_cache.c:        __wt_err(session, EINVAL, "block cache reconfiguration not supported");
block_cache/block_cache.c: *     Set up the block cache.
block_cache/block_cache.c:     "block_cache=(blkcache_eviction_aggression=1800,"
block_cache/block_cache.c:        WT_RET_MSG(session, EINVAL, "block cache setup requested for a configured cache");
block_cache/block_cache.c:        if ((ret = __wt_config_gets(session, cfg + 1, "block_cache", &cval)) == WT_NOTFOUND)
block_cache/block_cache.c:    //false默认值，block_cache.enabled使能true后后面的其他配置才有效
block_cache/block_cache.c:    WT_RET(__wt_config_gets(session, cfg, "block_cache.enabled", &cval));
block_cache/block_cache.c:    WT_RET(__wt_config_gets(session, cfg, "block_cache.size", &cval));
block_cache/block_cache.c:        WT_RET_MSG(session, EINVAL, "block cache size must be greater than zero");
block_cache/block_cache.c:    WT_RET(__wt_config_gets(session, cfg, "block_cache.hashsize", &cval));
block_cache/block_cache.c:        WT_RET_MSG(session, EINVAL, "block cache hash size must be between %d and %d entries",
block_cache/block_cache.c:    WT_RET(__wt_config_gets(session, cfg, "block_cache.type", &cval));
block_cache/block_cache.c:        WT_RET(__wt_config_gets(session, cfg, "block_cache.nvram_path", &cval));
block_cache/block_cache.c:        WT_RET_MSG(session, EINVAL, "NVRAM block cache requires libmemkind");
block_cache/block_cache.c:        WT_RET_MSG(session, EINVAL, "Invalid block cache type");
block_cache/block_cache.c:    WT_RET(__wt_config_gets(session, cfg, "block_cache.system_ram", &cval));
block_cache/block_cache.c:    WT_RET(__wt_config_gets(session, cfg, "block_cache.percent_file_in_dram", &cval));
block_cache/block_cache.c:    WT_RET(__wt_config_gets(session, cfg, "block_cache.cache_on_checkpoint", &cval));
block_cache/block_cache.c:    WT_RET(__wt_config_gets(session, cfg, "block_cache.blkcache_eviction_aggression", &cval));
block_cache/block_cache.c:    WT_RET(__wt_config_gets(session, cfg, "block_cache.full_target", &cval));
block_cache/block_cache.c:    WT_RET(__wt_config_gets(session, cfg, "block_cache.cache_on_writes", &cval));
block_cache/block_cache.c:    WT_RET(__wt_config_gets(session, cfg, "block_cache.max_percent_overhead", &cval));
block_cache/block_io.c: *     Read an address-cookie referenced block into a buffer.
block_cache/block_io.c: //__wt_meta_checkpoint获取checkpoint信息，然后__wt_block_checkpoint_load加载checkpoint相关元数据
block_cache/block_io.c:     * If anticipating a compressed or encrypted block, start with a scratch buffer and convert into
block_cache/block_io.c:    /* Check for mapped blocks. */
block_cache/block_io.c:    /* Check the block cache. */
block_cache/block_io.c:    //默认配置不使用block cache
block_cache/block_io.c:    /* Read the block. */
block_cache/block_io.c:     * If the block is encrypted, copy the skipped bytes of the image into place, then decrypt. DRAM
block_cache/block_io.c:     * block-cache blocks are never encrypted.
block_cache/block_io.c:                  "encrypted block for which no decryptor configured"));
block_cache/block_io.c:                  session, ret, addr, addr_size, "block decryption failed"));
block_cache/block_io.c:              "unencrypted block for which encryption configured"));
block_cache/block_io.c:    /* Store the decrypted, possibly compressed, block in the block_cache. */
block_cache/block_io.c:              "compressed block for which no compression configured");
block_cache/block_io.c:         * block we just read (minus the skipped bytes). We don't store the number of compressed
block_cache/block_io.c:              __blkcache_read_corrupt(session, ret, addr, addr_size, "block decompression failed"));
block_cache/block_io.c:    /* If we pulled the block from the block cache, decrement its reference count. */
block_cache/block_io.c: //    ->__wt_blkcache_write->__bm_write->__wt_block_write
block_cache/block_io.c: *     Write a buffer into a block, returning the block's address cookie.
block_cache/block_io.c://buf数据内容 = 包括page header + block header + 实际数据
block_cache/block_io.c:     * Optionally stream-compress the data, but don't compress blocks that are already as small as
block_cache/block_io.c:    /* Call the block manager to write the block. */
block_cache/block_io.c:     * Store a copy of the compressed buffer in the block cache.
block_cache/block_io.c:     * Optional if the write is part of a checkpoint. Hot blocks get written and over-written a lot
block_cache/block_io.c:     * that are not part of checkpoint I/O are done in the service of eviction. Those are the blocks
block_cache/block_io.c:        WT_STAT_CONN_INCR(session, block_cache_bypass_chkpt);
block_cache/block_io.c:        WT_STAT_CONN_INCR(session, block_cache_bypass_writealloc);
block_cache/block_mgr.c: * __bm_close_block_remove --
block_cache/block_mgr.c: *     Remove a single block handle. Must be called with the block lock held.
block_cache/block_mgr.c:__bm_close_block_remove(WT_SESSION_IMPL *session, WT_BLOCK *block)
block_cache/block_mgr.c:    for (i = 0; i < block->related_next; ++i) {
block_cache/block_mgr.c:        --block->related[i]->ref;
block_cache/block_mgr.c:        block->related[i] = NULL;
block_cache/block_mgr.c:    /* Discard the block structure. */
block_cache/block_mgr.c:    return (__wt_block_close(session, block));
block_cache/block_mgr.c: * __bm_close_block --
block_cache/block_mgr.c: *     Close a single block handle, removing the handle if it's no longer useful.
block_cache/block_mgr.c:__bm_close_block(WT_SESSION_IMPL *session, WT_BLOCK *block)
block_cache/block_mgr.c:    __wt_verbose(session, WT_VERB_BLKCACHE, "block close: %s", block->name);
block_cache/block_mgr.c:    __wt_spin_lock(session, &conn->block_lock);
block_cache/block_mgr.c:    if (block->ref > 0 && --block->ref > 0) {
block_cache/block_mgr.c:        __wt_spin_unlock(session, &conn->block_lock);
block_cache/block_mgr.c:      session, block->ckpt_state == WT_CKPT_NONE || block->ckpt_state == WT_CKPT_PANIC_ON_FAILURE);
block_cache/block_mgr.c:     * Every time we remove a block, we may have sufficiently decremented other references to allow
block_cache/block_mgr.c:     * other blocks to be removed. It's unlikely for blocks to reference each other but it's not out
block_cache/block_mgr.c:        TAILQ_FOREACH (block, &conn->blockqh, q)
block_cache/block_mgr.c:            if (block->ref == 0) {
block_cache/block_mgr.c:                WT_TRET(__bm_close_block_remove(session, block));
block_cache/block_mgr.c:    __wt_spin_unlock(session, &conn->block_lock);
block_cache/block_mgr.c:      session, ENOTSUP, "%s: write operation on read-only checkpoint handle", bm->block->name);
block_cache/block_mgr.c:    return (__wt_block_addr_invalid(session, bm->block, addr, addr_size, bm->is_live));
block_cache/block_mgr.c:    return (__wt_block_addr_string(session, bm->block, buf, addr, addr_size));
block_cache/block_mgr.c: * __bm_block_header --
block_cache/block_mgr.c: *     Return the size of the block header.
block_cache/block_mgr.c:__bm_block_header(WT_BM *bm)
block_cache/block_mgr.c:    return (__wt_block_header(bm->block));
block_cache/block_mgr.c: *     Write a buffer into a block, creating a checkpoint.
block_cache/block_mgr.c://reconcile evict流程: __rec_write->__wt_blkcache_write->__bm_write->__wt_block_write
block_cache/block_mgr.c://    ->__wt_blkcache_write->__bm_checkpoint->__wt_block_checkpoint
block_cache/block_mgr.c://    ->__wt_blkcache_write->__bm_write->__wt_block_write
block_cache/block_mgr.c:    WT_BLOCK *block, *tblock;
block_cache/block_mgr.c:    block = bm->block;
block_cache/block_mgr.c:    WT_RET(__wt_block_checkpoint(session, block, buf, ckptbase, data_checksum));
block_cache/block_mgr.c:    if (strcmp(WT_METAFILE, block->name) != 0)
block_cache/block_mgr.c:        __wt_spin_lock(session, &conn->block_lock);
block_cache/block_mgr.c:        TAILQ_FOREACH (tblock, &conn->blockqh, q)
block_cache/block_mgr.c:            if (tblock->close_on_checkpoint) {
block_cache/block_mgr.c:                tblock->close_on_checkpoint = false;
block_cache/block_mgr.c:                __wt_spin_unlock(session, &conn->block_lock);
block_cache/block_mgr.c:                WT_RET(__wt_fsync(session, tblock->fh, true));
block_cache/block_mgr.c:                WT_RET(__bm_close_block(session, tblock));
block_cache/block_mgr.c:    __wt_spin_unlock(session, &conn->block_lock);
block_cache/block_mgr.c:      __wt_block_checkpoint_last(session, bm->block, metadatap, checkpoint_listp, checkpoint));
block_cache/block_mgr.c: *     Write a buffer into a block, creating a checkpoint; readonly version.
block_cache/block_mgr.c:    WT_RET(__wt_block_checkpoint_load(
block_cache/block_mgr.c:      session, bm->block, addr, addr_size, root_addr, root_addr_sizep, checkpoint));
block_cache/block_mgr.c:        WT_RET(__wt_blkcache_map(session, bm->block, &bm->map, &bm->maplen, &bm->mapped_cookie));
block_cache/block_mgr.c:    return (__wt_block_checkpoint_resolve(session, bm->block, failed));
block_cache/block_mgr.c://__checkpoint_tree->__bm_checkpoint_start->__wt_block_checkpoint_start
block_cache/block_mgr.c:    return (__wt_block_checkpoint_start(session, bm->block));
block_cache/block_mgr.c:        WT_TRET(__wt_blkcache_unmap(session, bm->block, bm->map, bm->maplen, &bm->mapped_cookie));
block_cache/block_mgr.c:    WT_TRET(__wt_block_checkpoint_unload(session, bm->block, !bm->is_live));
block_cache/block_mgr.c:    ret = __bm_close_block(session, bm->block);
block_cache/block_mgr.c: *     End a block manager compaction.
block_cache/block_mgr.c:    return (__wt_block_compact_end(session, bm->block));
block_cache/block_mgr.c: *     End a block manager compaction; readonly version.
block_cache/block_mgr.c:    return (__wt_block_compact_page_rewrite(session, bm->block, addr, addr_sizep, writtenp));
block_cache/block_mgr.c:    return (__wt_block_compact_page_skip(session, bm->block, addr, addr_size, skipp));
block_cache/block_mgr.c:    __wt_block_compact_progress(session, bm->block, msg_countp);
block_cache/block_mgr.c:    return (__wt_block_compact_skip(session, bm->block, skipp));
block_cache/block_mgr.c: *     Start a block manager compaction.
block_cache/block_mgr.c:    return (__wt_block_compact_start(session, bm->block));
block_cache/block_mgr.c: *     Start a block manager compaction; readonly version.
block_cache/block_mgr.c: *     Free a block of space to the underlying file.
block_cache/block_mgr.c://__rec_write_wrapup->__wt_btree_block_free->__bm_free
block_cache/block_mgr.c:    /* Evict the freed block from the block cache */
block_cache/block_mgr.c:    return (__wt_block_free(session, bm->block, addr, addr_size));
block_cache/block_mgr.c: *     Free a block of space to the underlying file; readonly version.
block_cache/block_mgr.c:    handle = bm->block->fh->handle;
block_cache/block_mgr.c: *     Read an address cookie referenced block into a buffer.
block_cache/block_mgr.c: *     End a block manager salvage.
block_cache/block_mgr.c:    return (__wt_block_salvage_end(session, bm->block));
block_cache/block_mgr.c: *     End a block manager salvage; readonly version.
block_cache/block_mgr.c: *     Return the next block from the file; readonly version.
block_cache/block_mgr.c: *     Return the next block from the file.
block_cache/block_mgr.c:    return (__wt_block_salvage_next(session, bm->block, addr, addr_sizep, eofp));
block_cache/block_mgr.c: *     Start a block manager salvage.
block_cache/block_mgr.c:    return (__wt_block_salvage_start(session, bm->block));
block_cache/block_mgr.c: *     Start a block manager salvage; readonly version.
block_cache/block_mgr.c: *     Inform salvage a block is valid.
block_cache/block_mgr.c:    return (__wt_block_salvage_valid(session, bm->block, addr, addr_size, valid));
block_cache/block_mgr.c: *     Inform salvage a block is valid; readonly version.
block_cache/block_mgr.c:    __wt_block_stat(session, bm->block, stats);
block_cache/block_mgr.c:    WT_BLOCK *block, *current;
block_cache/block_mgr.c:    current = bm->block;
block_cache/block_mgr.c:    WT_RET(__wt_blkcache_tiered_open(session, NULL, objectid, &block));
block_cache/block_mgr.c:      session, WT_VERB_TIERED, "block manager switching from %s to %s", current->name, block->name);
block_cache/block_mgr.c:    if (block == current)
block_cache/block_mgr.c:        return (__bm_close_block(session, block));
block_cache/block_mgr.c:    WT_RET(__wt_block_checkpoint_load(session, block, NULL, 0, NULL, &root_addr_size, false));
block_cache/block_mgr.c:     * Swap out the block manager's default handler.
block_cache/block_mgr.c:     * FIXME: the new block handle reasonably has different methods for objects in different backing
block_cache/block_mgr.c:    bm->block = block;
block_cache/block_mgr.c:__bm_sync(WT_BM *bm, WT_SESSION_IMPL *session, bool block)
block_cache/block_mgr.c:    return (__wt_fsync(session, bm->block->fh, block));
block_cache/block_mgr.c:    return (__wt_block_verify_addr(session, bm->block, addr, addr_size));
block_cache/block_mgr.c: *     End a block manager verify.
block_cache/block_mgr.c:    return (__wt_block_verify_end(session, bm->block));
block_cache/block_mgr.c: *     Start a block manager verify.
block_cache/block_mgr.c:    return (__wt_block_verify_start(session, bm->block, ckptbase, cfg));
block_cache/block_mgr.c: *     Write a buffer into a block, returning the block's address cookie.
block_cache/block_mgr.c: //buf数据内容 = 包括page header + block header + 实际数据
block_cache/block_mgr.c://    ->__wt_blkcache_write->__bm_checkpoint->__wt_block_checkpoint
block_cache/block_mgr.c://    ->__wt_blkcache_write->__bm_write->__wt_block_write
block_cache/block_mgr.c://checkpoint流程: __rec_write->__wt_blkcache_write->__bm_write->__wt_block_write
block_cache/block_mgr.c:      __wt_block_write(session, bm->block, buf, addr, addr_sizep, data_checksum, checkpoint_io));
block_cache/block_mgr.c: *     Write a buffer into a block, returning the block's address cookie; readonly version.
block_cache/block_mgr.c: *     Return the buffer size required to write a block.
block_cache/block_mgr.c: */ //获取//block size = WT_PAGE_HEADER_SIZE + WT_BLOCK_HEADER_SIZE + 实际数据sizep
block_cache/block_mgr.c:    //block size = WT_PAGE_HEADER_SIZE + WT_BLOCK_HEADER_SIZE + 实际数据sizep
block_cache/block_mgr.c:    return (__wt_block_write_size(session, bm->block, sizep));
block_cache/block_mgr.c: *     Return the buffer size required to write a block; readonly version.
block_cache/block_mgr.c:    bm->block_header = __bm_block_header;
block_cache/block_mgr.c:    bm->size = __wt_block_manager_size;
block_cache/block_mgr.c:        WT_ERR(__wt_block_open(session, uri, WT_TIERED_OBJECTID_NONE, cfg, forced_salvage, readonly,
block_cache/block_mgr.c:          false, allocsize, &bm->block));
block_cache/block_mgr.c:        WT_ERR(__wt_blkcache_tiered_open(session, uri, 0, &bm->block));
block_cache/block_mgr.c: *     Set the block API to read-only.
btree/bt_compact.c:    /* If rewriting the page, have reconciliation write new blocks. */
btree/bt_compact.c:     * Skip deleted pages but consider them progress (the on-disk block is discarded by the next
btree/bt_compact.c:     * If it's on-disk, get a copy of the address and ask the block manager to rewrite the block if
btree/bt_compact.c:     * original block and the write of the new block), plus whatever overhead that entails. It's not
btree/bt_compact.c:     * ideal, we could release the lock, but then we'd have to deal with the block having been read
btree/bt_compact.c:     * case where we found an on-disk page and either rewrite the block successfully or failed to
btree/bt_compact.c:     * more calls to the underlying block manager which is going to search the list of extents to
btree/bt_compact.c:     * figure out if the block is worth rewriting. It's not ideal because we're blocking the
btree/bt_compact.c:     * We could corrupt a checkpoint if we moved a block that's part of the checkpoint, that is, if
btree/bt_compact.c:     * we race with checkpoint's review of the tree. Get the tree's flush lock which blocks threads
btree/bt_compact.c:    /* Unblock checkpoint threads. */
btree/bt_compact.c:        __wt_block_compact_get_progress_stats(
btree/bt_delete.c:     * We cannot truncate pages that have overflow key/value items as the overflow blocks have to be
btree/bt_delete.c:        WT_STAT_CONN_INCRV(session, page_del_rollback_blocked, sleep_usecs);
btree/bt_import.c:     * Open the file, request block manager checkpoint information. We don't know the allocation
btree/bt_import.c:     * size, but 512B allows us to read the descriptor block and that's all we care about.
btree/bt_import.c:    WT_ERR(__wt_config_getones(session, metadata, "block_metadata_encrypted", &v));
btree/bt_import.c:    WT_ERR(__wt_config_getones(session, metadata, "block_metadata", &v));
btree/bt_import.c:     * size. When we did this earlier, we were able to read the descriptor block properly but the
btree/bt_import.c:     * right. The block manager returned the corrected final checkpoint, put it all together.
btree/bt_ovfl.c:     * Read the overflow item from the block manager, then reference the start of the data and set
btree/bt_ovfl.c:     * backing blocks are removed. However, this gets hard because the snapshot transaction reader
btree/bt_ovfl.c:     *     - checkpoint runs, frees the backing blocks
btree/bt_ovfl.c:     *     - another thread allocates and overwrites the blocks
btree/bt_ovfl.c:     *     - the reader wakes up and uses the on-page cell to read the blocks
btree/bt_ovfl.c:     * The second problem is to only remove the underlying blocks once, also solved by checking the
btree/bt_ovfl.c:     * blocks to be freed when reconciliation completes.
btree/bt_ovfl.c:     * Acquire the overflow lock to avoid racing with a thread reading the backing overflow blocks.
btree/bt_ovfl.c:    /* Free the backing disk blocks. */
btree/bt_random.c:     * Use the underlying file size divided by its block allocation size as
btree/bt_stat.c:    WT_STAT_SET(session, stats, rec_multiblock_max, btree->rec_multiblock_max);
btree/bt_slvg.c:    /* If need to free blocks backing merged page ranges. */
btree/bt_slvg.c:     * Physical information about the file block.
btree/bt_slvg.c:static int __slvg_merge_block_free(WT_SESSION_IMPL *, WT_STUFF *);
btree/bt_slvg.c:     * XXX The salvage process reads and discards previous checkpoints, so the underlying block
btree/bt_slvg.c:    WT_ERR(__wt_meta_block_metadata(session, config, ckptbase));
btree/bt_slvg.c:     * Inform the underlying block manager that we're salvaging the file.
btree/bt_slvg.c:     * expect to see corrupted blocks.
btree/bt_slvg.c:     * Add unreferenced overflow page blocks to the free list so they are reused immediately.
btree/bt_slvg.c:     * internal page might allocate those free'd file blocks, and if the salvage run subsequently
btree/bt_slvg.c:        WT_ERR(__slvg_merge_block_free(session, ss));
btree/bt_slvg.c:     * Inform the underlying block manager that we're done.
btree/bt_slvg.c:        /* Get the next block address from the block manager. */
btree/bt_slvg.c:         * Read (and potentially decompress) the block; the underlying block manager might return
btree/bt_slvg.c:         * only good blocks if checksums are configured, or both good and bad blocks if we're
btree/bt_slvg.c:         * Report the block's status to the block manager.
btree/bt_slvg.c:         * Column-store fixed-sized format: start and stop keys can be taken from the block's
btree/bt_slvg.c:         * Column-store variable-length format: the start key can be taken from the block's header,
btree/bt_slvg.c:         * range. Note, that requires an additional pass to free the merge page's backing blocks.
btree/bt_slvg.c:     * We can't discard the original blocks associated with this page now. (The problem is we don't
btree/bt_slvg.c:     * blocks now, the next merge page we write might allocate those blocks and overwrite them, and
btree/bt_slvg.c:     * the reference addr so eviction doesn't free the underlying blocks.
btree/bt_slvg.c:     * value is an overflow item, reconciliation will free the underlying object's backing blocks.
btree/bt_slvg.c:     * used, reconciliation will free the underlying object's backing blocks, which is fine, but we
btree/bt_slvg.c:     * need to adjust our list of overflow blocks so we don't free the overflow item twice.
btree/bt_slvg.c:     * Intercept any attempt by reconciliation to free blocks.
btree/bt_slvg.c:     * never used, reconciliation will free the underlying object's backing blocks. We'll set up a
btree/bt_slvg.c:     * callback to track the blocks that are freed, mark all page overflow values as "referenced" so
btree/bt_slvg.c:         * range. Note, that requires an additional pass to free the merge page's backing blocks.
btree/bt_slvg.c:     * We can't discard the original blocks associated with this page now. (The problem is we don't
btree/bt_slvg.c:     * blocks now, the next merge page we write might allocate those blocks and overwrite them, and
btree/bt_slvg.c:     * the reference addr so eviction doesn't free the underlying blocks.
btree/bt_slvg.c:     * blocks. That's a problem when merging pages if the key is an overflow item: if we're
btree/bt_slvg.c:     * the key. Intercept any attempt by reconciliation to free blocks.
btree/bt_slvg.c: *     Block manager replacement to update blocks reconciliation wants removed.
btree/bt_slvg.c:                 * Convert each block address into a slot in the list of overflow pages as we go.
btree/bt_slvg.c: * __slvg_merge_block_free --
btree/bt_slvg.c: *     Clean up backing file and overflow blocks after the merge phase.
btree/bt_slvg.c:__slvg_merge_block_free(WT_SESSION_IMPL *session, WT_STUFF *ss)
btree/bt_slvg.c:    /* Free any underlying file blocks for merged pages. */
btree/bt_slvg.c:     * Walk the overflow page array: if an overflow page isn't referenced, add its file blocks to
btree/bt_slvg.c: * __slvg_trk_free_block --
btree/bt_slvg.c: *     Discard underlying blocks.
btree/bt_slvg.c:__slvg_trk_free_block(WT_SESSION_IMPL *session, WT_TRACK *trk)
btree/bt_slvg.c:     * If freeing underlying file blocks or overflow pages, this is a page we were tracking but
btree/bt_slvg.c:    __wt_verbose(session, WT_VERB_SALVAGE, "%s blocks discarded: discard freed file bytes %" PRIu32,
btree/bt_slvg.c: *     Discard a WT_TRACK structure and (optionally) its underlying blocks.
btree/bt_slvg.c:         * blocks. As we're the last user of those blocks, nobody is going to use them and they can
btree/bt_slvg.c:            WT_RET(__slvg_trk_free_block(session, trk));
btree/bt_cursor.c:    /* Check what the block manager can actually write. */
btree/bt_cursor.c:          session, ret, "item size of %" WT_SIZET_FMT " refused by block manager", kv->size);
btree/bt_debug.c:     * This routine depends on the default block manager's view of files, where an address consists
btree/bt_debug.c:    WT_RET(__wt_block_read_off_blind(session, S2BT(session)->bm->block, offset, &size, &checksum));
btree/bt_debug.c:    WT_BLOCK *block;
btree/bt_debug.c:     * This routine depends on the default block manager's view of files, where an address consists
btree/bt_debug.c:     * of a file ID, file offset, length, and checksum. This is only for debugging, other block
btree/bt_debug.c:     * managers might not describe underlying objects the same way, that's why there's no block
btree/bt_debug.c:    block = S2BT(session)->bm->block;
btree/bt_debug.c:    WT_RET(__wt_block_addr_pack(block, &endp, block->objectid, offset, size, checksum));
btree/bt_debug.c:     * Read the address through the btree I/O functions (so the block is decompressed and/or
btree/bt_debug.c:            WT_RET(ds->f(ds, ", multiblock"));
btree/bt_discard.c:        /* Free list of replacement blocks. */
btree/bt_handle.c:    /* Connect to the underlying block manager. */
btree/bt_handle.c:     * As part of block-manager configuration, we need to return the maximum
btree/bt_handle.c:     * sized address cookie that a block manager will ever return.  There's
btree/bt_handle.c:     * a Btree with 512B internal pages.  The default block manager packs
btree/bt_handle.c:     * now, but when we create a block manager extension API, we need some
btree/bt_handle.c:     * way to consider the block manager's maximum cookie size versus the
btree/bt_handle.c:    btree->block_header = bm->block_header(bm);
btree/bt_handle.c:          __wt_ckpt_verbose(session, bm->block, "__wt_block_checkpoint_load load after: ", NULL, root_addr, root_addr_size);
btree/bt_handle.c:     * isn't a big deal, but the backing blocks for the handle may not yet have been discarded from
btree/bt_handle.c:    /* Discard any underlying block manager resources. */
btree/bt_handle.c:        /* Close the underlying block manager reference. */
btree/bt_handle.c:     * The metadata isn't blocked by in-memory cache limits because metadata "unroll" is performed
btree/bt_handle.c:     * by updates that are potentially blocked by the cache-full checks.
btree/bt_handle.c:    WT_RET(__wt_config_gets_none(session, cfg, "block_compressor", &cval));
btree/bt_handle.c: //    ->__wt_blkcache_write->__bm_write->__wt_block_write
btree/bt_handle.c: //__wt_block_checkpoint->__ckpt_process进行checkpoint相关元数据持久化
btree/bt_handle.c: //__wt_meta_checkpoint获取checkpoint信息，然后__wt_block_checkpoint_load加载checkpoint相关元数据
btree/bt_handle.c:    uint64_t block_preload;
btree/bt_handle.c:    block_preload = 0;
btree/bt_handle.c:            ++block_preload;
btree/bt_handle.c:    WT_STAT_CONN_INCRV(session, block_preload, block_preload);
btree/bt_misc.c:        return ("block manager");
btree/bt_misc.c:        return ("block manager");
btree/bt_read.c:     * Don't pass an allocated buffer to the underlying block read function, force allocation of new
btree/bt_read.c:                WT_STAT_CONN_INCR(session, page_read_blocked);
btree/bt_read.c:                WT_STAT_CONN_INCR(session, page_locked_blocked);
btree/bt_read.c:                WT_STAT_CONN_INCR(session, page_busy_blocked);
btree/bt_read.c:                    WT_STAT_CONN_INCR(session, page_forcible_evict_blocked);
btree/bt_split.c:     * been deleted, delete it along with any backing blocks.
btree/bt_split.c:    /* Leak blocks rather than try this twice. */
btree/bt_split.c:     * longer reference the block image that remains with the page being split.
btree/bt_split.c:     * key hasn't been deleted, delete it now, including its backing blocks. We are exchanging the
btree/bt_split.c:     * blocks, but the parent page would be unaffected).
btree/bt_split.c:    /* Free the backing block and address. */
btree/bt_split.c:    WT_TRET(__wt_ref_block_free(session, ref));
btree/bt_split.c:     * frees the blocks for the deleted pages, which can corrupt the free list calculated by the
btree/bt_split.c:     * The new page index is in place. Threads cursoring in the tree are blocked because the WT_REF
btree/bt_split.c:     * locked state to split unblocks those threads and causes them to re-calculate their position
btree/bt_split.c:     * to use a different lock if we have to block reconciliation anyway.
btree/bt_split.c:     * prevents eviction because reconciliation is blocked. However, if the page were clean, it
btree/bt_split.c: *     Move a multi-block entry into a WT_REF structure.
btree/bt_split.c:     * Convert the split page's multiblock reconciliation information into an array of page
btree/bt_sync.c:     * 5. there's already an address for every disk block involved.
btree/bt_sync.c:     * not every block associated with the page has a disk address. We can't skip such pages because
btree/bt_sync.c:        tag = "reconciled multi-block";
btree/bt_sync.c:        tag = "reconciled replacement block";
btree/bt_sync.c:         * pages nor can underlying blocks be freed until the checkpoint's block lists are stable.
btree/bt_sync.c:         * consistent view of that namespace. Set the checkpointing flag to block such actions and
btree/bt_vrfy.c:    ((vs)->dump_address || (vs)->dump_blocks || (vs)->dump_layout || (vs)->dump_pages)
btree/bt_vrfy.c:    bool dump_blocks;
btree/bt_vrfy.c:    WT_RET(__wt_config_gets(session, cfg, "dump_blocks", &cval));
btree/bt_vrfy.c:    vs->dump_blocks = cval.val != 0;
btree/bt_vrfy.c:    if (vs->dump_blocks || vs->dump_pages)
btree/bt_vrfy.c: *     Debugging: optionally dump specific blocks from the file.
btree/bt_vrfy.c:         * Quit after dumping the requested blocks. (That's hopefully what the user wanted, all of
btree/bt_vrfy.c:         * this stuff is just hooked into verify because that's where we "dump blocks" for
btree/bt_vrfy.c:    /* Optionally dump specific block offsets. */
btree/bt_vrfy.c:    /* Inform the underlying block manager we're verifying. */
btree/bt_vrfy.c:    /* Inform the underlying block manager we're done. */
btree/bt_vrfy.c: *     Check an address block's timestamps.
btree/bt_vrfy.c:    /* Optionally dump the blocks or page in debugging mode. */
btree/bt_vrfy.c:    if (vs->dump_blocks && page->type != WT_PAGE_ROW_LEAF)
btree/bt_vrfy.c:            /* Unpack the address block and check timestamps */
btree/bt_vrfy.c:            /* Unpack the address block and check timestamps */
btree/bt_vrfy_dsk.c: *     Verify a single block as read from disk.
btree/bt_walk.c:        WT_STAT_CONN_INCRV(session, page_index_slot_ref_blocked, sleep_usecs);
checksum/power8/vec_crc32.c:    unsigned long block_size;
checksum/power8/vec_crc32.c:    int next_block = 0;
checksum/power8/vec_crc32.c:    /* Align by 128 bits. The last 128 bit block will be processed at end. */
checksum/power8/vec_crc32.c:            /* Checksum in blocks of MAX_SIZE. */
checksum/power8/vec_crc32.c:            block_size = length;
checksum/power8/vec_crc32.c:            if (block_size > MAX_SIZE) {
checksum/power8/vec_crc32.c:                block_size = MAX_SIZE;
checksum/power8/vec_crc32.c:            length = length - block_size;
checksum/power8/vec_crc32.c:            offset = (MAX_SIZE / 8) - (block_size / 8);
checksum/power8/vec_crc32.c:            chunks = (block_size / 128) - 1;
checksum/power8/vec_crc32.c:            /* Check if we have more blocks to process */
checksum/power8/vec_crc32.c:            next_block = 0;
checksum/power8/vec_crc32.c:                next_block = 1;
checksum/power8/vec_crc32.c:        } while (next_block);
checksum/zseries/crc32le-vx.sx: * The CRC-32 constant block contains reduction constants to fold and
config/config_def.c:static const WT_CONFIG_CHECK confchk_wiredtiger_open_block_cache_subconfigs[] = {
config/config_def.c:  {"block_cache", "category", NULL, NULL, confchk_wiredtiger_open_block_cache_subconfigs, 12},
config/config_def.c:    "choices=[\"api\",\"backup\",\"block\",\"block_cache\","
config/config_def.c:  {"block_allocation", "string", NULL, "choices=[\"best\",\"first\"]", NULL, 0},
config/config_def.c:  {"block_compressor", "string", NULL, NULL, NULL, 0},
config/config_def.c:  {"dump_address", "boolean", NULL, NULL, NULL, 0}, {"dump_blocks", "boolean", NULL, NULL, NULL, 0},
config/config_def.c:  {"block_allocation", "string", NULL, "choices=[\"best\",\"first\"]", NULL, 0},
config/config_def.c:  {"block_compressor", "string", NULL, NULL, NULL, 0},
config/config_def.c:  {"block_allocation", "string", NULL, "choices=[\"best\",\"first\"]", NULL, 0},
config/config_def.c:  {"block_compressor", "string", NULL, NULL, NULL, 0},
config/config_def.c:  {"block_allocation", "string", NULL, "choices=[\"best\",\"first\"]", NULL, 0},
config/config_def.c:  {"block_compressor", "string", NULL, NULL, NULL, 0},
config/config_def.c:  {"block_allocation", "string", NULL, "choices=[\"best\",\"first\"]", NULL, 0},
config/config_def.c:  {"block_compressor", "string", NULL, NULL, NULL, 0},
config/config_def.c:  {"block_allocation", "string", NULL, "choices=[\"best\",\"first\"]", NULL, 0},
config/config_def.c:  {"block_compressor", "string", NULL, NULL, NULL, 0}, {"bucket", "string", NULL, NULL, NULL, 0},
config/config_def.c:  {"block_allocation", "string", NULL, "choices=[\"best\",\"first\"]", NULL, 0},
config/config_def.c:  {"block_compressor", "string", NULL, NULL, NULL, 0},
config/config_def.c:  {"block_cache", "category", NULL, NULL, confchk_wiredtiger_open_block_cache_subconfigs, 12},
config/config_def.c:    "choices=[\"api\",\"backup\",\"block\",\"block_cache\","
config/config_def.c:  {"block_cache", "category", NULL, NULL, confchk_wiredtiger_open_block_cache_subconfigs, 12},
config/config_def.c:    "choices=[\"api\",\"backup\",\"block\",\"block_cache\","
config/config_def.c:  {"block_cache", "category", NULL, NULL, confchk_wiredtiger_open_block_cache_subconfigs, 12},
config/config_def.c:    "choices=[\"api\",\"backup\",\"block\",\"block_cache\","
config/config_def.c:  {"block_cache", "category", NULL, NULL, confchk_wiredtiger_open_block_cache_subconfigs, 12},
config/config_def.c:    "choices=[\"api\",\"backup\",\"block\",\"block_cache\","
config/config_def.c:    "block_cache=(blkcache_eviction_aggression=1800,"
config/config_def.c:    "read_timestamp=none,write_timestamp=off),block_allocation=best,"
config/config_def.c:    "block_compressor=,cache_resident=false,checksum=on,colgroups=,"
config/config_def.c:    "do_not_clear_txn_id=false,dump_address=false,dump_blocks=false,"
config/config_def.c:    "read_timestamp=none,write_timestamp=off),block_allocation=best,"
config/config_def.c:    "block_compressor=,cache_resident=false,checksum=on,collator=,"
config/config_def.c:    "read_timestamp=none,write_timestamp=off),block_allocation=best,"
config/config_def.c:    "block_compressor=,cache_resident=false,checkpoint=,"
config/config_def.c:    "read_timestamp=none,write_timestamp=off),block_allocation=best,"
config/config_def.c:    "block_compressor=,cache_resident=false,checksum=on,chunks=,"
config/config_def.c:    "read_timestamp=none,write_timestamp=off),block_allocation=best,"
config/config_def.c:    "block_compressor=,cache_resident=false,checkpoint=,"
config/config_def.c:    "read_timestamp=none,write_timestamp=off),block_allocation=best,"
config/config_def.c:    "block_compressor=,bucket=,bucket_prefix=,cache_directory=,"
config/config_def.c:    "read_timestamp=none,write_timestamp=off),block_allocation=best,"
config/config_def.c:    "block_compressor=,cache_resident=false,checkpoint=,"
config/config_def.c:    "block_cache=(blkcache_eviction_aggression=1800,"
config/config_def.c:    "block_cache=(blkcache_eviction_aggression=1800,"
config/config_def.c:    "block_cache=(blkcache_eviction_aggression=1800,"
config/config_def.c:    "block_cache=(blkcache_eviction_aggression=1800,"
conn/api_calc_modify.c:    /* Step past the end and before the beginning of the matching block. */
conn/api_calc_modify.c: *     Calculate an integral "fingerprint" of a block of bytes.
conn/conn_tiered.c:             * object sweep to clean up block->ofh file handles. Another alternative would be to try
conn/conn_api.c:Wiredtiger_begin_transaction_block_bm.cpp (src\mongo\db\storage\wiredtiger):        _conn->close(_conn, nullptr);
conn/conn_api.c:    WT_RET(__wt_calloc_def(session, conn->hash_size, &conn->blockhash));
conn/conn_api.c:        TAILQ_INIT(&conn->blockhash[i]);
conn/conn_api.c:例如verbose=[api=5,block=5,checkpoint=5,checkpoint_progress=5,compact=5,evict=5,evict_stuck=5,evictserver=5,fileops=5,handleops=5,log=5,lsm=5,lsm_manager=5,metadata=5,mutex=5,overflow=5,read=5,reconcile=5,reconcile=5,recovery=5,recovery_progress=5,salvage=5,shared_cache=5,split=5,thread_group=5,split=5,thread_group=5,timestamp=5,transaction=5,verify=5,version=5,write=5]
conn/conn_api.c:      {"backup", WT_VERB_BACKUP}, {"block", WT_VERB_BLOCK}, {"block_cache", WT_VERB_BLKCACHE},
conn/conn_ckpt.c:     * Checkpoint does enough I/O it may be called upon to perform slow operations for the block
conn/conn_dhandle.c:        //    "access_pattern_hint=none,allocation_size=4KB,allocation_size=8KB,allocation_size=18KB,app_metadata=,assert=(commit_timestamp=none,durable_timestamp=none,read_timestamp=none,write_timestamp=off),block_allocation=best,block_compressor=,cache_resident=false,checkpoint=,checkpoint_backup_info=,checkpoint_lsn=,checksum=on,collator=,columns=,dictionary=0,encryption=(keyid=,name=),format=btree,huffman_key=,huffman_value=,id=0,ignore_in_memory_cache_size=false,internal_item_max=0,internal_key_max=0,internal_key_truncate=true,internal_page_max=4KB,key_format=S,key_gap=10,leaf_item_max=0,leaf_key_max=0,leaf_page_max=32KB,leaf_value_max=0,log=(enabled=true),memory_page_image_max=0,memory_page_max=5MB,os_cache_dirty_max=0,os_cache_max=0,prefix_compression=false,prefix_compression_min=4,readonly=false,split_deepen_min_child=0,split_deepen_per_child=0,split_pct=90,tiered_object=false,tiered_storage=(auth_token=,bucket=,bucket_prefix=,cache_directory=,local_retention=300,name=,object_target_size=0),value_format=S,verbose=[],version=(major=2,minor=1),write_timestamp_usage=none";;
conn/conn_dhandle.c:        //metaconf="access_pattern_hint=none,allocation_size=4KB,allocation_size=8KB,allocation_size=18KB,app_metadata=,assert=(commit_timestamp=none,durable_timestamp=none,read_timestamp=none,write_timestamp=off),block_allocation=best,block_compressor=,cache_resident=false,checkpoint=,checkpoint_backup_info=,checkpoint_lsn=,checksum=on,collator=,columns=,dictionary=0,encryption=(keyid=,name=),format=btree,huffman_key=,huffman_value=,id=0,ignore_in_memory_cache_size=false,internal_item_max=0,internal_key_max=0,internal_key_truncate=true,internal_page_max=4KB,key_format=S,key_gap=10,leaf_item_max=0,leaf_key_max=0,leaf_page_max=32KB,leaf_value_max=0,log=(enabled=true),memory_page_image_max=0,memory_page_max=5MB,os_cache_dirty_max=0,os_cache_max=0,prefix_compression=false,prefix_compression_min=4,readonly=false,split_deepen_min_child=0,split_deepen_per_child=0,split_pct=90,tiered_object=false,tiered_storage=(auth_token=,bucket=,bucket_prefix=,cache_directory=,local_retention=300,name=,object_target_size=0),value_format=S,verbose=[],version=(major=2,minor=1),write_timestamp_usage=none";
conn/conn_dhandle.c:     * reasons. However, the underlying block manager "owns" information about memory mappings, and
conn/conn_dhandle.c:     * that, the block manager asserts there are never two references to a block manager object, and
conn/conn_dhandle.c:     * operation is closed, there won't be updates in the tree that can block the close.
conn/conn_handle.c:     * Block manager. XXX If there's ever a second block manager, we'll want to make this more
conn/conn_handle.c:    WT_RET(__wt_spin_init(session, &conn->block_lock, "block manager"));
conn/conn_handle.c:    TAILQ_INIT(&conn->blockqh); /* Block manager list */
conn/conn_handle.c:    __wt_spin_destroy(session, &conn->block_lock);
conn/conn_handle.c:    __wt_free(session, conn->blockhash);
conn/conn_open.c:    /* Shut down the block cache */
conn/conn_open.c:     * started before any operation that can commit, or the commit can block.
conn/conn_sweep.c:     * We don't set WT_DHANDLE_EXCLUSIVE deliberately, we want opens to block on us and then retry
conn/conn_sweep.c:     * Handle sweep does enough I/O it may be called upon to perform slow operations for the block
conn/conn_sweep.c:     * manager. Sweep should not block due to the cache being full.
cursor/cur_backup.c: *     Restore any incremental backup information. We use the metadata's block information as the
cursor/cur_backup.c: *     Add the identifier for block based incremental backup.
cursor/cur_backup.c: *     Find the source identifier for block based incremental backup. Error if it is not a valid id.
cursor/cur_backup.c:     * Duplicate backup cursors are only for log targets or block-based incremental backups. But log
cursor/cur_backup.c:     * targets don't make sense with block-based incremental backup.
cursor/cur_backup.c:          "duplicate backup cursor must be for block-based incremental or logging backup");
cursor/cur_backup.c:          session, EINVAL, "block-based incremental backup incompatible with a list of targets");
cursor/cur_backup.c:    /* Return an error if block-based incremental backup is performed with open LSM trees. */
cursor/cur_backup.c:        WT_ERR_MSG(session, ENOTSUP, "LSM does not work with block-based incremental backup");
cursor/cur_backup.c:         * The hot backup copy is done outside of WiredTiger, which means file blocks can't be freed
cursor/cur_backup.c:         * as we've set the flag, we don't want to block checkpoints, we just want to make sure no
cursor/cur_backup.c:     * To support a block manager where that's not the case, we'd need
cursor/cur_backup.c:     * to call into the block manager and get a list of physical files
cursor/cur_backup.c:     * that for now, that block manager might not even support physical
cursor/cur_log.c:        /* Log cursors block removal. */
cursor/cur_stat.c:        WT_RET(__wt_block_manager_named_size(session, filename, &size));
cursor/cur_stat.c:        cst->u.dsrc_stats.block_size = size;
cursor/cur_version.c:         * visited this page and freed the underlying overflow blocks. In this case, checkpoint
cursor/cur_backup_incr.c:        WT_RET_MSG(session, WT_ERROR, "corrupted modified block list");
cursor/cur_backup_incr.c: *     Get the block modifications for a tree from its metadata and fill in the backup cursor's
cursor/cur_backup_incr.c:         * granularity should be set to something. But nbits may be 0 if there are no blocks
cursor/cur_backup_incr.c:          "Found modified incr block gran %" PRIu64 " nbits %" PRIu64 " offset %" PRIu64,
cursor/cur_backup_incr.c:        __wt_verbose_debug2(session, WT_VERB_BACKUP, "Modified incr block config: \"%s\"", config);
cursor/cur_backup_incr.c:         * forces full copies, there is no need to traverse the blocks information.
cursor/cur_backup_incr.c:             * We found a match. Load the block information into the cursor.
cursor/cur_backup_incr.c:            if ((ret = __wt_config_subgets(session, &v, "blocks", &b)) == 0) {
cursor/cur_backup_incr.c:             * Get a list of the block modifications for the file. The block modifications are from
cursor/cur_backup_incr.c:             * There are several cases where we do not have block modification information for
cursor/cur_file.c:     * the dhandle, which causes us to block until any running checkpoint finishes. This is
docs/Doxyfile:# multi-line C++ special comment block (i.e. a block of //! or /// comments) as
docs/Doxyfile:# to treat a multi-line C++ comment block as a detailed description. Set this
docs/Doxyfile:# documentation blocks found inside the body of a function. If set to NO, these
docs/Doxyfile:# blocks will be appended to the function's detailed documentation block.
docs/Doxyfile:# ... \endcond blocks.
docs/Doxyfile:# special comment blocks from generated source code fragments. Normal C, C++ and
docs/Doxyfile:# of the possible markers and block names see the documentation.
docs/Doxyfile:# to create new LaTeX commands to be used in formulas as building blocks. See
docs/Doxyfile:# the !include statement in a plantuml block.
docs/Doxyfile.9:# multi-line C++ special comment block (i.e. a block of //! or /// comments) as
docs/Doxyfile.9:# to treat a multi-line C++ comment block as a detailed description. Set this
docs/Doxyfile.9:# documentation blocks is shown as doxygen documentation.
docs/Doxyfile.9:# documentation blocks found inside the body of a function. If set to NO, these
docs/Doxyfile.9:# blocks will be appended to the function's detailed documentation block.
docs/Doxyfile.9:# ... \endcond blocks.
docs/Doxyfile.9:# special comment blocks from generated source code fragments. Normal C, C++ and
docs/Doxyfile.9:# of the possible markers and block names see the documentation.
docs/Doxyfile.9:# to create new LaTeX commands to be used in formulas as building blocks. See
docs/Doxyfile.9:# description of the possible markers and block names see the documentation.
docs/Doxyfile.9:# the !include statement in a plantuml block.
docs/arch-backup.dox:and schema locks to block database file modifications while generating the list files. There
docs/arch-backup.dox:Block-based incremental backup is performed by tracking the modified blocks in the checkpoint.
docs/arch-backup.dox:Whenever a new checkpoint occurs on a file, any new or modified blocks in this checkpoint are
docs/arch-backup.dox:@ref backup_incremental-block for more information on how to use the block-based incremental backup.
docs/arch-backup.dox:block-based incremental backup. Please refer to @ref backup_duplicate for more details.
docs/arch-block.dox:/*! @arch_page arch-block Block Manager
docs/arch-block.dox:The WiredTiger block manager subsystem manages the reading and writing of data
docs/arch-block.dox:@section block What is a block?
docs/arch-block.dox:A block is a chunk of data that is stored on the disk and operated on as a
docs/arch-block.dox:\c .wt suffix) is made up of these blocks. Each block consists of a page header,
docs/arch-block.dox:a block header and contains a single page of the btree from which it was
docs/arch-block.dox:generated. WiredTiger is a no-overwrite storage engine, and when blocks are
docs/arch-block.dox:re-written, they are written to new locations in the file. The size of a block
docs/arch-block.dox:Once a block is written an address cookie is returned. This address cookie is
docs/arch-block.dox: - size: The size of the block, also divided by the allocation size.
docs/arch-block.dox: - checksum: The checksum of the block for validation purposes.
docs/arch-block.dox:The block header contains the following fields:
docs/arch-block.dox: - size: The size of the block on disk, used when salvaging data from a corrupt
docs/arch-block.dox: - checksum: The checksum of the block, again used for salvaging.
docs/arch-block.dox: - flags: Flags set on the block itself.
docs/arch-block.dox:@section block_implementation Block manager implementation details
docs/arch-block.dox:The block manager decides where in the file a block will be written. It has two
docs/arch-block.dox:fit. While operating in best fit mode the block manager will search a skip list
docs/arch-block.dox:block manager will place the newly created block in the first available extent.
docs/arch-block.dox:Additionally the block manager is a no-overwrite system. As such once a block is
docs/arch-block.dox:the system were to crash during an overwrite the block state would be unknown.
docs/arch-block.dox:block being created.
docs/arch-block.dox:@subsection desc_block Descriptor blocks
docs/arch-block.dox:A file is divided up into blocks. The first block in a file is special as it
docs/arch-block.dox:contains metadata about the file and is referred to as the "descriptor block".
docs/arch-block.dox:It contains the WiredTiger major and minor version, a checksum of the block
docs/arch-block.dox:The descriptor block serves as a safety check to ensure that the file being
docs/arch-block.dox:loaded into the block manager is actually a WiredTiger data file, that it
docs/arch-block.dox:@subsection block_lists Extent lists
docs/arch-block.dox:Internally, the block manager uses a data structure called an extent list or a
docs/arch-block.dox:extent size to aid with allocating new blocks.
docs/arch-block.dox:There are a number of configuration options that affect the block manager's
docs/arch-block.dox:Any blocks allocated by the block manager must be a multiple of this value.
docs/arch-block.dox:For example, if we specify an allocation_size of \c 4KB, blocks of size
docs/arch-block.dox:This configuration instructs the block manager to checksum the full length of
docs/arch-block.dox:the buffer provided to be written into the block. Be default it is enabled.
docs/arch-block.dox:When disabled the block manager still does perform a checksum operation but only
docs/arch-block.dox:The checksum is used when reading blocks to validate their contents, it
docs/arch-block.dox:compared with a checksum generated from the buffer that was held in the block
docs/arch-block.dox:@section block_usage How WiredTiger uses the block manager
docs/arch-block.dox:@subsection creation File creation and the block manager
docs/arch-block.dox:metadata file. However the block manager itself only exists on the btree
docs/arch-block.dox:block is contained in the metadata file \c WiredTiger.wt. The block manager will
docs/arch-block.dox:read the block at the location specified and return the page image as a buffer
docs/arch-block.dox:Two cases exist for writing out data using the block manager: checkpoint and
docs/arch-block.dox:eviction. When a page image is written out the block manager the \c bm->write
docs/arch-block.dox:At the block manager level, a checkpoint corresponds with a set of blocks that
docs/arch-block.dox:During a checkpoint new blocks are only written out for dirty pages. A block can
docs/arch-block.dox:checkpointed in checkpoint \c A, it will be created as a new block on disk. Now
docs/arch-block.dox:clean and as such will not require a new block to be written for it. The address
docs/arch-block.dox:of the original block is still valid.
docs/arch-block.dox:Checkpoints are created in depth first order, leaf blocks are created, then
docs/arch-block.dox:the parent blocks. This is a requirement as the parent blocks contain the
docs/arch-block.dox:addresses of the leaf blocks.
docs/arch-block.dox:The block manager doesn't guarantee that calling \c bm->write will result in
docs/arch-block.dox:call \c bm->sync once all blocks have been written which will call the file
docs/arch-block.dox:by the block manager, these extent lists are written out to disk as part of
docs/arch-block.dox:the checkpoint in blocks. Between checkpoints these extent lists are being
docs/arch-block.dox:blocks \c I, \c J, \c K as such its extent lists are as follows:
docs/arch-block.dox:block \c J, it also has allocated an additional block \c L.
docs/arch-block.dox:Finally we complete a 3rd checkpoint \c C which allocates an additional block
docs/arch-block.dox:to do that, the block manager will merge checkpoint \c A's extent lists into
docs/arch-block.dox:What's important here is that if a block appears in both the alloc list and
docs/arch-block.dox:We don't want to list each block individually in the extent lists, so instead of
docs/arch-block.dox:listing each block separately in the list, we use extents, which can describe a
docs/arch-block.dox:range in the file, that is, any number of contiguous blocks.
docs/arch-block.dox:Eviction also utilizes the block manager. When a page is evicted and contains
docs/arch-block.dox:data that needs to be maintained, logically a block needs to be written.
docs/arch-block.dox:Eviction calls \c bm->write however it does not instruct the block manager to
docs/arch-block.dox:As new blocks are written, the block manager will place them where they fit best.
docs/arch-block.dox:shrinking. The file can only be shrunk when there are available blocks at the
docs/arch-block.dox:The block manager operates in first fit mode during compaction to maximize block
docs/arch-block.dox:the block manager if relocating that page will reduce the file size. If so, the
docs/arch-block.dox:page is marked dirty, forcing the block to be rewritten. WiredTiger then
docs/arch-block.dox:checkpoint originally containing the block.
docs/arch-cache.dox:@ref arch-block "Block Manager"
docs/arch-cache.dox:and gets back a buffer containing the corresponding block from the underlying file.
docs/arch-cache.dox:If necessary, WiredTiger decrypts and decompresses the block.  Then it allocates indexing
docs/arch-compact.dox:the @ref arch-block "Block Manager" to reduce the on-disk footprint of WT tables. The compaction
docs/arch-compact.dox:compaction process involves rewriting disk blocks from the end of the on-disk file to the start of
docs/arch-compact.dox:Before understanding the compaction process, we need to understand how disk blocks are referenced by the
docs/arch-compact.dox:checkpoints. Each checkpoint references a certain set of disk blocks for a table. When a dirty
docs/arch-compact.dox:btree page is reconciled, a new disk block is assigned for the page and a new checkpoint starts
docs/arch-compact.dox:referencing the new block used for the page. Once the checkpoint referencing the old block is deleted,
docs/arch-compact.dox:the old disk block becomes available for reuse. The compaction process copies over the data from
docs/arch-compact.dox:the blocks at the end of the file to the reusable blocks at the start of the file.
docs/arch-compact.dox:The compaction process starts with a system-wide checkpoint. There are potentially many dirty blocks
docs/arch-compact.dox:that there are as many blocks as possible on the file's "available for reuse" list when the compaction
docs/arch-compact.dox:Compacting the object is done 10% at a time, that is, compaction tries to move blocks from the last 10% of the
docs/arch-compact.dox:file into the beginning of the file (the 10% is hard-coded in the block manager).  The reason for
docs/arch-compact.dox:this is because compaction walks the file in a logical order, not block offset order, and compaction
docs/arch-compact.dox:of a file can fail if the block from the end of the file is not written first. Note that the block manager
docs/arch-compact.dox:uses a first-fit block selection algorithm during compaction to maximize block movement. The process
docs/arch-compact.dox:is repeated multiple times until the block manager detects that there are no blocks from the last 10% of the file
docs/arch-compact.dox:a block manager API to assess whether it will be beneficial to rewrite the leaf page. If the block
docs/arch-compact.dox:block to a new disk location. The new disk address is placed into the parent internal page and
docs/arch-compact.dox:checkpoints are because the block manager checkpoints in two steps: blocks made available for reuse
docs/arch-compact.dox:blocks allocated to write the checkpoint itself cannot be taken from the blocks made available by
docs/arch-compact.dox:the checkpoint. To say it another way, the second checkpoint puts the blocks from the end of the file
docs/arch-compact.dox:the metadata is updated for the second checkpoint, the blocks freed by compaction become available for
docs/arch-compact.dox:the third checkpoint, so the third checkpoint's blocks are written towards the beginning of the file,
docs/arch-cursor.dox:of disabling the translation provided by the schema, transferring a single block of unencoded data
docs/arch-cursor.dox:whole data files.  Thus, having an open backup may cause the block manager and log file server
docs/arch-data-file.dox:disk, they are written out as units of data called blocks. On the disk, a
docs/arch-data-file.dox:WiredTiger data file is just a collection of blocks which logically represent
docs/arch-data-file.dox:always occupies the first block, followed by a set of on-disk pages.
docs/arch-data-file.dox:major and minor version, a magic number, and a checksum of the block
docs/arch-data-file.dox:immediately followed by the block header \c WT_BLOCK_HEADER which contains
docs/arch-data-file.dox:block-manager specific information such as flags and version.
docs/arch-data-file.dox:Fixed-length column store pages contain a block of bitmap data after
docs/arch-data-file.dox:up of, first, a block of bitmap data, and then an auxiliary header
docs/arch-data-file.dox:size). In addition, each block written may be compressed and/or encrypted.
docs/arch-data-file.dox:The header portion of each block remains uncompressed and unencrypted.
docs/arch-fast-truncate.dox:If the deletion is or has become globally visible, we can delete any on-disk block, and
docs/arch-fast-truncate.dox:Eviction of the child is blocked in these circumstances.)
docs/arch-fast-truncate.dox:Eviction of instantiated pages where the truncation is unresolved is blocked.
docs/arch-glossary.dox:<tr><td>address cookie<td>block manager<td>an opaque set of bytes returned by the block manager to reference a block in a Btree file, it includes an offset, size, checksum, and object id.
docs/arch-glossary.dox:<tr><td>block<td>block manager<td>the smallest granularity of data that is read from or written to a Btree file.  A btree page, when it appears on disk, may consist of one or more blocks.
docs/arch-glossary.dox:<tr><td>block compression<td>btree<td>after pages of btrees are encoded to be written, they may be compressed according to a configured algorithm.  Compressors may be added to WiredTiger via the extension mechanism.
docs/arch-glossary.dox:<tr><td>block manager<td>block manager<td>an internal API that abstracts writing, reading and allocating blocks to and from files.  A block manager is associated with a Btree.
docs/arch-glossary.dox:<tr><td>compression<td>general<td>one of several techniques to reduce the size of data on disk and memory.  See block compression, run length encoding, Huffman encoding, key prefix compression.
docs/arch-glossary.dox:<tr><td>extent list<td>block manager<td>a list of contiguous sets of blocks in a file.  Extent lists are used to track available blocks and/or used blocks.
docs/arch-glossary.dox:<tr><td>frag<td>verify<td>in verify, a part of a file that is the minimum allocation size and aligned the same.  The smallest blocks may be the same as a frag, other blocks may be composed of multiple contiguous frags.
docs/arch-index.dox:    rectangle "[[arch-block.html Block\nManager]]" as block
docs/arch-index.dox:cache -down-> block
docs/arch-index.dox:evict -down-> block
docs/arch-index.dox:block -[hidden]right-> SPACE_log
docs/arch-index.dox:block -down-> os
docs/arch-index.dox:    - @ref arch-block
docs/arch-index.dox:@subpage arch-block
docs/arch-index.dox:The block manager manages the reading and writing of disk blocks.
docs/arch-index.dox:The format of the data file is given by structures in \c block.h .
docs/arch-metadata.dox:this information also tracks an encoded address cookie that describes the blocks that make up the checkpoint's data.
docs/arch-transaction.dox:They are to prevent the slow prepared transactions blocking the movement of the global stable
docs/backup.dox:alignment or block size (specifically, Linux or Windows filesystems that
docs/backup.dox:@section backup_incremental-block Block-based Incremental backup
docs/backup.dox:copying only modified blocks and new files to the backup copy directory.
docs/backup.dox:using block modifications:
docs/backup.dox:The identifier specified in \c this_id starts block tracking and that
docs/backup.dox:value.  The information returned will be based on blocks tracked since the time of
docs/backup.dox:the previous backup designated with "ID1".  New block tracking will be started as
docs/backup.dox:read the block from the source database file indicated by the file offset and
docs/backup.dox:size pair and write the block to the same offset in the
docs/backup.dox:An example of opening the backup data source for block-based incremental backup:
docs/backup.dox:@snippet ex_all.c incremental block backup
docs/backup.dox:The URI \c backup:query_id can be used to return existing block incremental identifier
docs/backup.dox:@snippet ex_backup_block.c Query existing IDs
docs/basic-api.dox:The code block above also shows simple error handling with
docs/command-line.dox:table block_allocation=first
docs/command-line.dox:table:xxx block_allocation=first
docs/command-line.dox:table:xxx block_allocation=first,prefix_compress=false
docs/command-line.dox:table:xxx block_allocation=first table:xxx prefix_compress=false
docs/command-line.dox:`wt [-RrVv] [-C config] [-E secretkey ] [-h directory] verify [-s] [-d dump_address | dump_blocks | dump_layout | dump_offsets=#,# | dump_pages ] [uri]`
docs/compression.dox:Finally, when creating the WiredTiger object, set \c block_compressor
docs/compression.dox:Finally, when creating the WiredTiger object, set \c block_compressor
docs/compression.dox:Finally, when creating the WiredTiger object, set \c block_compressor
docs/compression.dox:Finally, when creating the WiredTiger object, set \c block_compressor
docs/compression.dox:WiredTiger does not store information with file blocks to identify the
docs/compression.dox:compression engine used to compressed the block.  Applications wanting
docs/compression.dox:dump and re-load), should ensure each compressed block includes enough
docs/compression.dox:code can correctly decompress old and new blocks.
docs/data-sources.dox:	backup cursor that only returns block incremental ids,
docs/durability-checkpoint.dox:Checkpoints share file blocks, and dropping a checkpoint may or may not
docs/durability-checkpoint.dox:make file blocks available for re-use, depending on whether the dropped
docs/durability-checkpoint.dox:checkpoint contained the last reference to those file blocks.  Because named
docs/durability-checkpoint.dox:prevent WT_SESSION::compact from reducing file size due to shared file blocks.
docs/encryption.dox:cryptographically strong checksum, WiredTiger's own block checksums can safely be disabled.
docs/encryption.dox:disable WiredTiger's own block checksums.
docs/examples.dox:@example ex_backup_block.c
docs/examples.dox:Shows how to use block-based incremental backup.
docs/file-formats.dox:WiredTiger allocates space from the underlying files in block units.
docs/file-formats.dox:dictionary compression, Huffman encoding and block compression.
docs/file-formats.dox:on-disk cost is the primary concern, block compression may mean prefix
docs/file-formats.dox:compressing blocks of the backing object's file.  The cost is additional
docs/file-formats.dox:additional CPU cost of block compression can be high, and should be
docs/file-formats.dox:block compression.
docs/file-formats.dox:compressing blocks of the backing object's file.  The cost is additional
docs/file-formats.dox:additional CPU cost of block compression can be high, and should be
docs/file-formats.dox:Fixed-length column stores support a single type of compression: block
docs/file-formats.dox:compressing blocks of the backing object's file.  The cost is additional
docs/file-formats.dox:additional CPU cost of block compression can be high, and should be
docs/images/plantuml_gen_img/wt_diagram.cmapx:<area shape="rect" id="id14" href="arch-block.html" title="arch-block.html" alt="" coords="196,642,256,674"/>
docs/js/sorttable.js:	Array.forEach = function(array, block, context) {
docs/js/sorttable.js:			block.call(context, array[i], i, array);
docs/js/sorttable.js:Function.prototype.forEach = function(object, block, context) {
docs/js/sorttable.js:			block.call(context, object[key], key, object);
docs/js/sorttable.js:String.forEach = function(string, block, context) {
docs/js/sorttable.js:		block.call(context, chr, index, string);
docs/js/sorttable.js:var forEach = function(object, block, context) {
docs/js/sorttable.js:			object.forEach(block, context);
docs/js/sorttable.js:		resolve.forEach(object, block, context);
docs/overview.dox:- WiredTiger offers transactional semantics without blocking,
docs/overview.dox:in one thread do not block operations in other threads, but strong isolation is
docs/overview.dox:WiredTiger supports block compression on table pages.  Because
docs/overview.dox:by a fixed amount in order to benefit from block compression.  Block
docs/style/tabs.css:	display:block;
docs/style/tabs.css:   display          : block;
docs/style/wiredtiger.css:	display: block;
docs/style/wiredtiger.css:    display: block;
docs/style/wiredtiger.css:    display: block;
docs/style/wiredtiger.css:    display: block;
docs/style/wiredtiger.css:	display: block;
docs/tool-index.dox:Kernel events include scheduling context switches, page faults and block I/O.
docs/tool-perf.dox:Kernel events include scheduling context switches, page faults, block I/O, etc.
docs/tool-perf.dox:- How much block I/O did my program generate?
docs/tool-perf.dox:blocking](https://perf.wiki.kernel.org/index.php/Tutorial#Profiling_sleep_times),
docs/tools/doxypy.py:into Doxygen-conform documentation blocks.
docs/tools/doxypy.py:		"""Appends any open comment block and triggering block to the output."""
docs/tools/doxypy.py:			block = self.makeCommentBlock()
docs/tools/doxypy.py:			self.output.extend(block)
docs/tools/doxypy.py:		Closes the current commentblock and starts a new comment search.
docs/tools/doxypy.py:		Closes the current commentblock, resets	the triggering line and
docs/tools/doxypy.py:		Closes the open comment	block, resets it and appends the current line.
docs/tools/doxypy.py:		"""Appends a line to the triggering block."""
docs/tools/doxypy.py:		"""Indents the current comment block with respect to the current
docs/transactions_api.dox:WiredTiger uses optimistic concurrency control algorithms.  Writes do not block
docs/transactions_api.dox:A thread with an active transaction should avoid pausing or blocking. This may delay
docs/tune-checksum.dox:functionality, or when using backing storage systems where blocks require no validation,
docs/tune-checksum.dox:"on", in which case all block writes include a checksum subsequently verified when the block is
docs/tune-checksum.dox:with storage systems that detect block corruption. The "uncompressed" setting only checksums
docs/tune-checksum.dox:blocks that are not compressed; the "unencrypted" setting only checksums blocks that are not
docs/tune-checksum.dox:compression or encryption engines that detect block corruption. Corruption detection is often
docs/tune-cursor-persist.dox:decrease performance by blocking page eviction or looking like a
docs/tune-file-alloc.dox:@section tuning_system_file_block_grow File growth
docs/tune-file-alloc.dox:extend it a block at a time as new blocks are written.  By configuring
docs/tune-file-alloc.dox:grow files ahead of the blocks being written.
docs/tune-file-alloc.dox:@section tuning_system_file_block_allocation File block allocation
docs/tune-file-alloc.dox:By default, when file blocks are being reused, WiredTiger attempts to
docs/tune-file-alloc.dox:avoid file fragmentation by selecting the smallest available block
docs/tune-file-alloc.dox:rather than splitting a larger available block into two.  The \c
docs/tune-file-alloc.dox:block_allocation configuration string to WT_SESSION::create can be set
docs/tune-file-alloc.dox:first available block in the file.  Applications where file size is more
docs/tune-file-alloc.dox:fixed-size blocks) might want to configure this way.
docs/tune-file-alloc.dox:@snippet ex_all.c Configure block_allocation
docs/tune-page-size-and-comp.dox:into smaller chunks called blocks, which then get written to the disk. The size
docs/tune-page-size-and-comp.dox:of these blocks is defined by a parameter called allocation_size, which is the
docs/tune-page-size-and-comp.dox:by enabling block compression.
docs/tune-page-size-and-comp.dox:size to better match the underlying storage block size.
docs/tune-page-size-and-comp.dox:algorithms other than block compression work by modifying how the keys and
docs/tune-page-size-and-comp.dox:cost is the primary concern, block compression may mean prefix compression is
docs/tune-page-size-and-comp.dox:Reduces the size requirement of on-disk objects by compressing blocks of
docs/tune-page-size-and-comp.dox:the backing object's file. The additional CPU cost of block compression can be
docs/tune-page-size-and-comp.dox:high, and should be considered. When block compression has been configured,
docs/tune-page-size-and-comp.dox:When block compression is configured, chunks of data are given to the
docs/tune-page-size-and-comp.dox:compression system, then returned as a compressed block of data. The amount of
docs/tune-page-size-and-comp.dox:Specified using the \c block_compressor configuration option to
docs/tune-page-size-and-comp.dox:"key_format=S,value_format=S,block_compressor=snappy"
docs/tune-system-buffer-cache.dox:- avoid double-buffering of blocks in WiredTiger's cache and the
docs/tune-system-buffer-cache.dox:of dirty blocks.
docs/tune-system-buffer-cache.dox:Direct I/O can be separately configured for log files, data files, and blocks
docs/tune-system-buffer-cache.dox:attempt to schedule writes for all of the dirty blocks the object has
docs/tune-system-buffer-cache.dox:applications to flush dirty blocks from the object, avoiding stalling
docs/tune-system-buffer-cache.dox:attempt to evict all of the object's blocks from the buffer cache.  This
docs/tune-system-buffer-cache.dox:configuration option allows applications to evict blocks from the system
evict/evict_lru.c:         * Clear the walks so we don't pin pages while asleep, otherwise we can block applications
evict/evict_lru.c:     * We don't do this check for in-memory workloads because application threads are not blocked by
evict/evict_lru.c:     * If application threads are blocked by the total volume of data in cache, try dirty pages as
evict/evict_lru.c:         * Without this, if all threads are blocked after a long-running transaction (such as a
evict/evict_lru.c:                 * Back off if we aren't making progress: walks hold the handle list lock, blocking
evict/evict_lru.c: *     Get exclusive eviction access to a file and discard any of the file's blocks queued for
evict/evict_lru.c:            ret = __wt_txn_is_blocking(session);
evict/evict_lru.c:         * previous txn is blocking call, however it won't pickup transactions that have been
evict/evict_page.c:     * Review the page for conditions that would block its eviction. If the check fails (for
evict/evict_page.c:         * Multiple blocks: Either a split where we reconciled a page and it turned into a lot of
evict/evict_page.c:         * a single block that we can't write. Take advantage of the fact we have exclusive access
evict/evict_page.c: *     Review the page and its subtree for conditions that would block its eviction.
evict/evict_page.c:        WT_STAT_CONN_INCR(session, cache_eviction_blocked_checkpoint_hs);
history/hs_rec.c:    WT_ERR(__wt_block_manager_named_size(session, WT_HS_FILE, &hs_size));
include/block_inline.h: * WiredTiger's block manager interface.
include/cache_inline.h:     * block manager in the case of flushing the system cache.
include/cache_inline.h:     * holding the schema lock, we don't want this thread to block for eviction.
include/cache_inline.h:     * holding the handle list, schema or table locks (which can block checkpoints and eviction),
include/cache_inline.h:     * don't block the thread for eviction.
include/cache_inline.h:    /* In memory configurations don't block when the cache is full. */
include/cache_inline.h:     * problem. We also don't block while reading metadata because we're likely to be holding some
include/cache_inline.h:     * other resources that could block checkpoints or eviction.
include/cursor.h:    WT_ITEM bitstring;    /* List of modified blocks */
include/extern.h:extern bool __wt_block_offset_invalid(WT_BLOCK *block, wt_off_t offset, uint32_t size)
include/extern.h:  WT_BLOCK **blockp) WT_GCC_FUNC_DECL_ATTRIBUTE((warn_unused_result));
include/extern.h:extern int __wt_blkcache_map(WT_SESSION_IMPL *session, WT_BLOCK *block, void **mapped_regionp,
include/extern.h:  WT_BLOCK **blockp) WT_GCC_FUNC_DECL_ATTRIBUTE((warn_unused_result));
include/extern.h:extern int __wt_blkcache_unmap(WT_SESSION_IMPL *session, WT_BLOCK *block, void *mapped_region,
include/extern.h:extern int __wt_block_addr_invalid(WT_SESSION_IMPL *session, WT_BLOCK *block, const uint8_t *addr,
include/extern.h:extern int __wt_block_addr_pack(WT_BLOCK *block, uint8_t **pp, uint32_t objectid, wt_off_t offset,
include/extern.h:extern int __wt_block_addr_string(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_ITEM *buf,
include/extern.h:extern int __wt_block_addr_unpack(WT_SESSION_IMPL *session, WT_BLOCK *block, const uint8_t *p,
include/extern.h:extern int __wt_block_alloc(WT_SESSION_IMPL *session, WT_BLOCK *block, wt_off_t *offp,
include/extern.h:extern int __wt_block_checkpoint(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_ITEM *buf,
include/extern.h:extern int __wt_block_checkpoint_final(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_ITEM *buf,
include/extern.h:extern int __wt_block_checkpoint_last(WT_SESSION_IMPL *session, WT_BLOCK *block, char **metadatap,
include/extern.h:extern int __wt_block_checkpoint_load(WT_SESSION_IMPL *session, WT_BLOCK *block,
include/extern.h:extern int __wt_block_checkpoint_resolve(WT_SESSION_IMPL *session, WT_BLOCK *block, bool failed)
include/extern.h:extern int __wt_block_checkpoint_start(WT_SESSION_IMPL *session, WT_BLOCK *block)
include/extern.h:extern int __wt_block_checkpoint_unload(WT_SESSION_IMPL *session, WT_BLOCK *block, bool checkpoint)
include/extern.h:extern int __wt_block_ckpt_decode(WT_SESSION *wt_session, WT_BLOCK *block, const uint8_t *ckpt,
include/extern.h:extern int __wt_block_ckpt_init(WT_SESSION_IMPL *session, WT_BLOCK_CKPT *ci, const char *name)
include/extern.h:extern int __wt_block_ckpt_pack(WT_SESSION_IMPL *session, WT_BLOCK *block, uint8_t **pp,
include/extern.h:extern int __wt_block_ckpt_unpack(WT_SESSION_IMPL *session, WT_BLOCK *block, const uint8_t *ckpt,
include/extern.h:extern int __wt_block_close(WT_SESSION_IMPL *session, WT_BLOCK *block)
include/extern.h:extern int __wt_block_compact_end(WT_SESSION_IMPL *session, WT_BLOCK *block)
include/extern.h:extern int __wt_block_compact_page_rewrite(WT_SESSION_IMPL *session, WT_BLOCK *block, uint8_t *addr,
include/extern.h:extern int __wt_block_compact_page_skip(
include/extern.h:  WT_SESSION_IMPL *session, WT_BLOCK *block, const uint8_t *addr, size_t addr_size, bool *skipp)
include/extern.h:extern int __wt_block_compact_skip(WT_SESSION_IMPL *session, WT_BLOCK *block, bool *skipp)
include/extern.h:extern int __wt_block_compact_start(WT_SESSION_IMPL *session, WT_BLOCK *block)
include/extern.h:extern int __wt_block_discard(WT_SESSION_IMPL *session, WT_BLOCK *block, size_t added_size)
include/extern.h:extern int __wt_block_ext_alloc(WT_SESSION_IMPL *session, WT_EXT **extp)
include/extern.h:extern int __wt_block_ext_discard(WT_SESSION_IMPL *session, u_int max)
include/extern.h:extern int __wt_block_ext_prealloc(WT_SESSION_IMPL *session, u_int max)
include/extern.h:extern int __wt_block_extlist_check(WT_SESSION_IMPL *session, WT_EXTLIST *al, WT_EXTLIST *bl)
include/extern.h:extern int __wt_block_extlist_init(WT_SESSION_IMPL *session, WT_EXTLIST *el, const char *name,
include/extern.h:extern int __wt_block_extlist_merge(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_EXTLIST *a,
include/extern.h:extern int __wt_block_extlist_overlap(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_BLOCK_CKPT *ci)
include/extern.h:extern int __wt_block_extlist_read(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_EXTLIST *el,
include/extern.h:extern int __wt_block_extlist_read_avail(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_EXTLIST *el,
include/extern.h:extern int __wt_block_extlist_truncate(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_EXTLIST *el)
include/extern.h:extern int __wt_block_extlist_write(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_EXTLIST *el,
include/extern.h:extern int __wt_block_free(WT_SESSION_IMPL *session, WT_BLOCK *block, const uint8_t *addr,
include/extern.h:extern int __wt_block_insert_ext(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_EXTLIST *el,
include/extern.h:extern int __wt_block_manager_create(WT_SESSION_IMPL *session, const char *filename,
include/extern.h:extern int __wt_block_manager_drop(WT_SESSION_IMPL *session, const char *filename, bool durable)
include/extern.h:extern int __wt_block_manager_drop_object(WT_SESSION_IMPL *session, WT_BUCKET_STORAGE *bstorage,
include/extern.h:extern int __wt_block_manager_named_size(WT_SESSION_IMPL *session, const char *name,
include/extern.h:extern int __wt_block_manager_size(WT_BM *bm, WT_SESSION_IMPL *session, wt_off_t *sizep)
include/extern.h:extern int __wt_block_misplaced(WT_SESSION_IMPL *session, WT_BLOCK *block, const char *list,
include/extern.h:extern int __wt_block_off_free(WT_SESSION_IMPL *session, WT_BLOCK *block, uint32_t objectid,
include/extern.h:extern int __wt_block_off_remove_overlap(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_EXTLIST *el,
include/extern.h:extern int __wt_block_open(WT_SESSION_IMPL *session, const char *filename, uint32_t objectid,
include/extern.h:  WT_BLOCK **blockp) WT_GCC_FUNC_DECL_ATTRIBUTE((warn_unused_result));
include/extern.h:extern int __wt_block_read_off(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_ITEM *buf,
include/extern.h:extern int __wt_block_read_off_blind(WT_SESSION_IMPL *session, WT_BLOCK *block, wt_off_t offset,
include/extern.h:extern int __wt_block_salvage_end(WT_SESSION_IMPL *session, WT_BLOCK *block)
include/extern.h:extern int __wt_block_salvage_next(WT_SESSION_IMPL *session, WT_BLOCK *block, uint8_t *addr,
include/extern.h:extern int __wt_block_salvage_start(WT_SESSION_IMPL *session, WT_BLOCK *block)
include/extern.h:extern int __wt_block_salvage_valid(WT_SESSION_IMPL *session, WT_BLOCK *block, uint8_t *addr,
include/extern.h:extern int __wt_block_size_alloc(WT_SESSION_IMPL *session, WT_SIZE **szp)
include/extern.h:extern int __wt_block_truncate(WT_SESSION_IMPL *session, WT_BLOCK *block, wt_off_t len)
include/extern.h:extern int __wt_block_verify_addr(WT_SESSION_IMPL *session, WT_BLOCK *block, const uint8_t *addr,
include/extern.h:extern int __wt_block_verify_end(WT_SESSION_IMPL *session, WT_BLOCK *block)
include/extern.h:extern int __wt_block_verify_start(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_CKPT *ckptbase,
include/extern.h:extern int __wt_block_write(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_ITEM *buf, uint8_t *addr,
include/extern.h:extern int __wt_block_write_off(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_ITEM *buf,
include/extern.h:extern int __wt_block_write_size(WT_SESSION_IMPL *session, WT_BLOCK *block, size_t *sizep)
include/extern.h:extern int __wt_meta_block_metadata(WT_SESSION_IMPL *session, const char *config, WT_CKPT *ckpt)
include/extern.h:extern int __wt_txn_is_blocking(WT_SESSION_IMPL *session)
include/extern.h:extern int __wt_verify_ckpt_load(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_BLOCK_CKPT *ci)
include/extern.h:extern int __wt_verify_ckpt_unload(WT_SESSION_IMPL *session, WT_BLOCK *block)
include/extern.h:extern void __wt_block_ckpt_destroy(WT_SESSION_IMPL *session, WT_BLOCK_CKPT *ci);
include/extern.h:extern void __wt_block_compact_get_progress_stats(WT_SESSION_IMPL *session, WT_BM *bm,
include/extern.h:extern void __wt_block_compact_progress(
include/extern.h:  WT_SESSION_IMPL *session, WT_BLOCK *block, u_int *msg_countp);
include/extern.h:extern void __wt_block_configure_first_fit(WT_BLOCK *block, bool on);
include/extern.h:extern void __wt_block_ext_free(WT_SESSION_IMPL *session, WT_EXT *ext);
include/extern.h:extern void __wt_block_extlist_free(WT_SESSION_IMPL *session, WT_EXTLIST *el);
include/extern.h:extern void __wt_block_size_free(WT_SESSION_IMPL *session, WT_SIZE *sz);
include/extern.h:extern void __wt_block_stat(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_DSRC_STATS *stats);
include/extern.h:extern void __wt_ckpt_verbose(WT_SESSION_IMPL *session, WT_BLOCK *block, const char *tag,
include/extern.h:static inline int __wt_btree_block_free(WT_SESSION_IMPL *session, const uint8_t *addr,
include/extern.h:static inline int __wt_fsync(WT_SESSION_IMPL *session, WT_FH *fh, bool block)
include/extern.h:static inline int __wt_ref_block_free(WT_SESSION_IMPL *session, WT_REF *ref)
include/extern.h:static inline int __wt_txn_modify_block(WT_SESSION_IMPL *session, WT_CURSOR_BTREE *cbt,
include/extern.h:__ut_block_off_srch_last(WT_EXTLIST *el, WT_EXT ***stack, bool need_traverse)
include/extern.h:extern bool __ut_block_first_srch(WT_EXT **head, wt_off_t size, WT_EXT ***stack)
include/extern.h:extern void __ut_block_off_srch(WT_EXT **head, wt_off_t off, WT_EXT ***stack, bool skip_off);
include/extern.h:extern void __ut_block_size_srch(WT_SIZE **head, wt_off_t size, WT_SIZE ***stack);
include/reconcile.h:    //block size = WT_PAGE_HEADER_SIZE + WT_BLOCK_HEADER_SIZE + 实际数据
include/reconcile.h:    //跳过PAGE_HEADER及block header，也就是指向真实data, 记录写入的KV数据的末尾处，见__wt_rec_incr
include/reconcile.h:    //最终这部分buf数据会和PAGE_HEADER、block header一起写入磁盘
include/reconcile.h:     * page, we save WT_UPDATE lists here, and then move them to per-block areas as the blocks are
include/reconcile.h:     * We calculate checksums to find previously written identical blocks, but once a match fails
include/hardware.h: * Note that we avoid compiler structure alignment because that requires allocating aligned blocks
include/stat.h:    //"block-cache"
include/stat.h:    int64_t block_cache_blocks_update;
include/stat.h:    int64_t block_cache_bytes_update;
include/stat.h:    int64_t block_cache_blocks_evicted;
include/stat.h:    int64_t block_cache_bypass_filesize;
include/stat.h:    int64_t block_cache_lookups;
include/stat.h:    int64_t block_cache_not_evicted_overhead;
include/stat.h:    int64_t block_cache_bypass_writealloc;
include/stat.h:    int64_t block_cache_bypass_overhead_put;
include/stat.h:    int64_t block_cache_bypass_get;
include/stat.h:    int64_t block_cache_bypass_put;
include/stat.h:    int64_t block_cache_eviction_passes;
include/stat.h:    int64_t block_cache_hits;
include/stat.h:    int64_t block_cache_misses;
include/stat.h:    int64_t block_cache_bypass_chkpt;
include/stat.h:    int64_t block_cache_blocks_removed;
include/stat.h:    int64_t block_cache_blocks;
include/stat.h:    int64_t block_cache_blocks_insert_read;
include/stat.h:    int64_t block_cache_blocks_insert_write;
include/stat.h:    int64_t block_cache_bytes;
include/stat.h:    int64_t block_cache_bytes_insert_read;
include/stat.h:    int64_t block_cache_bytes_insert_write;
include/stat.h:    //"block-manager"
include/stat.h:    int64_t block_preload;
include/stat.h:    int64_t block_read;
include/stat.h:    int64_t block_write;
include/stat.h:    int64_t block_byte_read;
include/stat.h:    int64_t block_byte_read_mmap;
include/stat.h:    int64_t block_byte_read_syscall;
include/stat.h:    int64_t block_byte_write;
include/stat.h:    int64_t block_byte_write_checkpoint;
include/stat.h:    int64_t block_byte_write_mmap;
include/stat.h:    int64_t block_byte_write_syscall;
include/stat.h:    int64_t block_map_read;
include/stat.h:    int64_t block_byte_map_read;
include/stat.h:    int64_t block_remap_file_resize;
include/stat.h:    int64_t block_remap_file_write;
include/stat.h:    int64_t cache_eviction_blocked_checkpoint_hs;
include/stat.h:    int64_t cache_eviction_blocked_no_ts_checkpoint_race_1;
include/stat.h:    int64_t cache_eviction_blocked_no_ts_checkpoint_race_2;
include/stat.h:    int64_t cache_eviction_blocked_no_ts_checkpoint_race_3;
include/stat.h:    int64_t cache_eviction_blocked_no_ts_checkpoint_race_4;
include/stat.h:    int64_t cache_eviction_blocked_remove_hs_race_with_checkpoint;
include/stat.h:    int64_t txn_release_blocked;
include/stat.h:    int64_t conn_close_blocked_lsm;
include/stat.h:    int64_t dhandle_lock_blocked;
include/stat.h:    int64_t page_index_slot_ref_blocked;
include/stat.h:    int64_t prepared_transition_blocked_page;
include/stat.h:    int64_t page_busy_blocked;
include/stat.h:    int64_t page_forcible_evict_blocked;
include/stat.h:    int64_t page_locked_blocked;
include/stat.h:    int64_t page_read_blocked;
include/stat.h:    int64_t page_del_rollback_blocked;
include/stat.h:    int64_t child_modify_blocked_page;
include/stat.h:    int64_t block_extension;
include/stat.h:    int64_t block_alloc;
include/stat.h:    int64_t block_free;
include/stat.h:    int64_t block_checkpoint_size;
include/stat.h:    int64_t block_reuse_bytes;
include/stat.h:    int64_t block_magic;
include/stat.h:    int64_t block_major;
include/stat.h:    int64_t block_size;
include/stat.h:    int64_t block_minor;
include/stat.h:    int64_t cache_eviction_blocked_checkpoint_hs;
include/stat.h:    int64_t cache_eviction_blocked_no_ts_checkpoint_race_1;
include/stat.h:    int64_t cache_eviction_blocked_no_ts_checkpoint_race_2;
include/stat.h:    int64_t cache_eviction_blocked_no_ts_checkpoint_race_3;
include/stat.h:    int64_t cache_eviction_blocked_no_ts_checkpoint_race_4;
include/stat.h:    int64_t cache_eviction_blocked_remove_hs_race_with_checkpoint;
include/stat.h:    int64_t rec_multiblock_internal;
include/stat.h:    int64_t rec_multiblock_leaf;
include/stat.h:    int64_t rec_multiblock_max;
include/time_inline.h: //operation_timeout_ms配置超时处理后，在__wt_cache_eviction_worker  __wt_txn_is_blocking中生效
include/misc.h: * Encryption needs to know its original length before either the block or logging subsystems pad.
include/os_fhandle_inline.h:__wt_fsync(WT_SESSION_IMPL *session, WT_FH *fh, bool block)
include/os_fhandle_inline.h:     * There is no way to check when the non-blocking sync-file-range is complete, but we track the
include/os_fhandle_inline.h:    if (block)
include/os_fhandle_inline.h://__wt_block_manager_create->__wt_desc_write->__wt_write: 头部1024字节用于记录Descriptor信息，实际上没有用完1024字节
include/os_fhandle_inline.h://__block_write_off: page数据内容写入磁盘通过该接口
include/session.h:    //__wt_block_ext_prealloc中初始化和赋值，管理WT_EXT WT_SIZE
include/session.h:    //对应WT_BLOCK_MGR_SESSION结构  参考官方文档https://source.wiredtiger.com/develop/arch-block.html
include/session.h:    void *block_manager; /* Block-manager support */
include/session.h:    //__block_manager_session_cleanup
include/session.h:    int (*block_manager_cleanup)(WT_SESSION_IMPL *);
include/wiredtiger.in:	 * cache size and are not blocked when the cache is full.  Note that use of this option for
include/wiredtiger.in:	 * @config{incremental = (, configure the cursor for block incremental backup usage.  These
include/wiredtiger.in:	 * consolidate, causes block incremental backup information to be consolidated if adjacent
include/wiredtiger.in:	 * granularity blocks are modified.  If false\, information will be returned in granularity
include/wiredtiger.in:	 * sized blocks only.  This must be set on the primary backup cursor and it applies to all
include/wiredtiger.in:	 * backup cursor.  That duplicate cursor will return the block modifications relevant to the
include/wiredtiger.in:	 * causes all block incremental backup information to be released.  This is on an
include/wiredtiger.in:	 * non-zero\, schedule writes for dirty blocks belonging to this object in the system buffer
include/wiredtiger.in:	 * object blocks from the system buffer cache after that many bytes from this object are
include/wiredtiger.in:	 * @config{block_allocation, configure block allocation.  Permitted values are \c "best" or
include/wiredtiger.in:	 * configuration uses a first-available algorithm during block allocation., a string\,
include/wiredtiger.in:	 * @config{block_compressor, configure a compressor for file blocks.  Permitted values are
include/wiredtiger.in:	 * @config{checksum, configure block checksums; the permitted values are \c on\, \c off\, \c
include/wiredtiger.in:	 * uncompressed and \c unencrypted.  The default is \c on\, in which case all block writes
include/wiredtiger.in:	 * include a checksum subsequently verified when the block is read.  The \c off setting does
include/wiredtiger.in:	 * no checksums\, the \c uncompressed setting only checksums blocks that are not
include/wiredtiger.in:	 * compressed\, and the \c unencrypted setting only checksums blocks that are not encrypted.
include/wiredtiger.in:	 * @config{encryption = (, configure an encryptor for file blocks.  When a table is
include/wiredtiger.in:	 * of uncompressed data\, that is\, the limit is applied before any block compression is
include/wiredtiger.in:	 * of uncompressed data\, that is\, the limit is applied before any block compression is
include/wiredtiger.in:	 * storage block.  Depending on compression efficiency\, compression can create storage
include/wiredtiger.in:	 * blocks which require significant resources to re-instantiate in the cache\, penalizing
include/wiredtiger.in:	 * image a storage block will need.  If set to 0\, a default of 4 times \c leaf_page_max is
include/wiredtiger.in:	 * non-zero\, schedule writes for dirty blocks belonging to this object in the system buffer
include/wiredtiger.in:	 * object blocks from the system buffer cache after that many bytes from this object are
include/wiredtiger.in:	 * discarding any corrupted file blocks.
include/wiredtiger.in:	 * @config{dump_blocks, Display the contents of on-disk blocks as they are verified\, using
include/wiredtiger.in:	 * the block manager., a boolean flag; default \c false.}
include/wiredtiger.in:	 * @config{dump_offsets, Display the contents of specific on-disk blocks\, using the
include/wiredtiger.in:	 * checksum error.  It will skip past the corrupt block and continue with the verification
include/wiredtiger.in:	 * example\, a leaked block)., a boolean flag; default \c false.}
include/wiredtiger.in:	 * @config{block_cache = (, block cache configuration options., a set of related
include/wiredtiger.in:	 * blkcache_eviction_aggression, seconds an unused block remains in the cache before it is
include/wiredtiger.in:	 * @config{&nbsp;&nbsp;&nbsp;&nbsp;cache_on_checkpoint, cache blocks written by a
include/wiredtiger.in:	 * cache_on_writes, cache blocks as they are written (other than checkpoint blocks)., a
include/wiredtiger.in:	 * @config{&nbsp;&nbsp;&nbsp;&nbsp;enabled, enable block
include/wiredtiger.in:	 * the fraction of the block cache that must be full before eviction will remove unused
include/wiredtiger.in:	 * blocks., an integer between \c 30 and \c 100; default \c 95.}
include/wiredtiger.in:	 * track of blocks., an integer between \c 512 and \c 256K; default \c 0.}
include/wiredtiger.in:	 * expressed as the number of blocks added and removed as percent of blocks looked up; cache
include/wiredtiger.in:	 * block_cache.system_ram)., an integer between \c 0 and \c 100; default \c 50.}
include/wiredtiger.in:	 * @config{&nbsp;&nbsp;&nbsp;&nbsp;size, maximum memory to allocate for the block cache., an
include/wiredtiger.in:	 * system_ram, the bytes of system DRAM available for caching filesystem blocks., an integer
include/wiredtiger.in:	 * dirty blocks belonging to the log in the system buffer cache after that percentage of the
include/wiredtiger.in:	 * from the following options: \c "api"\, \c "backup"\, \c "block"\, \c "block_cache"\, \c
include/wiredtiger.in:	 * cache size and are not blocked when the cache is full.  Note that use of this option for
include/wiredtiger.in: * @config{block_cache = (, block cache configuration options., a set of related configuration
include/wiredtiger.in: * seconds an unused block remains in the cache before it is evicted., an integer between \c 1 and
include/wiredtiger.in: * @config{&nbsp;&nbsp;&nbsp;&nbsp;cache_on_checkpoint, cache blocks
include/wiredtiger.in: * cache_on_writes, cache blocks as they are written (other than checkpoint blocks)., a boolean
include/wiredtiger.in: * @config{&nbsp;&nbsp;&nbsp;&nbsp;enabled, enable block cache., a boolean
include/wiredtiger.in: * @config{&nbsp;&nbsp;&nbsp;&nbsp;full_target, the fraction of the block
include/wiredtiger.in: * cache that must be full before eviction will remove unused blocks., an integer between \c 30 and
include/wiredtiger.in: * hashtable that keeps track of blocks., an integer between \c 512 and \c 256K; default \c 0.}
include/wiredtiger.in: * number of blocks added and removed as percent of blocks looked up; cache population and eviction
include/wiredtiger.in: * DRAM (as specified by block_cache.system_ram)., an integer between \c 0 and \c 100; default \c
include/wiredtiger.in: * @config{&nbsp;&nbsp;&nbsp;&nbsp;size, maximum memory to allocate for the block cache., an
include/wiredtiger.in: * bytes of system DRAM available for caching filesystem blocks., an integer between \c 0 and \c
include/wiredtiger.in: * in allocations of the given size\, instead of a block at a time as each new block is written.
include/wiredtiger.in: * a percentage of the log's \c file_max.  If non-zero\, schedule writes for dirty blocks belonging
include/wiredtiger.in: * "backup"\, \c "block"\, \c "block_cache"\, \c "checkpoint"\, \c "checkpoint_cleanup"\, \c
include/wiredtiger.in:	 * On entry, \c src will point to a block of memory to encrypt, with the length of
include/wiredtiger.in:	 * the block in \c src_len.
include/wiredtiger.in:	 * that is needed when encrypting a data block. This is always necessary, since
include/wiredtiger.in:	 * that if the encryption uses a block cipher in such a way that the input size
include/wiredtiger.in:	 * needs to be padded to the cipher block size, the sizing method should return
include/wiredtiger.in:/*! block-cache: cached blocks updated */
include/wiredtiger.in:/*! block-cache: cached bytes updated */
include/wiredtiger.in:/*! block-cache: evicted blocks */
include/wiredtiger.in:/*! block-cache: file size causing bypass */
include/wiredtiger.in:/*! block-cache: lookups */
include/wiredtiger.in:/*! block-cache: number of blocks not evicted due to overhead */
include/wiredtiger.in: * block-cache: number of bypasses because no-write-allocate setting was
include/wiredtiger.in:/*! block-cache: number of bypasses due to overhead on put */
include/wiredtiger.in:/*! block-cache: number of bypasses on get */
include/wiredtiger.in:/*! block-cache: number of bypasses on put because file is too small */
include/wiredtiger.in:/*! block-cache: number of eviction passes */
include/wiredtiger.in:/*! block-cache: number of hits */
include/wiredtiger.in:/*! block-cache: number of misses */
include/wiredtiger.in:/*! block-cache: number of put bypasses on checkpoint I/O */
include/wiredtiger.in:/*! block-cache: removed blocks */
include/wiredtiger.in:/*! block-cache: total blocks */
include/wiredtiger.in:/*! block-cache: total blocks inserted on read path */
include/wiredtiger.in:/*! block-cache: total blocks inserted on write path */
include/wiredtiger.in:/*! block-cache: total bytes */
include/wiredtiger.in:/*! block-cache: total bytes inserted on read path */
include/wiredtiger.in:/*! block-cache: total bytes inserted on write path */
include/wiredtiger.in:/*! block-manager: blocks pre-loaded */
include/wiredtiger.in:/*! block-manager: blocks read */
include/wiredtiger.in:/*! block-manager: blocks written */
include/wiredtiger.in:/*! block-manager: bytes read */
include/wiredtiger.in:/*! block-manager: bytes read via memory map API */
include/wiredtiger.in:/*! block-manager: bytes read via system call API */
include/wiredtiger.in:/*! block-manager: bytes written */
include/wiredtiger.in:/*! block-manager: bytes written for checkpoint */
include/wiredtiger.in:/*! block-manager: bytes written via memory map API */
include/wiredtiger.in:/*! block-manager: bytes written via system call API */
include/wiredtiger.in:/*! block-manager: mapped blocks read */
include/wiredtiger.in:/*! block-manager: mapped bytes read */
include/wiredtiger.in: * block-manager: number of times the file was remapped because it
include/wiredtiger.in:/*! block-manager: number of times the region was remapped via write */
include/wiredtiger.in:/*! cache: checkpoint blocked page eviction */
include/wiredtiger.in: * cache: checkpoint of history store file blocked non-history store page
include/wiredtiger.in:/*! cache: hazard pointer blocked page eviction */
include/wiredtiger.in: * thread-yield: connection close blocked waiting for transaction state
include/wiredtiger.in:/*! thread-yield: page acquire busy blocked */
include/wiredtiger.in:/*! thread-yield: page acquire eviction blocked */
include/wiredtiger.in:/*! thread-yield: page acquire locked blocked */
include/wiredtiger.in:/*! thread-yield: page acquire read blocked */
include/wiredtiger.in:/*! block-manager: allocations requiring file extension */
include/wiredtiger.in:/*! block-manager: blocks allocated */
include/wiredtiger.in:/*! block-manager: blocks freed */
include/wiredtiger.in:/*! block-manager: checkpoint size */
include/wiredtiger.in:/*! block-manager: file allocation unit size */
include/wiredtiger.in:/*! block-manager: file bytes available for reuse */
include/wiredtiger.in:/*! block-manager: file magic number */
include/wiredtiger.in:/*! block-manager: file major version number */
include/wiredtiger.in:/*! block-manager: file size in bytes */
include/wiredtiger.in:/*! block-manager: minor version number */
include/wiredtiger.in:/*! cache: checkpoint blocked page eviction */
include/wiredtiger.in: * cache: checkpoint of history store file blocked non-history store page
include/wiredtiger.in:/*! cache: hazard pointer blocked page eviction */
include/wiredtiger.in:/*! compression: number of blocks with compress ratio greater than 64 */
include/wiredtiger.in:/*! compression: number of blocks with compress ratio smaller than 16 */
include/wiredtiger.in:/*! compression: number of blocks with compress ratio smaller than 2 */
include/wiredtiger.in:/*! compression: number of blocks with compress ratio smaller than 32 */
include/wiredtiger.in:/*! compression: number of blocks with compress ratio smaller than 4 */
include/wiredtiger.in:/*! compression: number of blocks with compress ratio smaller than 64 */
include/wiredtiger.in:/*! compression: number of blocks with compress ratio smaller than 8 */
include/wiredtiger.in:/*! reconciliation: internal page multi-block writes */
include/wiredtiger.in:/*! reconciliation: leaf page multi-block writes */
include/wiredtiger.in:/*! reconciliation: maximum blocks required for a page */
include/btmem.h: * block-manager specific structure.
include/btmem.h: 2. The page header is followed by a "block header". In WiredTiger each page is a block, and it is possible to plug
include/btmem.h:     in different "block managers" that manage the transition of pages to and from disk. The default block header is
include/btmem.h:     defined in src/include/block.h in the __wt_block_header structure.
include/btmem.h: (the overflow record length), and the page type. This is immediately followed by the block header WT_BLOCK_HEADER which contains
include/btmem.h: block-manager specific information such as flags and version.
include/btmem.h://WT_BLOCK_HEADER(__wt_block_header)赋值在写磁盘完成后，在__block_write_off赋值,对应内存偏移见WT_PAGE_HEADER_BYTE_SIZE
include/btmem.h://如果配置了压缩，则__wt_page_header记录的是压缩前的数据信息,__wt_block_header记录的是压缩后的数据信息
include/btmem.h://WT_BLOCK_HEADER(__wt_block_header)赋值在写磁盘完成后，在__block_write_off赋值,对应内存偏移见WT_PAGE_HEADER_BYTE_SIZE
include/btmem.h://如果配置了压缩，则__wt_page_header记录的是压缩前的数据信息,__wt_block_header记录的是压缩后的数据信息
include/btmem.h: * The block-manager specific information immediately follows the WT_PAGE_HEADER structure.
include/btmem.h: *	The first usable data byte on the block (past the combined headers).
include/btmem.h://WT_BLOCK_HEADER(__wt_block_header)赋值在写磁盘完成后，在__block_write_off赋值,对应内存偏移见WT_PAGE_HEADER_BYTE_SIZE
include/btmem.h://如果配置了压缩，则__wt_page_header记录的是压缩前的数据信息,__wt_block_header记录的是压缩后的数据信息
include/btmem.h://page header(WT_PAGE_HEADER_SIZE) + block header(WT_BLOCK_HEADER_SIZE)
include/btmem.h:#define WT_PAGE_HEADER_BYTE_SIZE(btree) ((u_int)(WT_PAGE_HEADER_SIZE + (btree)->block_header)) 
include/btmem.h://dsk开始跳过page header + block header,也就是这个page对应的实际数据起始地址
include/btmem.h: *	An in-memory structure to hold a block's location.
include/btmem.h:     * If an address is both as an address for the previous and the current multi-block
include/btmem.h:     * reconciliations, that is, a block we're writing matches the block written the last time, it
include/btmem.h:     * previous blocks. The reuse flag is how we know that's happening so the block is treated
include/btmem.h: * written (in which case we want to write a new record and discard blocks used by the previously
include/btmem.h: * with their underlying blocks.
include/btmem.h: * underlying blocks.
include/btmem.h:    ",block_compressor=" WT_HS_COMPRESSOR                              \
include/btmem.h: *	Replacement block information used during reconciliation.
include/btmem.h:     * If there are unresolved updates, the block wasn't written and there will always be a disk
include/btmem.h:     * page, we avoid writing the block if it's unchanged by comparing size and checksum; the reuse
include/btmem.h:     * flag is set when the block is unchanged and we're reusing a previous address.
include/btmem.h:     * Overflow key/value addresses to be discarded from the block manager after reconciliation
include/btmem.h:     * When pages are reconciled, the result is one or more replacement blocks. A replacement block
include/btmem.h:     * can be in one of two states: it was written to disk, and so we have a block address, or it
include/btmem.h:     * is. In other words, checkpoints will skip unresolved modifications, and will write the blocks
include/btmem.h:     * multiple replacement blocks.
include/btmem.h:        struct { /* Single, written replacement block */
include/btmem.h:            WT_MULTI *multi;        /* Multiple replacement blocks */
include/btmem.h:            uint32_t multi_entries; /* Multiple blocks element count */
include/btmem.h:#define WT_PM_REC_MULTIBLOCK 2 /* Reconciliation: multiple blocks */
include/btmem.h:#define WT_PM_REC_REPLACE 3    /* Reconciliation: single block */
include/btmem.h://__wt_block_extlist_write，表示checkpoint的ext
include/btmem.h:     * Address: on-page cell if read from backing block, off-page WT_ADDR if instantiated in-memory,
include/btmem.h:    //通过ref->addr可以判断除该ref对应page是否罗盘了 __wt_ref_block_free
include/log.h: *     Handle big- and little-endian transformation of the log record header block.
include/log.h: *     Handle big- and little-endian transformation of the log file description block.
include/wt_internal.h:struct __wt_block;
include/wt_internal.h:    typedef struct __wt_block WT_BLOCK;
include/wt_internal.h:struct __wt_block_ckpt;
include/wt_internal.h:    typedef struct __wt_block_ckpt WT_BLOCK_CKPT;
include/wt_internal.h:struct __wt_block_desc;
include/wt_internal.h:    typedef struct __wt_block_desc WT_BLOCK_DESC;
include/wt_internal.h:struct __wt_block_header;
include/wt_internal.h:    typedef struct __wt_block_header WT_BLOCK_HEADER;
include/wt_internal.h:struct __wt_block_mods;
include/wt_internal.h:    typedef struct __wt_block_mods WT_BLOCK_MODS;
include/wt_internal.h:#include "block.h"
include/wt_internal.h:#include "block_cache.h"
include/wt_internal.h:#include "meta.h" /* required by block.h */
include/wt_internal.h:#include "block_inline.h"
include/tags:BLKCACHE_DRAM	../include/block_cache.h	22;"	d
include/tags:BLKCACHE_EVICT_OTHER	../include/block_cache.h	34;"	d
include/tags:BLKCACHE_FILESIZE_EST_FREQ	../include/block_cache.h	31;"	d
include/tags:BLKCACHE_HASHSIZE_DEFAULT	../include/block_cache.h	26;"	d
include/tags:BLKCACHE_HASHSIZE_MAX	../include/block_cache.h	28;"	d
include/tags:BLKCACHE_HASHSIZE_MIN	../include/block_cache.h	27;"	d
include/tags:BLKCACHE_HIST_BOUNDARY	../include/block_cache.h	139;"	d
include/tags:BLKCACHE_HIST_BUCKETS	../include/block_cache.h	138;"	d
include/tags:BLKCACHE_MINREF_INCREMENT	../include/block_cache.h	33;"	d
include/tags:BLKCACHE_NOT_EVICTION_CANDIDATE	../include/block_cache.h	35;"	d
include/tags:BLKCACHE_NVRAM	../include/block_cache.h	23;"	d
include/tags:BLKCACHE_RM_EVICTION	../include/block_cache.h	40;"	d
include/tags:BLKCACHE_RM_EXIT	../include/block_cache.h	38;"	d
include/tags:BLKCACHE_RM_FREE	../include/block_cache.h	39;"	d
include/tags:BLKCACHE_UNCONFIGURED	../include/block_cache.h	21;"	d
include/tags:CKSUM_UNCOMPRESSED	../include/btree.h	/^    CKSUM_UNCOMPRESSED = 3, \/* Uncompressed blocks only *\/$/;"	e	enum:__anon64
include/tags:CKSUM_UNENCRYPTED	../include/btree.h	/^    CKSUM_UNENCRYPTED = 4   \/* Unencrypted blocks only *\/$/;"	e	enum:__anon64
include/tags:WT_BLOCK	../include/wt_internal.h	/^    typedef struct __wt_block WT_BLOCK;$/;"	t	typeref:struct:__wt_block
include/tags:WT_BLOCK_CHECKPOINT_BUFFER	../include/block.h	170;"	d
include/tags:WT_BLOCK_CKPT	../include/wt_internal.h	/^    typedef struct __wt_block_ckpt WT_BLOCK_CKPT;$/;"	t	typeref:struct:__wt_block_ckpt
include/tags:WT_BLOCK_COMPRESS_SKIP	../include/block.h	540;"	d
include/tags:WT_BLOCK_COOKIE_FILEID	../block/block_addr.c	11;"	d	file:
include/tags:WT_BLOCK_DATA_CKSUM	../include/block.h	479;"	d
include/tags:WT_BLOCK_DESC	../include/wt_internal.h	/^    typedef struct __wt_block_desc WT_BLOCK_DESC;$/;"	t	typeref:struct:__wt_block_desc
include/tags:WT_BLOCK_DESC_SIZE	../include/block.h	424;"	d
include/tags:WT_BLOCK_ENCRYPT_SKIP	../include/block.h	541;"	d
include/tags:WT_BLOCK_EXTLIST_MAGIC	../include/block.h	157;"	d
include/tags:WT_BLOCK_EXTLIST_VERSION_CKPT	../include/block.h	164;"	d
include/tags:WT_BLOCK_EXTLIST_VERSION_ORIG	../include/block.h	163;"	d
include/tags:WT_BLOCK_HEADER	../include/wt_internal.h	/^    typedef struct __wt_block_header WT_BLOCK_HEADER;$/;"	t	typeref:struct:__wt_block_header
include/tags:WT_BLOCK_HEADER_BYTE	../include/block.h	529;"	d
include/tags:WT_BLOCK_HEADER_BYTE_SIZE	../include/block.h	528;"	d
include/tags:WT_BLOCK_HEADER_SIZE	../include/block.h	492;"	d
include/tags:WT_BLOCK_INVALID_OFFSET	../include/block.h	17;"	d
include/tags:WT_BLOCK_MAGIC	../include/block.h	408;"	d
include/tags:WT_BLOCK_MAJOR_VERSION	../include/block.h	410;"	d
include/tags:WT_BLOCK_MGR_SESSION	../block/block_session.c	/^} WT_BLOCK_MGR_SESSION;$/;"	t	typeref:struct:__anon8	file:
include/tags:WT_BLOCK_MINOR_VERSION	../include/block.h	412;"	d
include/tags:WT_BLOCK_MODS	../include/wt_internal.h	/^    typedef struct __wt_block_mods WT_BLOCK_MODS;$/;"	t	typeref:struct:__wt_block_mods
include/tags:WT_BLOCK_RET	../block/block_ext.c	16;"	d	file:
include/tags:WT_BLOCK_SKIP	../block/block_ckpt_scan.c	204;"	d	file:
include/tags:WT_BM_CHECKPOINT_VERSION	../include/block.h	156;"	d
include/tags:WT_CHECKPOINT_LIST_PROGRESS_INTERVAL	../block/block_ckpt_scan.c	266;"	d	file:
include/tags:WT_CKPT_INPROGRESS	../include/block.h	/^        WT_CKPT_INPROGRESS,$/;"	e	enum:__wt_block::__anon36
include/tags:WT_CKPT_NONE	../include/block.h	/^        WT_CKPT_NONE = 0,$/;"	e	enum:__wt_block::__anon36
include/tags:WT_CKPT_PANIC_ON_FAILURE	../include/block.h	/^        WT_CKPT_PANIC_ON_FAILURE,$/;"	e	enum:__wt_block::__anon36
include/tags:WT_CKPT_SALVAGE	../include/block.h	/^        WT_CKPT_SALVAGE$/;"	e	enum:__wt_block::__anon36
include/tags:WT_CORRUPT_FMT	../block/block_read.c	63;"	d	file:
include/tags:WT_EXT_FOREACH	../include/block.h	143;"	d
include/tags:WT_EXT_FOREACH_OFF	../include/block.h	145;"	d
include/tags:WT_FRAG_TO_OFF	../block/block_vrfy.c	21;"	d	file:
include/tags:WT_wt_off_TO_FRAG	../block/block_vrfy.c	20;"	d	file:
include/tags:__blkcache_alloc	../block_cache/block_cache.c	/^__blkcache_alloc(WT_SESSION_IMPL *session, size_t size, void **retp)$/;"	f	file:
include/tags:__blkcache_estimate_filesize	../block_cache/block_cache.c	/^__blkcache_estimate_filesize(WT_SESSION_IMPL *session)$/;"	f	file:
include/tags:__blkcache_eviction_thread	../block_cache/block_cache.c	/^__blkcache_eviction_thread(void *arg)$/;"	f	file:
include/tags:__blkcache_free	../block_cache/block_cache.c	/^__blkcache_free(WT_SESSION_IMPL *session, void *ptr)$/;"	f	file:
include/tags:__blkcache_high_overhead	../block_cache/block_cache.c	/^__blkcache_high_overhead(WT_SESSION_IMPL *session)$/;"	f	file:
include/tags:__blkcache_init	../block_cache/block_cache.c	/^__blkcache_init(WT_SESSION_IMPL *session, size_t cache_size, u_int hash_size, u_int type,$/;"	f	file:
include/tags:__blkcache_print_reference_hist	../block_cache/block_cache.c	/^__blkcache_print_reference_hist(WT_SESSION_IMPL *session, const char *header, uint32_t *hist)$/;"	f	file:
include/tags:__blkcache_read_corrupt	../block_cache/block_io.c	/^__blkcache_read_corrupt(WT_SESSION_IMPL *session, int error, const uint8_t *addr, size_t addr_size,$/;"	f	file:
include/tags:__blkcache_reconfig	../block_cache/block_cache.c	/^__blkcache_reconfig(WT_SESSION_IMPL *session, bool reconfig, size_t cache_size, size_t hash_size,$/;"	f	file:
include/tags:__blkcache_should_evict	../block_cache/block_cache.c	/^__blkcache_should_evict(WT_SESSION_IMPL *session, WT_BLKCACHE_ITEM *blkcache_item, int *reason)$/;"	f	file:
include/tags:__blkcache_update_ref_histogram	../block_cache/block_cache.c	/^__blkcache_update_ref_histogram(WT_SESSION_IMPL *session, WT_BLKCACHE_ITEM *blkcache_item, int type)$/;"	f	file:
include/tags:__blkcache_verbose	../block_cache/block_cache.c	/^__blkcache_verbose(WT_SESSION_IMPL *session, WT_VERBOSE_LEVEL level, const char *tag, uint64_t hash,$/;"	f	file:
include/tags:__block_addr_unpack	../block/block_addr.c	/^__block_addr_unpack(WT_SESSION_IMPL *session, WT_BLOCK *block, const uint8_t **pp, size_t addr_size,$/;"	f	file:
include/tags:__block_append	../block/block_ext.c	/^__block_append($/;"	f	file:
include/tags:__block_checkpoint_update	../block/block_ckpt_scan.c	/^__block_checkpoint_update(WT_SESSION_IMPL *session, WT_BLOCK *block, struct saved_block_info *info)$/;"	f	file:
include/tags:__block_ckpt_unpack	../block/block_addr.c	/^__block_ckpt_unpack(WT_SESSION_IMPL *session, WT_BLOCK *block, const uint8_t *ckpt,$/;"	f	file:
include/tags:__block_dump_bucket_stat	../block/block_compact.c	/^__block_dump_bucket_stat(WT_SESSION_IMPL *session, uintmax_t file_size, uintmax_t file_free,$/;"	f	file:
include/tags:__block_dump_file_stat	../block/block_compact.c	/^__block_dump_file_stat(WT_SESSION_IMPL *session, WT_BLOCK *block, bool start)$/;"	f	file:
include/tags:__block_ext_alloc	../block/block_session.c	/^__block_ext_alloc(WT_SESSION_IMPL *session, WT_EXT **extp)$/;"	f	file:
include/tags:__block_ext_discard	../block/block_session.c	/^__block_ext_discard(WT_SESSION_IMPL *session, u_int max)$/;"	f	file:
include/tags:__block_ext_insert	../block/block_ext.c	/^__block_ext_insert(WT_SESSION_IMPL *session, WT_EXTLIST *el, WT_EXT *ext)$/;"	f	file:
include/tags:__block_ext_overlap	../block/block_ext.c	/^__block_ext_overlap(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_EXTLIST *ael, WT_EXT **ap,$/;"	f	file:
include/tags:__block_ext_prealloc	../block/block_session.c	/^__block_ext_prealloc(WT_SESSION_IMPL *session, u_int max)$/;"	f	file:
include/tags:__block_extend	../block/block_ext.c	/^__block_extend(WT_SESSION_IMPL *session, WT_BLOCK *block, wt_off_t *offp, wt_off_t size)$/;"	f	file:
include/tags:__block_extlist_dump	../block/block_ext.c	/^__block_extlist_dump(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_EXTLIST *el, const char *tag)$/;"	f	file:
include/tags:__block_first_srch	../block/block_ext.c	/^__block_first_srch(WT_EXT **head, wt_off_t size, WT_EXT ***stack)$/;"	f	file:
include/tags:__block_manager_session_cleanup	../block/block_session.c	/^__block_manager_session_cleanup(WT_SESSION_IMPL *session)$/;"	f	file:
include/tags:__block_merge	../block/block_ext.c	/^__block_merge($/;"	f	file:
include/tags:__block_off_insert	../block/block_ext.c	/^__block_off_insert(WT_SESSION_IMPL *session, WT_EXTLIST *el, wt_off_t off, wt_off_t size)$/;"	f	file:
include/tags:__block_off_match	../block/block_ext.c	/^__block_off_match(WT_EXTLIST *el, wt_off_t off, wt_off_t size)$/;"	f	file:
include/tags:__block_off_remove	../block/block_ext.c	/^__block_off_remove($/;"	f	file:
include/tags:__block_off_srch	../block/block_ext.c	/^__block_off_srch(WT_EXT **head, wt_off_t off, WT_EXT ***stack, bool skip_off, WT_EXT **penultimate_ext)$/;"	f	file:
include/tags:__block_off_srch_last	../block/block_ext.c	/^__block_off_srch_last(WT_EXTLIST *el, WT_EXT ***stack, bool need_traverse)$/;"	f	file:
include/tags:__block_off_srch_pair	../block/block_ext.c	/^__block_off_srch_pair(WT_EXTLIST *el, wt_off_t off, WT_EXT **beforep, WT_EXT **afterp)$/;"	f	file:
include/tags:__block_size_alloc	../block/block_session.c	/^__block_size_alloc(WT_SESSION_IMPL *session, WT_SIZE **szp)$/;"	f	file:
include/tags:__block_size_discard	../block/block_session.c	/^__block_size_discard(WT_SESSION_IMPL *session, u_int max)$/;"	f	file:
include/tags:__block_size_prealloc	../block/block_session.c	/^__block_size_prealloc(WT_SESSION_IMPL *session, u_int max)$/;"	f	file:
include/tags:__block_size_srch	../block/block_ext.c	/^__block_size_srch(WT_SIZE **head, wt_off_t size, WT_SIZE ***stack)$/;"	f	file:
include/tags:__block_write_off	../block/block_write.c	/^__block_write_off(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_ITEM *buf, uint32_t *objectidp,$/;"	f	file:
include/tags:__bm_checkpoint_unload	../block_cache/block_mgr.c	/^__bm_checkpoint_unload(WT_BM *bm, WT_SESSION_IMPL *session)$/;"	f	file:
include/tags:__bm_close	../block_cache/block_mgr.c	/^__bm_close(WT_BM *bm, WT_SESSION_IMPL *session)$/;"	f	file:
include/tags:__bm_compact_end	../block_cache/block_mgr.c	/^__bm_compact_end(WT_BM *bm, WT_SESSION_IMPL *session)$/;"	f	file:
include/tags:__bm_compact_end_readonly	../block_cache/block_mgr.c	/^__bm_compact_end_readonly(WT_BM *bm, WT_SESSION_IMPL *session)$/;"	f	file:
include/tags:__bm_compact_page_rewrite	../block_cache/block_mgr.c	/^__bm_compact_page_rewrite($/;"	f	file:
include/tags:__bm_compact_page_rewrite_readonly	../block_cache/block_mgr.c	/^__bm_compact_page_rewrite_readonly($/;"	f	file:
include/tags:__bm_compact_page_skip	../block_cache/block_mgr.c	/^__bm_compact_page_skip($/;"	f	file:
include/tags:__bm_compact_page_skip_readonly	../block_cache/block_mgr.c	/^__bm_compact_page_skip_readonly($/;"	f	file:
include/tags:__bm_compact_progress	../block_cache/block_mgr.c	/^__bm_compact_progress(WT_BM *bm, WT_SESSION_IMPL *session, u_int *msg_countp)$/;"	f	file:
include/tags:__bm_compact_skip	../block_cache/block_mgr.c	/^__bm_compact_skip(WT_BM *bm, WT_SESSION_IMPL *session, bool *skipp)$/;"	f	file:
include/tags:__bm_compact_skip_readonly	../block_cache/block_mgr.c	/^__bm_compact_skip_readonly(WT_BM *bm, WT_SESSION_IMPL *session, bool *skipp)$/;"	f	file:
include/tags:__bm_compact_start	../block_cache/block_mgr.c	/^__bm_compact_start(WT_BM *bm, WT_SESSION_IMPL *session)$/;"	f	file:
include/tags:__bm_compact_start_readonly	../block_cache/block_mgr.c	/^__bm_compact_start_readonly(WT_BM *bm, WT_SESSION_IMPL *session)$/;"	f	file:
include/tags:__bm_free	../block_cache/block_mgr.c	/^__bm_free(WT_BM *bm, WT_SESSION_IMPL *session, const uint8_t *addr, size_t addr_size)$/;"	f	file:
include/tags:__bm_free_readonly	../block_cache/block_mgr.c	/^__bm_free_readonly(WT_BM *bm, WT_SESSION_IMPL *session, const uint8_t *addr, size_t addr_size)$/;"	f	file:
include/tags:__bm_is_mapped	../block_cache/block_mgr.c	/^__bm_is_mapped(WT_BM *bm, WT_SESSION_IMPL *session)$/;"	f	file:
include/tags:__bm_map_discard	../block_cache/block_mgr.c	/^__bm_map_discard(WT_BM *bm, WT_SESSION_IMPL *session, void *map, size_t len)$/;"	f	file:
include/tags:__bm_method_set	../block_cache/block_mgr.c	/^__bm_method_set(WT_BM *bm, bool readonly)$/;"	f	file:
include/tags:__bm_read	../block_cache/block_mgr.c	/^__bm_read(WT_BM *bm, WT_SESSION_IMPL *session, WT_ITEM *buf, const uint8_t *addr, size_t addr_size)$/;"	f	file:
include/tags:__bm_salvage_end	../block_cache/block_mgr.c	/^__bm_salvage_end(WT_BM *bm, WT_SESSION_IMPL *session)$/;"	f	file:
include/tags:__bm_salvage_end_readonly	../block_cache/block_mgr.c	/^__bm_salvage_end_readonly(WT_BM *bm, WT_SESSION_IMPL *session)$/;"	f	file:
include/tags:__bm_salvage_next	../block_cache/block_mgr.c	/^__bm_salvage_next($/;"	f	file:
include/tags:__bm_salvage_next_readonly	../block_cache/block_mgr.c	/^__bm_salvage_next_readonly($/;"	f	file:
include/tags:__bm_salvage_start	../block_cache/block_mgr.c	/^__bm_salvage_start(WT_BM *bm, WT_SESSION_IMPL *session)$/;"	f	file:
include/tags:__bm_salvage_start_readonly	../block_cache/block_mgr.c	/^__bm_salvage_start_readonly(WT_BM *bm, WT_SESSION_IMPL *session)$/;"	f	file:
include/tags:__bm_salvage_valid	../block_cache/block_mgr.c	/^__bm_salvage_valid(WT_BM *bm, WT_SESSION_IMPL *session, uint8_t *addr, size_t addr_size, bool valid)$/;"	f	file:
include/tags:__bm_salvage_valid_readonly	../block_cache/block_mgr.c	/^__bm_salvage_valid_readonly($/;"	f	file:
include/tags:__bm_stat	../block_cache/block_mgr.c	/^__bm_stat(WT_BM *bm, WT_SESSION_IMPL *session, WT_DSRC_STATS *stats)$/;"	f	file:
include/tags:__bm_switch_object	../block_cache/block_mgr.c	/^__bm_switch_object(WT_BM *bm, WT_SESSION_IMPL *session, uint32_t objectid)$/;"	f	file:
include/tags:__bm_switch_object_readonly	../block_cache/block_mgr.c	/^__bm_switch_object_readonly(WT_BM *bm, WT_SESSION_IMPL *session, uint32_t objectid)$/;"	f	file:
include/tags:__bm_sync	../block_cache/block_mgr.c	/^__bm_sync(WT_BM *bm, WT_SESSION_IMPL *session, bool block)$/;"	f	file:
include/tags:__bm_sync_readonly	../block_cache/block_mgr.c	/^__bm_sync_readonly(WT_BM *bm, WT_SESSION_IMPL *session, bool async)$/;"	f	file:
include/tags:__bm_verify_addr	../block_cache/block_mgr.c	/^__bm_verify_addr(WT_BM *bm, WT_SESSION_IMPL *session, const uint8_t *addr, size_t addr_size)$/;"	f	file:
include/tags:__bm_verify_end	../block_cache/block_mgr.c	/^__bm_verify_end(WT_BM *bm, WT_SESSION_IMPL *session)$/;"	f	file:
include/tags:__bm_verify_start	../block_cache/block_mgr.c	/^__bm_verify_start(WT_BM *bm, WT_SESSION_IMPL *session, WT_CKPT *ckptbase, const char *cfg[])$/;"	f	file:
include/tags:__bm_write	../block_cache/block_mgr.c	/^__bm_write(WT_BM *bm, WT_SESSION_IMPL *session, WT_ITEM *buf, uint8_t *addr, size_t *addr_sizep,$/;"	f	file:
include/tags:__bm_write_readonly	../block_cache/block_mgr.c	/^__bm_write_readonly(WT_BM *bm, WT_SESSION_IMPL *session, WT_ITEM *buf, uint8_t *addr,$/;"	f	file:
include/tags:__bm_write_size	../block_cache/block_mgr.c	/^__bm_write_size(WT_BM *bm, WT_SESSION_IMPL *session, size_t *sizep)$/;"	f	file:
include/tags:__bm_write_size_readonly	../block_cache/block_mgr.c	/^__bm_write_size_readonly(WT_BM *bm, WT_SESSION_IMPL *session, size_t *sizep)$/;"	f	file:
include/tags:__ckpt_add_blk_mods_alloc	../block/block_ckpt.c	/^__ckpt_add_blk_mods_alloc($/;"	f	file:
include/tags:__ckpt_add_blk_mods_ext	../block/block_ckpt.c	/^__ckpt_add_blk_mods_ext(WT_SESSION_IMPL *session, WT_CKPT *ckptbase, WT_BLOCK_CKPT *ci)$/;"	f	file:
include/tags:__ckpt_add_blkmod_entry	../block/block_ckpt.c	/^__ckpt_add_blkmod_entry($/;"	f	file:
include/tags:__ckpt_extlist_fblocks	../block/block_ckpt.c	/^__ckpt_extlist_fblocks(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_EXTLIST *el)$/;"	f	file:
include/tags:__ckpt_extlist_read	../block/block_ckpt.c	/^__ckpt_extlist_read(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_CKPT *ckpt, bool *localp)$/;"	f	file:
include/tags:__ckpt_process	../block/block_ckpt.c	/^__ckpt_process(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_CKPT *ckptbase)$/;"	f	file:
include/tags:__ckpt_update	../block/block_ckpt.c	/^__ckpt_update($/;"	f	file:
include/tags:__ckpt_verify	../block/block_ckpt.c	/^__ckpt_verify(WT_SESSION_IMPL *session, WT_CKPT *ckptbase)$/;"	f	file:
include/tags:__compact_page_skip	../block/block_compact.c	/^__compact_page_skip($/;"	f	file:
include/tags:__create_file_block_manager	../schema/schema_create.c	/^__create_file_block_manager($/;"	f	file:
include/tags:__desc_read	../block/block_open.c	/^__desc_read(WT_SESSION_IMPL *session, uint32_t allocsize, WT_BLOCK *block)$/;"	f	file:
include/tags:__read_blocked	../support/mtx_rw.c	/^__read_blocked(WT_SESSION_IMPL *session)$/;"	f	file:
include/tags:__session_blocking_checkpoint	../session/session_api.c	/^__session_blocking_checkpoint(WT_SESSION_IMPL *session)$/;"	f	file:
include/tags:__slvg_merge_block_free	../btree/bt_slvg.c	/^__slvg_merge_block_free(WT_SESSION_IMPL *session, WT_STUFF *ss)$/;"	f	file:
include/tags:__slvg_trk_free_block	../btree/bt_slvg.c	/^__slvg_trk_free_block(WT_SESSION_IMPL *session, WT_TRACK *trk)$/;"	f	file:
include/tags:__ut_block_first_srch	../block/block_ext.c	/^__ut_block_first_srch(WT_EXT **head, wt_off_t size, WT_EXT ***stack)$/;"	f
include/tags:__ut_block_off_srch	../block/block_ext.c	/^__ut_block_off_srch(WT_EXT **head, wt_off_t off, WT_EXT ***stack, bool skip_off)$/;"	f
include/tags:__ut_block_off_srch_last	../block/block_ext.c	/^__ut_block_off_srch_last(WT_EXTLIST *el, WT_EXT ***stack, bool need_traverse)$/;"	f
include/tags:__ut_block_size_srch	../block/block_ext.c	/^__ut_block_size_srch(WT_SIZE **head, wt_off_t size, WT_SIZE ***stack)$/;"	f
include/tags:__ut_ckpt_add_blkmod_entry	../block/block_ckpt.c	/^__ut_ckpt_add_blkmod_entry($/;"	f
include/tags:__verify_ckptfrag_add	../block/block_vrfy.c	/^__verify_ckptfrag_add(WT_SESSION_IMPL *session, WT_BLOCK *block, wt_off_t offset, wt_off_t size)$/;"	f	file:
include/tags:__verify_ckptfrag_chk	../block/block_vrfy.c	/^__verify_ckptfrag_chk(WT_SESSION_IMPL *session, WT_BLOCK *block)$/;"	f	file:
include/tags:__verify_filefrag_add	../block/block_vrfy.c	/^__verify_filefrag_add(WT_SESSION_IMPL *session, WT_BLOCK *block, const char *type, wt_off_t offset,$/;"	f	file:
include/tags:__verify_filefrag_chk	../block/block_vrfy.c	/^__verify_filefrag_chk(WT_SESSION_IMPL *session, WT_BLOCK *block)$/;"	f	file:
include/tags:__verify_last_avail	../block/block_vrfy.c	/^__verify_last_avail(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_CKPT *ckpt)$/;"	f	file:
include/tags:__verify_set_file_size	../block/block_vrfy.c	/^__verify_set_file_size(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_CKPT *ckpt)$/;"	f	file:
include/tags:__write_blocked	../support/mtx_rw.c	/^__write_blocked(WT_SESSION_IMPL *session)$/;"	f	file:
include/tags:__wt_blkcache	../include/block_cache.h	/^struct __wt_blkcache {$/;"	s
include/tags:__wt_blkcache_destroy	../block_cache/block_cache.c	/^__wt_blkcache_destroy(WT_SESSION_IMPL *session)$/;"	f
include/tags:__wt_blkcache_get	../block_cache/block_cache.c	/^__wt_blkcache_get(WT_SESSION_IMPL *session, const uint8_t *addr, size_t addr_size,$/;"	f
include/tags:__wt_blkcache_get_handle	../block_cache/block_tier.c	/^__wt_blkcache_get_handle($/;"	f
include/tags:__wt_blkcache_item	../include/block_cache.h	/^struct __wt_blkcache_item {$/;"	s
include/tags:__wt_blkcache_map	../block_cache/block_map.c	/^__wt_blkcache_map(WT_SESSION_IMPL *session, WT_BLOCK *block, void **mapped_regionp, size_t *lengthp,$/;"	f
include/tags:__wt_blkcache_map_read	../block_cache/block_map.c	/^__wt_blkcache_map_read($/;"	f
include/tags:__wt_blkcache_open	../block_cache/block_mgr.c	/^__wt_blkcache_open(WT_SESSION_IMPL *session, const char *uri, const char *cfg[],$/;"	f
include/tags:__wt_blkcache_put	../block_cache/block_cache.c	/^__wt_blkcache_put($/;"	f
include/tags:__wt_blkcache_read	../block_cache/block_io.c	/^__wt_blkcache_read(WT_SESSION_IMPL *session, WT_ITEM *buf, const uint8_t *addr, size_t addr_size)$/;"	f
include/tags:__wt_blkcache_remove	../block_cache/block_cache.c	/^__wt_blkcache_remove(WT_SESSION_IMPL *session, const uint8_t *addr, size_t addr_size)$/;"	f
include/tags:__wt_blkcache_set_readonly	../block_cache/block_mgr.c	/^__wt_blkcache_set_readonly(WT_SESSION_IMPL *session) WT_GCC_FUNC_ATTRIBUTE((cold))$/;"	f
include/tags:__wt_blkcache_setup	../block_cache/block_cache.c	/^__wt_blkcache_setup(WT_SESSION_IMPL *session, const char *cfg[], bool reconfig)$/;"	f
include/tags:__wt_blkcache_tiered_open	../block_cache/block_tier.c	/^__wt_blkcache_tiered_open($/;"	f
include/tags:__wt_blkcache_unmap	../block_cache/block_map.c	/^__wt_blkcache_unmap(WT_SESSION_IMPL *session, WT_BLOCK *block, void *mapped_region, size_t length,$/;"	f
include/tags:__wt_blkcache_write	../block_cache/block_io.c	/^__wt_blkcache_write(WT_SESSION_IMPL *session, WT_ITEM *buf, uint8_t *addr, size_t *addr_sizep,$/;"	f
include/tags:__wt_block	../include/block.h	/^struct __wt_block {$/;"	s
include/tags:__wt_block_addr_invalid	../block/block_addr.c	/^__wt_block_addr_invalid($/;"	f
include/tags:__wt_block_addr_pack	../block/block_addr.c	/^__wt_block_addr_pack(WT_BLOCK *block, uint8_t **pp, uint32_t objectid, wt_off_t offset,$/;"	f
include/tags:__wt_block_addr_string	../block/block_addr.c	/^__wt_block_addr_string($/;"	f
include/tags:__wt_block_addr_unpack	../block/block_addr.c	/^__wt_block_addr_unpack(WT_SESSION_IMPL *session, WT_BLOCK *block, const uint8_t *p,$/;"	f
include/tags:__wt_block_alloc	../block/block_ext.c	/^__wt_block_alloc(WT_SESSION_IMPL *session, WT_BLOCK *block, wt_off_t *offp, wt_off_t size)$/;"	f
include/tags:__wt_block_checkpoint	../block/block_ckpt.c	/^__wt_block_checkpoint($/;"	f
include/tags:__wt_block_checkpoint_final	../block/block_ckpt_scan.c	/^__wt_block_checkpoint_final($/;"	f
include/tags:__wt_block_checkpoint_last	../block/block_ckpt_scan.c	/^__wt_block_checkpoint_last(WT_SESSION_IMPL *session, WT_BLOCK *block, char **metadatap,$/;"	f
include/tags:__wt_block_checkpoint_load	../block/block_ckpt.c	/^__wt_block_checkpoint_load(WT_SESSION_IMPL *session, WT_BLOCK *block, const uint8_t *addr,$/;"	f
include/tags:__wt_block_checkpoint_resolve	../block/block_ckpt.c	/^__wt_block_checkpoint_resolve(WT_SESSION_IMPL *session, WT_BLOCK *block, bool failed)$/;"	f
include/tags:__wt_block_checkpoint_start	../block/block_ckpt.c	/^__wt_block_checkpoint_start(WT_SESSION_IMPL *session, WT_BLOCK *block)$/;"	f
include/tags:__wt_block_checkpoint_unload	../block/block_ckpt.c	/^__wt_block_checkpoint_unload(WT_SESSION_IMPL *session, WT_BLOCK *block, bool checkpoint)$/;"	f
include/tags:__wt_block_ckpt	../include/block.h	/^struct __wt_block_ckpt {$/;"	s
include/tags:__wt_block_ckpt_decode	../block/block_addr.c	/^__wt_block_ckpt_decode(WT_SESSION *wt_session, WT_BLOCK *block, const uint8_t *ckpt,$/;"	f
include/tags:__wt_block_ckpt_destroy	../block/block_ckpt.c	/^__wt_block_ckpt_destroy(WT_SESSION_IMPL *session, WT_BLOCK_CKPT *ci)$/;"	f
include/tags:__wt_block_ckpt_init	../block/block_ckpt.c	/^__wt_block_ckpt_init(WT_SESSION_IMPL *session, WT_BLOCK_CKPT *ci, const char *name)$/;"	f
include/tags:__wt_block_ckpt_pack	../block/block_addr.c	/^__wt_block_ckpt_pack($/;"	f
include/tags:__wt_block_ckpt_unpack	../block/block_addr.c	/^__wt_block_ckpt_unpack(WT_SESSION_IMPL *session, WT_BLOCK *block, const uint8_t *ckpt,$/;"	f
include/tags:__wt_block_close	../block/block_open.c	/^__wt_block_close(WT_SESSION_IMPL *session, WT_BLOCK *block)$/;"	f
include/tags:__wt_block_compact_end	../block/block_compact.c	/^__wt_block_compact_end(WT_SESSION_IMPL *session, WT_BLOCK *block)$/;"	f
include/tags:__wt_block_compact_get_progress_stats	../block/block_compact.c	/^__wt_block_compact_get_progress_stats(WT_SESSION_IMPL *session, WT_BM *bm,$/;"	f
include/tags:__wt_block_compact_page_rewrite	../block/block_compact.c	/^__wt_block_compact_page_rewrite($/;"	f
include/tags:__wt_block_compact_page_skip	../block/block_compact.c	/^__wt_block_compact_page_skip($/;"	f
include/tags:__wt_block_compact_progress	../block/block_compact.c	/^__wt_block_compact_progress(WT_SESSION_IMPL *session, WT_BLOCK *block, u_int *msg_countp)$/;"	f
include/tags:__wt_block_compact_skip	../block/block_compact.c	/^__wt_block_compact_skip(WT_SESSION_IMPL *session, WT_BLOCK *block, bool *skipp)$/;"	f
include/tags:__wt_block_compact_start	../block/block_compact.c	/^__wt_block_compact_start(WT_SESSION_IMPL *session, WT_BLOCK *block)$/;"	f
include/tags:__wt_block_configure_first_fit	../block/block_open.c	/^__wt_block_configure_first_fit(WT_BLOCK *block, bool on)$/;"	f
include/tags:__wt_block_desc	../include/block.h	/^struct __wt_block_desc {$/;"	s
include/tags:__wt_block_desc_byteswap	../include/block.h	/^__wt_block_desc_byteswap(WT_BLOCK_DESC *desc)$/;"	f
include/tags:__wt_block_discard	../block/block_write.c	/^__wt_block_discard(WT_SESSION_IMPL *session, WT_BLOCK *block, size_t added_size)$/;"	f
include/tags:__wt_block_ext_alloc	../block/block_session.c	/^__wt_block_ext_alloc(WT_SESSION_IMPL *session, WT_EXT **extp)$/;"	f
include/tags:__wt_block_ext_discard	../block/block_session.c	/^__wt_block_ext_discard(WT_SESSION_IMPL *session, u_int max)$/;"	f
include/tags:__wt_block_ext_free	../block/block_session.c	/^__wt_block_ext_free(WT_SESSION_IMPL *session, WT_EXT *ext)$/;"	f
include/tags:__wt_block_ext_prealloc	../block/block_session.c	/^__wt_block_ext_prealloc(WT_SESSION_IMPL *session, u_int max)$/;"	f
include/tags:__wt_block_extend	../block/block_write.c	/^__wt_block_extend(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_FH *fh, wt_off_t offset,$/;"	f	file:
include/tags:__wt_block_extlist_check	../block/block_ext.c	/^__wt_block_extlist_check(WT_SESSION_IMPL *session, WT_EXTLIST *al, WT_EXTLIST *bl)$/;"	f
include/tags:__wt_block_extlist_free	../block/block_ext.c	/^__wt_block_extlist_free(WT_SESSION_IMPL *session, WT_EXTLIST *el)$/;"	f
include/tags:__wt_block_extlist_init	../block/block_ext.c	/^__wt_block_extlist_init($/;"	f
include/tags:__wt_block_extlist_merge	../block/block_ext.c	/^__wt_block_extlist_merge(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_EXTLIST *a, WT_EXTLIST *b)$/;"	f
include/tags:__wt_block_extlist_overlap	../block/block_ext.c	/^__wt_block_extlist_overlap(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_BLOCK_CKPT *ci)$/;"	f
include/tags:__wt_block_extlist_read	../block/block_ext.c	/^__wt_block_extlist_read($/;"	f
include/tags:__wt_block_extlist_read_avail	../block/block_ext.c	/^__wt_block_extlist_read_avail($/;"	f
include/tags:__wt_block_extlist_truncate	../block/block_ext.c	/^__wt_block_extlist_truncate(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_EXTLIST *el)$/;"	f
include/tags:__wt_block_extlist_write	../block/block_ext.c	/^__wt_block_extlist_write($/;"	f
include/tags:__wt_block_free	../block/block_ext.c	/^__wt_block_free(WT_SESSION_IMPL *session, WT_BLOCK *block, const uint8_t *addr, size_t addr_size)$/;"	f
include/tags:__wt_block_header	../include/block.h	/^__wt_block_header(WT_BLOCK *block)$/;"	f
include/tags:__wt_block_header	../include/block.h	/^struct __wt_block_header {$/;"	s
include/tags:__wt_block_header_byteswap	../include/block.h	/^__wt_block_header_byteswap(WT_BLOCK_HEADER *blk)$/;"	f
include/tags:__wt_block_header_byteswap_copy	../include/block.h	/^__wt_block_header_byteswap_copy(WT_BLOCK_HEADER *from, WT_BLOCK_HEADER *to)$/;"	f
include/tags:__wt_block_insert_ext	../block/block_ext.c	/^__wt_block_insert_ext($/;"	f
include/tags:__wt_block_manager_create	../block/block_open.c	/^__wt_block_manager_create(WT_SESSION_IMPL *session, const char *filename, uint32_t allocsize)$/;"	f
include/tags:__wt_block_manager_drop	../block/block_open.c	/^__wt_block_manager_drop(WT_SESSION_IMPL *session, const char *filename, bool durable)$/;"	f
include/tags:__wt_block_manager_drop_object	../block/block_open.c	/^__wt_block_manager_drop_object($/;"	f
include/tags:__wt_block_manager_named_size	../block/block_open.c	/^__wt_block_manager_named_size(WT_SESSION_IMPL *session, const char *name, wt_off_t *sizep)$/;"	f
include/tags:__wt_block_manager_size	../block/block_open.c	/^__wt_block_manager_size(WT_BM *bm, WT_SESSION_IMPL *session, wt_off_t *sizep)$/;"	f
include/tags:__wt_block_misplaced	../block/block_ext.c	/^__wt_block_misplaced(WT_SESSION_IMPL *session, WT_BLOCK *block, const char *list, wt_off_t offset,$/;"	f
include/tags:__wt_block_mods	../include/meta.h	/^struct __wt_block_mods {$/;"	s
include/tags:__wt_block_off_free	../block/block_ext.c	/^__wt_block_off_free($/;"	f
include/tags:__wt_block_off_remove_overlap	../block/block_ext.c	/^__wt_block_off_remove_overlap($/;"	f
include/tags:__wt_block_offset_invalid	../block/block_slvg.c	/^__wt_block_offset_invalid(WT_BLOCK *block, wt_off_t offset, uint32_t size)$/;"	f
include/tags:__wt_block_open	../block/block_open.c	/^__wt_block_open(WT_SESSION_IMPL *session, const char *filename, uint32_t objectid,$/;"	f
include/tags:__wt_block_read_off	../block/block_read.c	/^__wt_block_read_off(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_ITEM *buf, uint32_t objectid,$/;"	f
include/tags:__wt_block_read_off_blind	../block/block_read.c	/^__wt_block_read_off_blind($/;"	f
include/tags:__wt_block_salvage_end	../block/block_slvg.c	/^__wt_block_salvage_end(WT_SESSION_IMPL *session, WT_BLOCK *block)$/;"	f
include/tags:__wt_block_salvage_next	../block/block_slvg.c	/^__wt_block_salvage_next($/;"	f
include/tags:__wt_block_salvage_start	../block/block_slvg.c	/^__wt_block_salvage_start(WT_SESSION_IMPL *session, WT_BLOCK *block)$/;"	f
include/tags:__wt_block_salvage_valid	../block/block_slvg.c	/^__wt_block_salvage_valid($/;"	f
include/tags:__wt_block_size_alloc	../block/block_session.c	/^__wt_block_size_alloc(WT_SESSION_IMPL *session, WT_SIZE **szp)$/;"	f
include/tags:__wt_block_size_free	../block/block_session.c	/^__wt_block_size_free(WT_SESSION_IMPL *session, WT_SIZE *sz)$/;"	f
include/tags:__wt_block_stat	../block/block_open.c	/^__wt_block_stat(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_DSRC_STATS *stats)$/;"	f
include/tags:__wt_block_truncate	../block/block_write.c	/^__wt_block_truncate(WT_SESSION_IMPL *session, WT_BLOCK *block, wt_off_t len)$/;"	f
include/tags:__wt_block_verify_addr	../block/block_vrfy.c	/^__wt_block_verify_addr($/;"	f
include/tags:__wt_block_verify_end	../block/block_vrfy.c	/^__wt_block_verify_end(WT_SESSION_IMPL *session, WT_BLOCK *block)$/;"	f
include/tags:__wt_block_verify_start	../block/block_vrfy.c	/^__wt_block_verify_start($/;"	f
include/tags:__wt_block_write	../block/block_write.c	/^__wt_block_write(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_ITEM *buf, uint8_t *addr,$/;"	f
include/tags:__wt_block_write_off	../block/block_write.c	/^__wt_block_write_off(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_ITEM *buf, uint32_t *objectidp,$/;"	f
include/tags:__wt_block_write_size	../block/block_write.c	/^__wt_block_write_size(WT_SESSION_IMPL *session, WT_BLOCK *block, size_t *sizep)$/;"	f
include/tags:__wt_bm	../include/block.h	/^struct __wt_bm {$/;"	s
include/tags:__wt_bm_corrupt	../block/block_read.c	/^__wt_bm_corrupt(WT_BM *bm, WT_SESSION_IMPL *session, const uint8_t *addr, size_t addr_size)$/;"	f
include/tags:__wt_bm_corrupt_dump	../block/block_read.c	/^__wt_bm_corrupt_dump(WT_SESSION_IMPL *session, WT_ITEM *buf, uint32_t objectid, wt_off_t offset,$/;"	f	file:
include/tags:__wt_bm_read	../block/block_read.c	/^__wt_bm_read($/;"	f
include/tags:__wt_btree_block_free	../include/btree_inline.h	/^__wt_btree_block_free(WT_SESSION_IMPL *session, const uint8_t *addr, size_t addr_size)$/;"	f
include/tags:__wt_ckpt_verbose	../block/block_addr.c	/^__wt_ckpt_verbose(WT_SESSION_IMPL *session, WT_BLOCK *block, const char *tag,$/;"	f
include/tags:__wt_desc_write	../block/block_open.c	/^__wt_desc_write(WT_SESSION_IMPL *session, WT_FH *fh, uint32_t allocsize)$/;"	f
include/tags:__wt_ext	../include/block.h	/^struct __wt_ext {$/;"	s
include/tags:__wt_extlist	../include/block.h	/^struct __wt_extlist {$/;"	s
include/tags:__wt_extlist_read_pair	../include/block_inline.h	/^__wt_extlist_read_pair(const uint8_t **p, wt_off_t *offp, wt_off_t *sizep)$/;"	f
include/tags:__wt_extlist_write_pair	../include/block_inline.h	/^__wt_extlist_write_pair(uint8_t **p, wt_off_t off, wt_off_t size)$/;"	f
include/tags:__wt_fsync	../include/os_fhandle_inline.h	/^__wt_fsync(WT_SESSION_IMPL *session, WT_FH *fh, bool block)$/;"	f
include/tags:__wt_meta_block_metadata	../meta/meta_ckpt.c	/^__wt_meta_block_metadata(WT_SESSION_IMPL *session, const char *config, WT_CKPT *ckpt)$/;"	f
include/tags:__wt_ref_block_free	../include/btree_inline.h	/^__wt_ref_block_free(WT_SESSION_IMPL *session, WT_REF *ref)$/;"	f
include/tags:__wt_size	../include/block.h	/^struct __wt_size {$/;"	s
include/tags:__wt_txn_is_blocking	../txn/txn.c	/^__wt_txn_is_blocking(WT_SESSION_IMPL *session)$/;"	f
include/tags:__wt_txn_modify_block	../include/txn_inline.h	/^__wt_txn_modify_block($/;"	f
include/tags:__wt_verify_ckpt_load	../block/block_vrfy.c	/^__wt_verify_ckpt_load(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_BLOCK_CKPT *ci)$/;"	f
include/tags:__wt_verify_ckpt_unload	../block/block_vrfy.c	/^__wt_verify_ckpt_unload(WT_SESSION_IMPL *session, WT_BLOCK *block)$/;"	f
include/tags:addr	../include/block_cache.h	/^    uint8_t addr[];$/;"	m	struct:__wt_blkcache_item
include/tags:addr_invalid	../include/block.h	/^    int (*addr_invalid)(WT_BM *, WT_SESSION_IMPL *, const uint8_t *, size_t);$/;"	m	struct:__wt_bm
include/tags:addr_size	../include/block_cache.h	/^    uint8_t addr_size; \/* Address cookie *\/$/;"	m	struct:__wt_blkcache_item
include/tags:addr_string	../include/block.h	/^    int (*addr_string)(WT_BM *, WT_SESSION_IMPL *, WT_ITEM *, const uint8_t *, size_t);$/;"	m	struct:__wt_bm
include/tags:alloc	../include/block.h	/^    WT_EXTLIST alloc;   \/* Extents allocated *\/ \/\/__wt_block_allocextalloc$/;"	m	struct:__wt_block_ckpt
include/tags:allocfirst	../include/block.h	/^    uint32_t allocfirst; \/* Allocation is first-fit *\/$/;"	m	struct:__wt_block
include/tags:allocsize	../include/block.h	/^    uint32_t allocsize;  \/* Allocation size *\/$/;"	m	struct:__wt_block
include/tags:avail	../include/block.h	/^    WT_EXTLIST avail;   \/* Extents available *\/$/;"	m	struct:__wt_block_ckpt
include/tags:backup_blocks	../include/meta.h	/^    WT_BLOCK_MODS backup_blocks[WT_BLKINCR_MAX];$/;"	m	struct:__wt_ckpt
include/tags:bitstring	../include/cursor.h	/^    WT_ITEM bitstring;    \/* List of modified blocks *\/$/;"	m	struct:__wt_cursor_backup
include/tags:bitstring	../include/meta.h	/^    WT_ITEM bitstring;$/;"	m	struct:__wt_block_mods
include/tags:blkcache_exiting	../include/block_cache.h	/^    volatile bool blkcache_exiting; \/* If destroying the cache *\/$/;"	m	struct:__wt_blkcache
include/tags:block	../include/block.h	/^    WT_BLOCK *block; \/* Underlying file *\/$/;"	m	struct:__wt_bm
include/tags:block_alloc	../include/stat.h	/^    int64_t block_alloc;$/;"	m	struct:__wt_dsrc_stats
include/tags:block_byte_map_read	../include/stat.h	/^    int64_t block_byte_map_read;$/;"	m	struct:__wt_connection_stats
include/tags:block_byte_read	../include/stat.h	/^    int64_t block_byte_read;$/;"	m	struct:__wt_connection_stats
include/tags:block_byte_read_mmap	../include/stat.h	/^    int64_t block_byte_read_mmap;$/;"	m	struct:__wt_connection_stats
include/tags:block_byte_read_syscall	../include/stat.h	/^    int64_t block_byte_read_syscall;$/;"	m	struct:__wt_connection_stats
include/tags:block_byte_write	../include/stat.h	/^    int64_t block_byte_write;$/;"	m	struct:__wt_connection_stats
include/tags:block_byte_write_checkpoint	../include/stat.h	/^    int64_t block_byte_write_checkpoint;$/;"	m	struct:__wt_connection_stats
include/tags:block_byte_write_mmap	../include/stat.h	/^    int64_t block_byte_write_mmap;$/;"	m	struct:__wt_connection_stats
include/tags:block_byte_write_syscall	../include/stat.h	/^    int64_t block_byte_write_syscall;$/;"	m	struct:__wt_connection_stats
include/tags:block_cache_blocks	../include/stat.h	/^    int64_t block_cache_blocks;$/;"	m	struct:__wt_connection_stats
include/tags:block_cache_blocks_evicted	../include/stat.h	/^    int64_t block_cache_blocks_evicted;$/;"	m	struct:__wt_connection_stats
include/tags:block_cache_blocks_insert_read	../include/stat.h	/^    int64_t block_cache_blocks_insert_read;$/;"	m	struct:__wt_connection_stats
include/tags:block_cache_blocks_insert_write	../include/stat.h	/^    int64_t block_cache_blocks_insert_write;$/;"	m	struct:__wt_connection_stats
include/tags:block_cache_blocks_removed	../include/stat.h	/^    int64_t block_cache_blocks_removed;$/;"	m	struct:__wt_connection_stats
include/tags:block_cache_blocks_update	../include/stat.h	/^    int64_t block_cache_blocks_update;$/;"	m	struct:__wt_connection_stats
include/tags:block_cache_bypass_chkpt	../include/stat.h	/^    int64_t block_cache_bypass_chkpt;$/;"	m	struct:__wt_connection_stats
include/tags:block_cache_bypass_filesize	../include/stat.h	/^    int64_t block_cache_bypass_filesize;$/;"	m	struct:__wt_connection_stats
include/tags:block_cache_bypass_get	../include/stat.h	/^    int64_t block_cache_bypass_get;$/;"	m	struct:__wt_connection_stats
include/tags:block_cache_bypass_overhead_put	../include/stat.h	/^    int64_t block_cache_bypass_overhead_put;$/;"	m	struct:__wt_connection_stats
include/tags:block_cache_bypass_put	../include/stat.h	/^    int64_t block_cache_bypass_put;$/;"	m	struct:__wt_connection_stats
include/tags:block_cache_bypass_writealloc	../include/stat.h	/^    int64_t block_cache_bypass_writealloc;$/;"	m	struct:__wt_connection_stats
include/tags:block_cache_bytes	../include/stat.h	/^    int64_t block_cache_bytes;$/;"	m	struct:__wt_connection_stats
include/tags:block_cache_bytes_insert_read	../include/stat.h	/^    int64_t block_cache_bytes_insert_read;$/;"	m	struct:__wt_connection_stats
include/tags:block_cache_bytes_insert_write	../include/stat.h	/^    int64_t block_cache_bytes_insert_write;$/;"	m	struct:__wt_connection_stats
include/tags:block_cache_bytes_update	../include/stat.h	/^    int64_t block_cache_bytes_update;$/;"	m	struct:__wt_connection_stats
include/tags:block_cache_eviction_passes	../include/stat.h	/^    int64_t block_cache_eviction_passes;$/;"	m	struct:__wt_connection_stats
include/tags:block_cache_hits	../include/stat.h	/^    int64_t block_cache_hits;$/;"	m	struct:__wt_connection_stats
include/tags:block_cache_lookups	../include/stat.h	/^    int64_t block_cache_lookups;$/;"	m	struct:__wt_connection_stats
include/tags:block_cache_misses	../include/stat.h	/^    int64_t block_cache_misses;$/;"	m	struct:__wt_connection_stats
include/tags:block_cache_not_evicted_overhead	../include/stat.h	/^    int64_t block_cache_not_evicted_overhead;$/;"	m	struct:__wt_connection_stats
include/tags:block_checkpoint	../include/meta.h	/^    char *block_checkpoint; \/* Block-stored checkpoint *\/$/;"	m	struct:__wt_ckpt
include/tags:block_checkpoint_size	../include/stat.h	/^    int64_t block_checkpoint_size;$/;"	m	struct:__wt_dsrc_stats
include/tags:block_extension	../include/stat.h	/^    int64_t block_extension;$/;"	m	struct:__wt_dsrc_stats
include/tags:block_free	../include/stat.h	/^    int64_t block_free;$/;"	m	struct:__wt_dsrc_stats
include/tags:block_header	../include/block.h	/^    u_int (*block_header)(WT_BM *);$/;"	m	struct:__wt_bm
include/tags:block_header	../include/block.h	/^    u_int block_header; \/* Header length *\/$/;"	m	struct:__wt_block
include/tags:block_header	../include/btree.h	/^    u_int block_header; \/* WT_PAGE_HEADER_BYTE_SIZE *\/  \/\/yang add todo xxxxx$/;"	m	struct:__wt_btree
include/tags:block_lock	../include/connection.h	/^    WT_SPINLOCK block_lock; \/* Locked: block manager list *\/$/;"	m	struct:__wt_connection_impl
include/tags:block_magic	../include/stat.h	/^    int64_t block_magic;$/;"	m	struct:__wt_dsrc_stats
include/tags:block_major	../include/stat.h	/^    int64_t block_major;$/;"	m	struct:__wt_dsrc_stats
include/tags:block_manager	../include/session.h	/^    void *block_manager; \/* Block-manager support *\/$/;"	m	struct:__wt_session_impl
include/tags:block_manager_cleanup	../include/session.h	/^    int (*block_manager_cleanup)(WT_SESSION_IMPL *);$/;"	m	struct:__wt_session_impl
include/tags:block_map_read	../include/stat.h	/^    int64_t block_map_read;$/;"	m	struct:__wt_connection_stats
include/tags:block_metadata	../include/meta.h	/^    char *block_metadata;   \/* Block-stored metadata *\/$/;"	m	struct:__wt_ckpt
include/tags:block_minor	../include/stat.h	/^    int64_t block_minor;$/;"	m	struct:__wt_dsrc_stats
include/tags:block_preload	../include/stat.h	/^    int64_t block_preload;$/;"	m	struct:__wt_connection_stats
include/tags:block_read	../include/stat.h	/^    int64_t block_read;$/;"	m	struct:__wt_connection_stats
include/tags:block_remap_file_resize	../include/stat.h	/^    int64_t block_remap_file_resize;$/;"	m	struct:__wt_connection_stats
include/tags:block_remap_file_write	../include/stat.h	/^    int64_t block_remap_file_write;$/;"	m	struct:__wt_connection_stats
include/tags:block_reuse_bytes	../include/stat.h	/^    int64_t block_reuse_bytes;$/;"	m	struct:__wt_dsrc_stats
include/tags:block_size	../include/stat.h	/^    int64_t block_size;$/;"	m	struct:__wt_dsrc_stats
include/tags:block_write	../include/stat.h	/^    int64_t block_write;$/;"	m	struct:__wt_connection_stats
include/tags:bytes	../include/block.h	/^    uint64_t bytes;   \/* Byte count *\/$/;"	m	struct:__wt_extlist
include/tags:bytes_used	../include/block_cache.h	/^    uint64_t bytes_used; \/* Bytes in the block cache *\/$/;"	m	struct:__wt_blkcache
include/tags:cache_eviction_blocked_checkpoint_hs	../include/stat.h	/^    int64_t cache_eviction_blocked_checkpoint_hs;$/;"	m	struct:__wt_connection_stats
include/tags:cache_eviction_blocked_checkpoint_hs	../include/stat.h	/^    int64_t cache_eviction_blocked_checkpoint_hs;$/;"	m	struct:__wt_dsrc_stats
include/tags:cache_eviction_blocked_no_ts_checkpoint_race_1	../include/stat.h	/^    int64_t cache_eviction_blocked_no_ts_checkpoint_race_1;$/;"	m	struct:__wt_connection_stats
include/tags:cache_eviction_blocked_no_ts_checkpoint_race_1	../include/stat.h	/^    int64_t cache_eviction_blocked_no_ts_checkpoint_race_1;$/;"	m	struct:__wt_dsrc_stats
include/tags:cache_eviction_blocked_no_ts_checkpoint_race_2	../include/stat.h	/^    int64_t cache_eviction_blocked_no_ts_checkpoint_race_2;$/;"	m	struct:__wt_connection_stats
include/tags:cache_eviction_blocked_no_ts_checkpoint_race_2	../include/stat.h	/^    int64_t cache_eviction_blocked_no_ts_checkpoint_race_2;$/;"	m	struct:__wt_dsrc_stats
include/tags:cache_eviction_blocked_no_ts_checkpoint_race_3	../include/stat.h	/^    int64_t cache_eviction_blocked_no_ts_checkpoint_race_3;$/;"	m	struct:__wt_connection_stats
include/tags:cache_eviction_blocked_no_ts_checkpoint_race_3	../include/stat.h	/^    int64_t cache_eviction_blocked_no_ts_checkpoint_race_3;$/;"	m	struct:__wt_dsrc_stats
include/tags:cache_eviction_blocked_no_ts_checkpoint_race_4	../include/stat.h	/^    int64_t cache_eviction_blocked_no_ts_checkpoint_race_4;$/;"	m	struct:__wt_connection_stats
include/tags:cache_eviction_blocked_no_ts_checkpoint_race_4	../include/stat.h	/^    int64_t cache_eviction_blocked_no_ts_checkpoint_race_4;$/;"	m	struct:__wt_dsrc_stats
include/tags:cache_eviction_blocked_remove_hs_race_with_checkpoint	../include/stat.h	/^    int64_t cache_eviction_blocked_remove_hs_race_with_checkpoint;$/;"	m	struct:__wt_connection_stats
include/tags:cache_eviction_blocked_remove_hs_race_with_checkpoint	../include/stat.h	/^    int64_t cache_eviction_blocked_remove_hs_race_with_checkpoint;$/;"	m	struct:__wt_dsrc_stats
include/tags:cache_lock	../include/block.h	/^    WT_SPINLOCK cache_lock;   \/* Block cache layer lock *\/$/;"	m	struct:__wt_block
include/tags:cache_on_checkpoint	../include/block_cache.h	/^    bool cache_on_checkpoint; \/* Don't cache blocks written by checkpoints *\/$/;"	m	struct:__wt_blkcache
include/tags:cache_on_writes	../include/block_cache.h	/^    bool cache_on_writes;     \/* Cache blocks on writes *\/$/;"	m	struct:__wt_blkcache
include/tags:cache_references	../include/block_cache.h	/^    uint32_t cache_references[BLKCACHE_HIST_BUCKETS];$/;"	m	struct:__wt_blkcache
include/tags:cache_references_evicted_blocks	../include/block_cache.h	/^    uint32_t cache_references_evicted_blocks[BLKCACHE_HIST_BUCKETS];$/;"	m	struct:__wt_blkcache
include/tags:cache_references_removed_blocks	../include/block_cache.h	/^    uint32_t cache_references_removed_blocks[BLKCACHE_HIST_BUCKETS];$/;"	m	struct:__wt_blkcache
include/tags:checkpoint	../block/block_ckpt_scan.c	/^    WT_ITEM *checkpoint;$/;"	m	struct:saved_block_info	file:
include/tags:checkpoint	../include/block.h	/^    int (*checkpoint)(WT_BM *, WT_SESSION_IMPL *, WT_ITEM *, WT_CKPT *, bool);$/;"	m	struct:__wt_bm
include/tags:checkpoint_last	../include/block.h	/^    int (*checkpoint_last)(WT_BM *, WT_SESSION_IMPL *, char **, char **, WT_ITEM *);$/;"	m	struct:__wt_bm
include/tags:checkpoint_list	../block/block_ckpt_scan.c	/^    char *checkpoint_list;$/;"	m	struct:saved_block_info	file:
include/tags:checkpoint_load	../include/block.h	/^    int (*checkpoint_load)($/;"	m	struct:__wt_bm
include/tags:checkpoint_resolve	../include/block.h	/^    int (*checkpoint_resolve)(WT_BM *, WT_SESSION_IMPL *, bool);$/;"	m	struct:__wt_bm
include/tags:checkpoint_start	../include/block.h	/^    int (*checkpoint_start)(WT_BM *, WT_SESSION_IMPL *);$/;"	m	struct:__wt_bm
include/tags:checkpoint_unload	../include/block.h	/^    int (*checkpoint_unload)(WT_BM *, WT_SESSION_IMPL *);$/;"	m	struct:__wt_bm
include/tags:checksum	../block/block_ckpt_scan.c	/^    uint32_t checksum;$/;"	m	struct:saved_block_info	file:
include/tags:checksum	../include/block.h	/^    uint32_t checksum; \/* 04-07: checksum *\/$/;"	m	struct:__wt_block_header
include/tags:checksum	../include/block.h	/^    uint32_t checksum; \/* 08-11: Description block checksum *\/$/;"	m	struct:__wt_block_desc
include/tags:checksum	../include/block.h	/^    uint32_t checksum; \/* Written extent checksum *\/$/;"	m	struct:__wt_extlist
include/tags:child_modify_blocked_page	../include/stat.h	/^    int64_t child_modify_blocked_page;$/;"	m	struct:__wt_connection_stats
include/tags:ckpt_alloc	../include/block.h	/^    WT_EXTLIST ckpt_alloc;   \/* Checkpoint archive *\/$/;"	m	struct:__wt_block_ckpt
include/tags:ckpt_avail	../include/block.h	/^    WT_EXTLIST ckpt_avail; \/* Checkpoint free'd extents *\/$/;"	m	struct:__wt_block_ckpt
include/tags:ckpt_discard	../include/block.h	/^    WT_EXTLIST ckpt_discard; \/* Checkpoint archive *\/$/;"	m	struct:__wt_block_ckpt
include/tags:ckpt_size	../include/block.h	/^    uint64_t ckpt_size; \/* Checkpoint byte count *\/$/;"	m	struct:__wt_block_ckpt
include/tags:ckpt_state	../include/block.h	/^    } ckpt_state;$/;"	m	struct:__wt_block	typeref:enum:__wt_block::__anon36
include/tags:close	../include/block.h	/^    int (*close)(WT_BM *, WT_SESSION_IMPL *);$/;"	m	struct:__wt_bm
include/tags:close_on_checkpoint	../include/block.h	/^    bool close_on_checkpoint;   \/* Close the handle after the next checkpoint *\/$/;"	m	struct:__wt_block
include/tags:compact_end	../include/block.h	/^    int (*compact_end)(WT_BM *, WT_SESSION_IMPL *);$/;"	m	struct:__wt_bm
include/tags:compact_page_rewrite	../include/block.h	/^    int (*compact_page_rewrite)(WT_BM *, WT_SESSION_IMPL *, uint8_t *, size_t *, bool *);$/;"	m	struct:__wt_bm
include/tags:compact_page_skip	../include/block.h	/^    int (*compact_page_skip)(WT_BM *, WT_SESSION_IMPL *, const uint8_t *, size_t, bool *);$/;"	m	struct:__wt_bm
include/tags:compact_pages_reviewed	../include/block.h	/^    uint64_t compact_pages_reviewed;  \/* Pages reviewed *\/$/;"	m	struct:__wt_block
include/tags:compact_pages_rewritten	../include/block.h	/^    uint64_t compact_pages_rewritten; \/* Pages rewritten *\/$/;"	m	struct:__wt_block
include/tags:compact_pages_skipped	../include/block.h	/^    uint64_t compact_pages_skipped;   \/* Pages skipped *\/$/;"	m	struct:__wt_block
include/tags:compact_pct_tenths	../include/block.h	/^    int compact_pct_tenths;           \/* Percent to compact *\/$/;"	m	struct:__wt_block
include/tags:compact_progress	../include/block.h	/^    void (*compact_progress)(WT_BM *, WT_SESSION_IMPL *, u_int *);$/;"	m	struct:__wt_bm
include/tags:compact_skip	../include/block.h	/^    int (*compact_skip)(WT_BM *, WT_SESSION_IMPL *, bool *);$/;"	m	struct:__wt_bm
include/tags:compact_start	../include/block.h	/^    int (*compact_start)(WT_BM *, WT_SESSION_IMPL *);$/;"	m	struct:__wt_bm
include/tags:confchk_wiredtiger_open_block_cache_subconfigs	../config/config_def.c	/^static const WT_CONFIG_CHECK confchk_wiredtiger_open_block_cache_subconfigs[] = {$/;"	v	file:
include/tags:conn_close_blocked_lsm	../include/stat.h	/^    int64_t conn_close_blocked_lsm;$/;"	m	struct:__wt_connection_stats
include/tags:corrupt	../include/block.h	/^    int (*corrupt)(WT_BM *, WT_SESSION_IMPL *, const uint8_t *, size_t);$/;"	m	struct:__wt_bm
include/tags:created_during_backup	../include/block.h	/^    bool created_during_backup; \/* Created during incremental backup *\/$/;"	m	struct:__wt_block
include/tags:data	../include/block_cache.h	/^    void *data;$/;"	m	struct:__wt_blkcache_item
include/tags:data_size	../include/block_cache.h	/^    uint32_t data_size;$/;"	m	struct:__wt_blkcache_item
include/tags:depth	../include/block.h	/^    uint8_t depth; \/* Skip list depth *\/$/;"	m	struct:__wt_ext
include/tags:depth	../include/block.h	/^    uint8_t depth; \/* Skip list depth *\/$/;"	m	struct:__wt_size
include/tags:dhandle_lock_blocked	../include/stat.h	/^    int64_t dhandle_lock_blocked;$/;"	m	struct:__wt_connection_stats
include/tags:discard	../include/block.h	/^    WT_EXTLIST discard; \/* Extents discarded *\/$/;"	m	struct:__wt_block_ckpt
include/tags:disk_size	../include/block.h	/^    uint32_t disk_size; \/* 00-03: on-disk page size *\/$/;"	m	struct:__wt_block_header
include/tags:dump_blocks	../btree/bt_vrfy.c	/^    bool dump_blocks;$/;"	m	struct:__anon9	file:
include/tags:entries	../include/block.h	/^    uint32_t entries; \/* Entry count *\/$/;"	m	struct:__wt_extlist
include/tags:estimated_file_size	../include/block_cache.h	/^    size_t estimated_file_size;        \/* Estimated size of all files used by the workload. *\/$/;"	m	struct:__wt_blkcache
include/tags:evict_aggressive	../include/block_cache.h	/^    int32_t evict_aggressive;       \/* Seconds an unused block stays in the cache *\/$/;"	m	struct:__wt_blkcache
include/tags:evict_thread_tid	../include/block_cache.h	/^    wt_thread_t evict_thread_tid;$/;"	m	struct:__wt_blkcache
include/tags:ext_cache	../block/block_session.c	/^    WT_EXT *ext_cache;   \/* List of WT_EXT handles *\/$/;"	m	struct:__anon8	file:
include/tags:ext_cache_cnt	../block/block_session.c	/^    u_int ext_cache_cnt; \/* Count *\/$/;"	m	struct:__anon8	file:
include/tags:extend_len	../include/block.h	/^    wt_off_t extend_len;  \/* File extend chunk size *\/$/;"	m	struct:__wt_block
include/tags:extend_size	../include/block.h	/^    wt_off_t extend_size; \/* File extended size *\/$/;"	m	struct:__wt_block
include/tags:fh	../include/block.h	/^    WT_FH *fh;            \/* Backing file handle *\/$/;"	m	struct:__wt_block
include/tags:fid	../include/block_cache.h	/^    uint32_t fid;      \/* File ID *\/$/;"	m	struct:__wt_blkcache_item
include/tags:file_size	../block/block_ckpt_scan.c	/^    uint64_t file_size;$/;"	m	struct:saved_block_info	file:
include/tags:file_size	../include/block.h	/^    wt_off_t file_size; \/* Checkpoint file size *\/$/;"	m	struct:__wt_block_ckpt
include/tags:final_ckpt	../include/block.h	/^    WT_CKPT *final_ckpt; \/* Final live checkpoint write *\/$/;"	m	struct:__wt_block
include/tags:flags	../include/block.h	/^    uint8_t flags;               \/* 08: flags *\/$/;"	m	struct:__wt_block_header
include/tags:flags	../include/meta.h	/^    uint32_t flags;$/;"	m	struct:__wt_block_mods
include/tags:fragckpt	../include/block.h	/^    uint8_t *fragckpt;       \/* Per-checkpoint frag tracking list *\/$/;"	m	struct:__wt_block
include/tags:fragfile	../include/block.h	/^    uint8_t *fragfile;       \/* Per-file frag tracking list *\/$/;"	m	struct:__wt_block
include/tags:frags	../include/block.h	/^    uint64_t frags;          \/* Maximum frags in the file *\/$/;"	m	struct:__wt_block
include/tags:free	../include/block.h	/^    int (*free)(WT_BM *, WT_SESSION_IMPL *, const uint8_t *, size_t);$/;"	m	struct:__wt_bm
include/tags:freq_rec_counter	../include/block_cache.h	/^    int32_t freq_rec_counter;$/;"	m	struct:__wt_blkcache_item
include/tags:full_target	../include/block_cache.h	/^    uint64_t full_target; \/* Number of bytes in the block cache that triggers eviction *\/$/;"	m	struct:__wt_blkcache
include/tags:granularity	../include/meta.h	/^    uint64_t granularity;$/;"	m	struct:__wt_block_mods
include/tags:hash_locks	../include/block_cache.h	/^    WT_SPINLOCK *hash_locks;$/;"	m	struct:__wt_blkcache
include/tags:hash_size	../include/block_cache.h	/^    u_int hash_size;     \/* Number of block cache hash buckets *\/$/;"	m	struct:__wt_blkcache
include/tags:id_str	../include/meta.h	/^    const char *id_str;$/;"	m	struct:__wt_block_mods
include/tags:inserts	../include/block_cache.h	/^    uint64_t inserts;$/;"	m	struct:__wt_blkcache
include/tags:is_live	../include/block.h	/^    bool is_live; \/* The live system *\/$/;"	m	struct:__wt_bm
include/tags:is_mapped	../include/block.h	/^    bool (*is_mapped)(WT_BM *, WT_SESSION_IMPL *);$/;"	m	struct:__wt_bm
include/tags:last	../include/block.h	/^    WT_EXT *last; \/* Cached last element *\/$/;"	m	struct:__wt_extlist
include/tags:linked	../include/block.h	/^    bool linked;$/;"	m	struct:__wt_block
include/tags:list_init_block	../utilities/util_list.c	/^list_init_block(WT_SESSION *session, const char *key, WT_BLOCK *block)$/;"	f	file:
include/tags:live	../include/block.h	/^    WT_BLOCK_CKPT live;    \/* Live checkpoint *\/  \/\/__wt_block.live$/;"	m	struct:__wt_block
include/tags:live_lock	../include/block.h	/^    WT_SPINLOCK live_lock; \/* Live checkpoint lock *\/$/;"	m	struct:__wt_block
include/tags:live_open	../include/block.h	/^    bool live_open;        \/* Live system is open *\/$/;"	m	struct:__wt_block
include/tags:lookups	../include/block_cache.h	/^    uint64_t lookups;$/;"	m	struct:__wt_blkcache
include/tags:magic	../include/block.h	/^    uint32_t magic; \/* 00-03: Magic number *\/$/;"	m	struct:__wt_block_desc
include/tags:majorv	../include/block.h	/^    uint16_t majorv; \/* 04-05: Major version *\/$/;"	m	struct:__wt_block_desc
include/tags:map	../include/block.h	/^    void *map; \/* Mapped region *\/$/;"	m	struct:__wt_bm
include/tags:map_discard	../include/block.h	/^    int (*map_discard)(WT_BM *, WT_SESSION_IMPL *, void *, size_t);$/;"	m	struct:__wt_bm
include/tags:maplen	../include/block.h	/^    size_t maplen;$/;"	m	struct:__wt_bm
include/tags:mapped_cookie	../include/block.h	/^    void *mapped_cookie;$/;"	m	struct:__wt_bm
include/tags:max_bytes	../include/block_cache.h	/^    uint64_t max_bytes;  \/* Block cache size *\/$/;"	m	struct:__wt_blkcache
include/tags:metadata	../block/block_ckpt_scan.c	/^    char *metadata;$/;"	m	struct:saved_block_info	file:
include/tags:min_num_references	../include/block_cache.h	/^    uint32_t min_num_references; \/* The per-block number of references triggering eviction. *\/$/;"	m	struct:__wt_blkcache
include/tags:minorv	../include/block.h	/^    uint16_t minorv; \/* 06-07: Minor version *\/$/;"	m	struct:__wt_block_desc
include/tags:multi	../include/btmem.h	/^            WT_MULTI *multi;        \/* Multiple replacement blocks *\/$/;"	m	struct:__wt_page_modify::__anon50::__anon52
include/tags:multi_entries	../include/btmem.h	/^            uint32_t multi_entries; \/* Multiple blocks element count *\/$/;"	m	struct:__wt_page_modify::__anon50::__anon52
include/tags:name	../include/block.h	/^    char *name; \/* Name *\/$/;"	m	struct:__wt_extlist
include/tags:name	../include/block.h	/^    const char *name;  \/* Name *\/$/;"	m	struct:__wt_block
include/tags:nbits	../include/meta.h	/^    uint64_t nbits; \/* Number of bits in bitstring *\/$/;"	m	struct:__wt_block_mods
include/tags:next	../include/block.h	/^    WT_EXT *next[0]; \/* Offset, size skiplists *\/$/;"	m	struct:__wt_ext
include/tags:next	../include/block.h	/^    WT_SIZE *next[WT_SKIP_MAXDEPTH]; \/* Size skiplist *\/$/;"	m	struct:__wt_size
include/tags:num_references	../include/block_cache.h	/^    uint32_t num_references;$/;"	m	struct:__wt_blkcache_item
include/tags:nvram_device_path	../include/block_cache.h	/^    char *nvram_device_path; \/* The absolute path of the file system on NVRAM device *\/$/;"	m	struct:__wt_blkcache
include/tags:objectid	../include/block.h	/^    uint32_t objectid; \/* Object id *\/$/;"	m	struct:__wt_block
include/tags:objectid	../include/block.h	/^    uint32_t objectid; \/* Written object ID *\/$/;"	m	struct:__wt_extlist
include/tags:off	../include/block.h	/^    WT_EXT *off[WT_SKIP_MAXDEPTH]; \/* Per-size offset skiplist *\/$/;"	m	struct:__wt_size
include/tags:off	../include/block.h	/^    WT_EXT *off[WT_SKIP_MAXDEPTH]; \/* Size\/offset skiplists *\/$/;"	m	struct:__wt_extlist
include/tags:off	../include/block.h	/^    wt_off_t off;  \/* Extent's file offset *\/$/;"	m	struct:__wt_ext
include/tags:offset	../block/block_ckpt_scan.c	/^    wt_off_t offset;$/;"	m	struct:saved_block_info	file:
include/tags:offset	../include/block.h	/^    wt_off_t offset;   \/* Written extent offset *\/$/;"	m	struct:__wt_extlist
include/tags:offset	../include/meta.h	/^    uint64_t offset; \/* Zero bit offset for bitstring *\/$/;"	m	struct:__wt_block_mods
include/tags:os_cache	../include/block.h	/^    size_t os_cache;     \/* System buffer cache flush max *\/$/;"	m	struct:__wt_block
include/tags:os_cache_dirty_max	../include/block.h	/^    size_t os_cache_dirty_max;$/;"	m	struct:__wt_block
include/tags:os_cache_max	../include/block.h	/^    size_t os_cache_max;$/;"	m	struct:__wt_block
include/tags:overhead_pct	../include/block_cache.h	/^    u_int overhead_pct;   \/* Overhead percentage that suppresses population and eviction *\/$/;"	m	struct:__wt_blkcache
include/tags:page_busy_blocked	../include/stat.h	/^    int64_t page_busy_blocked;$/;"	m	struct:__wt_connection_stats
include/tags:page_del_rollback_blocked	../include/stat.h	/^    int64_t page_del_rollback_blocked;$/;"	m	struct:__wt_connection_stats
include/tags:page_forcible_evict_blocked	../include/stat.h	/^    int64_t page_forcible_evict_blocked;$/;"	m	struct:__wt_connection_stats
include/tags:page_index_slot_ref_blocked	../include/stat.h	/^    int64_t page_index_slot_ref_blocked;$/;"	m	struct:__wt_connection_stats
include/tags:page_locked_blocked	../include/stat.h	/^    int64_t page_locked_blocked;$/;"	m	struct:__wt_connection_stats
include/tags:page_read_blocked	../include/stat.h	/^    int64_t page_read_blocked;$/;"	m	struct:__wt_connection_stats
include/tags:percent_file_in_os_cache	../include/block_cache.h	/^    u_int percent_file_in_os_cache;$/;"	m	struct:__wt_blkcache
include/tags:pmem_kind	../include/block_cache.h	/^    struct memkind *pmem_kind; \/* NVRAM connection *\/$/;"	m	struct:__wt_blkcache	typeref:struct:__wt_blkcache::memkind
include/tags:prepared_transition_blocked_page	../include/stat.h	/^    int64_t prepared_transition_blocked_page;$/;"	m	struct:__wt_connection_stats
include/tags:print_extent_list	../block/block_ext.c	/^print_extent_list(const char *name, const char* filename, WT_EXTLIST *el)$/;"	f	file:
include/tags:print_extent_list_not_printlast	../block/block_ext.c	/^print_extent_list_not_printlast(const char *name, const char* filename, WT_EXTLIST *el)$/;"	f	file:
include/tags:read	../include/block.h	/^    int (*read)(WT_BM *, WT_SESSION_IMPL *, WT_ITEM *, const uint8_t *, size_t);$/;"	m	struct:__wt_bm
include/tags:rec_multiblock_internal	../include/stat.h	/^    int64_t rec_multiblock_internal;$/;"	m	struct:__wt_dsrc_stats
include/tags:rec_multiblock_leaf	../include/stat.h	/^    int64_t rec_multiblock_leaf;$/;"	m	struct:__wt_dsrc_stats
include/tags:rec_multiblock_max	../include/btree.h	/^    u_int rec_multiblock_max; \/* Maximum blocks written for a page *\/$/;"	m	struct:__wt_btree
include/tags:rec_multiblock_max	../include/stat.h	/^    int64_t rec_multiblock_max;$/;"	m	struct:__wt_dsrc_stats
include/tags:ref	../include/block.h	/^    uint32_t ref;      \/* References *\/$/;"	m	struct:__wt_block
include/tags:ref_count	../include/block_cache.h	/^    uint32_t ref_count; \/* References *\/$/;"	m	struct:__wt_blkcache_item
include/tags:refs_since_filesize_estimated	../include/block_cache.h	/^    int refs_since_filesize_estimated; \/* Counter for recalculating the aggregate file size *\/$/;"	m	struct:__wt_blkcache
include/tags:related	../include/block.h	/^    WT_BLOCK **related;       \/* Related objects *\/$/;"	m	struct:__wt_block
include/tags:related_allocated	../include/block.h	/^    size_t related_allocated; \/* Size of related object array *\/$/;"	m	struct:__wt_block
include/tags:related_next	../include/block.h	/^    u_int related_next;       \/* Next open slot *\/$/;"	m	struct:__wt_block
include/tags:removals	../include/block_cache.h	/^    uint64_t removals;$/;"	m	struct:__wt_blkcache
include/tags:root_checksum	../include/block.h	/^    uint32_t root_checksum, root_size;$/;"	m	struct:__wt_block_ckpt
include/tags:root_objectid	../include/block.h	/^    uint32_t root_objectid;$/;"	m	struct:__wt_block_ckpt
include/tags:root_offset	../include/block.h	/^    wt_off_t root_offset; \/* The root *\/$/;"	m	struct:__wt_block_ckpt
include/tags:root_size	../include/block.h	/^    uint32_t root_checksum, root_size;$/;"	m	struct:__wt_block_ckpt
include/tags:salvage_end	../include/block.h	/^    int (*salvage_end)(WT_BM *, WT_SESSION_IMPL *);$/;"	m	struct:__wt_bm
include/tags:salvage_next	../include/block.h	/^    int (*salvage_next)(WT_BM *, WT_SESSION_IMPL *, uint8_t *, size_t *, bool *);$/;"	m	struct:__wt_bm
include/tags:salvage_start	../include/block.h	/^    int (*salvage_start)(WT_BM *, WT_SESSION_IMPL *);$/;"	m	struct:__wt_bm
include/tags:salvage_valid	../include/block.h	/^    int (*salvage_valid)(WT_BM *, WT_SESSION_IMPL *, uint8_t *, size_t, bool);$/;"	m	struct:__wt_bm
include/tags:saved_block_info	../block/block_ckpt_scan.c	/^struct saved_block_info {$/;"	s	file:
include/tags:size	../block/block_ckpt_scan.c	/^    uint32_t size;$/;"	m	struct:saved_block_info	file:
include/tags:size	../include/block.h	/^    int (*size)(WT_BM *, WT_SESSION_IMPL *, wt_off_t *);$/;"	m	struct:__wt_bm
include/tags:size	../include/block.h	/^    uint32_t size;     \/* Written extent size *\/$/;"	m	struct:__wt_extlist
include/tags:size	../include/block.h	/^    wt_off_t size;        \/* File size *\/$/;"	m	struct:__wt_block
include/tags:size	../include/block.h	/^    wt_off_t size; \/* Extent's Size *\/$/;"	m	struct:__wt_ext
include/tags:size	../include/block.h	/^    wt_off_t size; \/* Size *\/$/;"	m	struct:__wt_size
include/tags:slvg_off	../include/block.h	/^    wt_off_t slvg_off; \/* Salvage file offset *\/$/;"	m	struct:__wt_block
include/tags:stat	../include/block.h	/^    int (*stat)(WT_BM *, WT_SESSION_IMPL *, WT_DSRC_STATS *stats);$/;"	m	struct:__wt_bm
include/tags:switch_object	../include/block.h	/^    int (*switch_object)(WT_BM *, WT_SESSION_IMPL *, uint32_t);$/;"	m	struct:__wt_bm
include/tags:sync	../include/block.h	/^    int (*sync)(WT_BM *, WT_SESSION_IMPL *, bool);$/;"	m	struct:__wt_bm
include/tags:system_ram	../include/block_cache.h	/^    uint64_t system_ram; \/* Configured size of system RAM *\/$/;"	m	struct:__wt_blkcache
include/tags:sz	../include/block.h	/^    WT_SIZE *sz[WT_SKIP_MAXDEPTH];$/;"	m	struct:__wt_extlist
include/tags:sz_cache	../block/block_session.c	/^    WT_SIZE *sz_cache;  \/* List of WT_SIZE handles *\/$/;"	m	struct:__anon8	file:
include/tags:sz_cache_cnt	../block/block_session.c	/^    u_int sz_cache_cnt; \/* Count *\/$/;"	m	struct:__anon8	file:
include/tags:track_size	../include/block.h	/^    bool track_size; \/* Maintain per-size skiplist *\/$/;"	m	struct:__wt_extlist
include/tags:txn_release_blocked	../include/stat.h	/^    int64_t txn_release_blocked;$/;"	m	struct:__wt_connection_stats
include/tags:type	../include/block_cache.h	/^    u_int type;          \/* Type of block cache (NVRAM or DRAM) *\/$/;"	m	struct:__wt_blkcache
include/tags:unused	../include/block.h	/^    uint32_t unused; \/* 12-15: Padding *\/$/;"	m	struct:__wt_block_desc
include/tags:unused	../include/block.h	/^    uint8_t unused[3]; \/* 09-11: unused padding *\/$/;"	m	struct:__wt_block_header
include/tags:verify	../include/block.h	/^    bool verify;             \/* If performing verification *\/$/;"	m	struct:__wt_block
include/tags:verify_addr	../include/block.h	/^    int (*verify_addr)(WT_BM *, WT_SESSION_IMPL *, const uint8_t *, size_t);$/;"	m	struct:__wt_bm
include/tags:verify_alloc	../include/block.h	/^    WT_EXTLIST verify_alloc; \/* Verification allocation list *\/$/;"	m	struct:__wt_block
include/tags:verify_end	../include/block.h	/^    int (*verify_end)(WT_BM *, WT_SESSION_IMPL *);$/;"	m	struct:__wt_bm
include/tags:verify_layout	../include/block.h	/^    bool verify_layout;      \/* Print out file layout information *\/$/;"	m	struct:__wt_block
include/tags:verify_size	../include/block.h	/^    wt_off_t verify_size;    \/* Checkpoint's file size *\/$/;"	m	struct:__wt_block
include/tags:verify_start	../include/block.h	/^    int (*verify_start)(WT_BM *, WT_SESSION_IMPL *, WT_CKPT *, const char *[]);$/;"	m	struct:__wt_bm
include/tags:verify_strict	../include/block.h	/^    bool verify_strict;      \/* Fail hard on any error *\/$/;"	m	struct:__wt_block
include/tags:version	../include/block.h	/^    uint8_t version; \/* Version *\/$/;"	m	struct:__wt_block_ckpt
include/tags:write	../include/block.h	/^    int (*write)(WT_BM *, WT_SESSION_IMPL *, WT_ITEM *, uint8_t *, size_t *, bool, bool);$/;"	m	struct:__wt_bm
include/tags:write_gen	../block/block_ckpt_scan.c	/^    uint64_t write_gen;$/;"	m	struct:saved_block_info	file:
include/tags:write_size	../include/block.h	/^    int (*write_size)(WT_BM *, WT_SESSION_IMPL *, size_t *);$/;"	m	struct:__wt_bm
include/block.h: * WiredTiger's block manager interface.
include/block.h: * The file's description is written into the first block of the file, which means we can use an
include/block.h: * The block manager maintains three per-checkpoint extent lists:
include/block.h: Internally, the block manager uses a data structure called an extent list or a WT_EXTLIST to track file usage.
include/block.h://__wt_block_ckpt的alloc avail discard为该类型
include/block.h://__wt_block_alloc中如果需要从avail中获取指定size的ext, 有了size跳跃表，可以方便快速查找指定长度可用的ext
include/block.h:    //赋值见__wt_block_extlist_init
include/block.h:    //跳表中所有elem数据字节数总和，参考__block_append  __block_ext_insert中增加extlist中所有ext保护的数据总数，
include/block.h:    //__block_off_remove减少extlist删除的ext数据长度
include/block.h:    //__block_off_insert->__block_ext_insert和__block_append中分配ext空间向跳跃表中添加elem,计数自增
include/block.h:    //赋值参考__wt_block_extlist_write，也就是跳表持久化到磁盘的核心元数据信息
include/block.h:    //重启的时候通过checkpoint元数据从__wt_block_ckpt_unpack加载起来对应跳表元数据
include/block.h:    //WT_BLOCK_CKPT.avail或者WT_BLOCK_CKPT.ckpt_avail才会在__wt_block_extlist_init中设置el->track_size为true
include/block.h:    //__block_append
include/block.h:    //__block_ext_insert添加ext到跳表中 参考__block_ext_insert __block_off_remove
include/block.h:    //只有在track_size为true的时候才生效__block_ext_insert
include/block.h:    //使用两个跳表的优势是，先找size跳表，在找off跳表会更快, 参考__block_ext_insert __block_off_remove
include/block.h://__block_ext_prealloc中分配空间, 成员赋值参考__block_append
include/block.h://管理reconcile拆分后的多个chunk磁盘数据，可以由一个ext管理，也可能你由多个ext管理，参考__block_append
include/block.h:    //参考__block_ext_insert
include/block.h: *	Encapsulation of a block size skiplist entry.
include/block.h: */ //__wt_extlist.sz成员为该类型, 参考__block_ext_insert
include/block.h:    //链接相同size，但是off起始地址不同的ext对应的跳表，使用两个跳表的优势是，先找size跳表，在找off跳表会更快, 参考__block_ext_insert
include/block.h: *	Walk a block manager skiplist.
include/block.h: *	Walk a block manager skiplist where the WT_EXT.next entries are offset
include/block.h: * file version should the default block manager checkpoint format change.
include/block.h: * There are two versions of the extent list blocks: the original, and a second version where
include/block.h://官方文档参考https://github.com/wiredtiger/wiredtiger/wiki/Block-Manager-Overview#source-files-in-block-manager
include/block.h://__wt_block.live为该类型
include/block.h:struct __wt_block_ckpt {
include/block.h:    //重启的时候从__wt_block_checkpoint_load加载起来, root元数据来源见__wt_rec_row_int
include/block.h:The avail extent list also maintains an extra skiplist sorted by the extent size to aid with allocating new blocks.
include/block.h:    //重启的时候通过checkpoint元数据从__wt_block_ckpt_unpack加载起来对应跳表元数据
include/block.h:    WT_EXTLIST alloc;   /* Extents allocated */ //__wt_block_alloc中分配ext空间，添加到alloc跳跃表中
include/block.h:    //从alloc跳跃表中被删除的offset对应的ext重新添加到avail中，代表的实际上就是磁盘碎片，也就是可重用的空间，参考__wt_block_off_free
include/block.h:    //__wt_block_alloc中如果需要从avail中获取指定size的ext, 有了size跳跃表，可以方便快速查找指定长度可用的ext
include/block.h:    //从alloc跳跃表中删除某个范围的ext，如果alloc跳跃表中没找到，则这个要删除范围对应的ext添加到discard跳跃表中，参考__wt_block_off_free
include/block.h:    //赋值参考__ckpt_update， 也就是block->size，也就是做checkpoint时候的文件大小
include/block.h:    //重启的时候从checkpoint元数据中获取，赋值见__block_ckpt_unpack
include/block.h:    //重启的时候从checkpoint元数据中获取，赋值见__block_ckpt_unpack
include/block.h:    //分配空间__ckpt_proces, 赋值见__ckpt_extlist_fblocks
include/block.h:     * Checkpoint archive: the block manager may potentially free a lot of memory from the
include/block.h:    //__bm_block_header
include/block.h:    u_int (*block_header)(WT_BM *);
include/block.h:    //__wt_block_open
include/block.h:    WT_BLOCK *block; /* Underlying file */
include/block.h:     * There's only a single block manager handle that can be written, all others are checkpoints.
include/block.h://分配空间和赋值见__wt_block_open， btree->bm  __wt_bm.block为该类型
include/block.h:struct __wt_block {
include/block.h:    //__wt_block_open中赋值
include/block.h://   TAILQ_ENTRY(__wt_block) q;     /* Linked list of handles */
include/block.h://   TAILQ_ENTRY(__wt_block) hashq; /* Hashed list of handles */
include/block.h:    //代表当前已经写入到文件末尾位置，也就是文件大小, 没写入一块数据就自增，参考__block_extend
include/block.h:    //file_extend配置，默认为0，所以extend_size也就是是当前block size
include/block.h:    //https://source.wiredtiger.com/develop/arch-block.html
include/block.h:    //默认为best, block_allocation配置，也就是默认为0
include/block.h:    u_int block_header; /* Header length */
include/block.h:    WT_BLOCK_CKPT live;    /* Live checkpoint */  //__wt_block.live
include/block.h:        //__wt_block_checkpoint_start
include/block.h:    //__wt_block_verify_start strict配置项，默认true
include/block.h:    //也就是有多少个block->allocsize长度大小
include/block.h:   TAILQ_ENTRY(__wt_block) q;     /* Linked list of handles */
include/block.h:   TAILQ_ENTRY(__wt_block) hashq; /* Hashed list of handles */
include/block.h: The layout of a .wt file consists of a file description WT_BLOCK_DESC which always occupies the first block, followed by a
include/block.h:  a magic number, and a checksum of the block contents. This information is used to verify that the file is a legitimate WiredTiger
include/block.h:struct __wt_block_desc {
include/block.h:    uint32_t checksum; /* 08-11: Description block checksum */
include/block.h: * hasn't inserted padding (padding won't cause failure, we reserve the first allocation-size block
include/block.h: * __wt_block_desc_byteswap --
include/block.h: *     Handle big- and little-endian transformation of a description block.
include/block.h:__wt_block_desc_byteswap(WT_BLOCK_DESC *desc)
include/block.h: * block-manager specific structure: WT_BLOCK_HEADER is WiredTiger's default.
include/block.h: The page header is followed by a "block header". In WiredTiger each page is a block, and it is possible
include/block.h:   to plug in different "block managers" that manage the transition of pages to and from disk.
include/block.h: 参考https://source.wiredtiger.com/develop/arch-block.html
include/block.h://WT_BLOCK_HEADER(__wt_block_header)赋值在写磁盘完成后，在__block_write_off赋值,对应内存偏移见WT_PAGE_HEADER_BYTE_SIZE
include/block.h://如果配置了压缩，则__wt_page_header记录的是压缩前的数据信息,__wt_block_header记录的是压缩后的数据信息
include/block.h:struct __wt_block_header {
include/block.h:    //__block_write_off中赋值
include/block.h: * __wt_block_header_byteswap_copy --
include/block.h: *     Handle big- and little-endian transformation of a header block, copying from a source to a
include/block.h:__wt_block_header_byteswap_copy(WT_BLOCK_HEADER *from, WT_BLOCK_HEADER *to)
include/block.h: * __wt_block_header_byteswap --
include/block.h: *     Handle big- and little-endian transformation of a header block.
include/block.h:__wt_block_header_byteswap(WT_BLOCK_HEADER *blk)
include/block.h:    __wt_block_header_byteswap_copy(blk, blk);
include/block.h: *	The first usable data byte on the block (past the combined headers).
include/block.h: * We don't compress or encrypt the block's WT_PAGE_HEADER or WT_BLOCK_HEADER structures because we
include/block.h: * on-disk size during salvage to figure out where the blocks are, and we use the WT_PAGE_HEADER
include/block.h: * __wt_block_header --
include/block.h: *     Return the size of the block-specific header.
include/block.h:__wt_block_header(WT_BLOCK *block)
include/block.h:    WT_UNUSED(block);
include/btree.h: * it could be larger, specifically, the underlying default block manager can support 4GB (2^32).
include/btree.h: * constrained by what an underlying block manager can actually write. (For example, in the default
include/btree.h: * block manager, writing an overflow item includes the underlying block's page header and block
include/btree.h: * store large key/value items in the tree trigger an immediate check to the block manager, to make
include/btree.h:    CKSUM_UNCOMPRESSED = 3, /* Uncompressed blocks only */
include/btree.h:    CKSUM_UNENCRYPTED = 4   /* Unencrypted blocks only */
include/btree.h:    //block_compressor=snappy配置，默认snappy
include/btree.h:    u_int rec_multiblock_max; /* Maximum blocks written for a page */
include/btree.h:    u_int block_header; /* WT_PAGE_HEADER_BYTE_SIZE */  //yang add todo xxxxx  备注长度错了，容易误解
include/btree_inline.h:     * and we're not blocking checkpoints (although we must block eviction as it might clear and
include/btree_inline.h:     * and we're not blocking checkpoints (although we must block eviction as it might clear and
include/btree_inline.h:     * and we're not blocking checkpoints (although we must block eviction as it might clear and
include/btree_inline.h: * __wt_btree_block_free --
include/btree_inline.h: *     Helper function to free a block from the current tree.
include/btree_inline.h:__wt_btree_block_free(WT_SESSION_IMPL *session, const uint8_t *addr, size_t addr_size)
include/btree_inline.h:    //通过ref->addr可以判断除该ref对应page是否罗盘了 __wt_ref_block_free
include/btree_inline.h: * __wt_ref_block_free --
include/btree_inline.h: *     Free the on-disk block for a reference and clear the address.
include/btree_inline.h:__wt_ref_block_free(WT_SESSION_IMPL *session, WT_REF *ref)
include/btree_inline.h:    WT_RET(__wt_btree_block_free(session, addr.addr, addr.size));
include/btree_inline.h:     * We can't split or evict multiblock row-store pages where the parent's key for the page is an
include/btree_inline.h:     * overflow item, because the split into the parent frees the backing blocks for no-longer-used
include/btree_inline.h:     * overflow keys, which will corrupt the checkpoint's block management. (This is only for
include/cache.h:#define WT_CACHE_EVICT_CLEAN_HARD 0x002u   /* Clean % blocking app threads */
include/cache.h:#define WT_CACHE_EVICT_DIRTY_HARD 0x010u   /* Dirty % blocking app threads */
include/cache.h:#define WT_CACHE_EVICT_UPDATES_HARD 0x100u /* Update % blocking app threads */
include/cell.h: * WT_CELL_ADDR_INT is an internal block location, WT_CELL_ADDR_LEAF is a leaf block location, and
include/cell.h: * WT_CELL_ADDR_LEAF_NO is a leaf block location where the page has no overflow items. (The goal is
include/cell_inline.h: *     blocks are removed; if there are still running transactions that might need to see the
include/connection.h: * Macros to ensure the block is inserted or removed from both the main queue and the hashed queue.
include/connection.h:#define WT_CONN_BLOCK_INSERT(conn, block, bucket)                    \
include/connection.h:        TAILQ_INSERT_HEAD(&(conn)->blockqh, block, q);               \
include/connection.h:        TAILQ_INSERT_HEAD(&(conn)->blockhash[bucket], block, hashq); \
include/connection.h:#define WT_CONN_BLOCK_REMOVE(conn, block, bucket)               \
include/connection.h:        TAILQ_REMOVE(&(conn)->blockqh, block, q);               \
include/connection.h:        TAILQ_REMOVE(&(conn)->blockhash[bucket], block, hashq); \
include/connection.h:    WT_SPINLOCK block_lock; /* Locked: block manager list */
include/connection.h:    TAILQ_HEAD(__wt_blockhash, __wt_block) * blockhash;
include/connection.h:    TAILQ_HEAD(__wt_block_qh, __wt_block) blockqh;
include/meta.h: * At the default granularity, this is enough for blocks in a 2G file.
include/meta.h:struct __wt_block_mods {
include/meta.h: * btree engine, and the block manager.
include/meta.h:    //赋值参考__wt_meta_block_metadata
include/meta.h:    char *block_metadata;   /* Block-stored metadata */
include/meta.h:    //转换后的字符串存储到block_checkpoint中，赋值参考__ckpt_update
include/meta.h:    char *block_checkpoint; /* Block-stored checkpoint */
include/meta.h:    WT_BLOCK_MODS backup_blocks[WT_BLKINCR_MAX];
include/meta.h:#define WT_CKPT_BLOCK_MODS 0x02u /* Return list of modified blocks */
include/misc_inline.h: *     consume enough CPU to block real work being done. The algorithm spins a few times, then
include/mutex.h: * are expected to block.
include/txn_inline.h:        WT_STAT_CONN_INCR(session, prepared_transition_blocked_page);
include/txn_inline.h:             * We may have raced with checkpoint freeing the overflow blocks. Retry from start and
include/txn_inline.h: *     do it now. If we have to block for eviction, this is the best time to do it.
include/txn_inline.h: * __wt_txn_modify_block --
include/txn_inline.h:__wt_txn_modify_block(
include/txn_inline.h:              "__wt_txn_modify_block rolback snapshot_min=%" PRIu64 ", snapshot_max=%" PRIu64 ", snapshot_count=%" PRIu32,
include/txn_inline.h:        WT_RET(__wt_txn_modify_block(session, cbt, upd, prev_tsp));
include/block_cache.h: * WiredTiger's block cache. It is used to cache blocks identical to those that live on disk in a
include/block_cache.h:////block_cache.enabled默认值false，block_cache.enabled使能true后block_cache的其他配置才有效
include/block_cache.h:#define BLKCACHE_UNCONFIGURED 0 //默认type为该值，表示block_cache没启用
include/block_cache.h:/* How often we compute the total size of the files open in the block manager. */
include/block_cache.h:     * This counter is incremented every time a block is referenced and decremented every time the
include/block_cache.h:     * eviction thread sweeps through the cache. This counter will be low for blocks that have not
include/block_cache.h:     * been reused or for blocks that were reused in the past but lost their appeal. In this sense,
include/block_cache.h: *     Block cache metadata includes the hashtable of cached items, number of cached data blocks
include/block_cache.h: "block_cache=(blkcache_eviction_aggression=1800,"
include/block_cache.h://block_cache.enabled默认值false，block_cache.enabled使能true后block_cache的其他配置才有效
include/block_cache.h:    int32_t evict_aggressive;       /* Seconds an unused block stays in the cache */
include/block_cache.h:    bool cache_on_checkpoint; /* Don't cache blocks written by checkpoints */
include/block_cache.h:    bool cache_on_writes;     /* Cache blocks on writes */
include/block_cache.h:    uint64_t full_target; /* Number of bytes in the block cache that triggers eviction */
include/block_cache.h:     * OS filesystem buffer cache, which makes the use of this block cache unnecessary. Suppose we
include/block_cache.h:     * user gives us for the filesystem buffer cache, we consider this block cache unhelpful.
include/block_cache.h:     * declares there to be 300GB of OS filesystem buffer cache, then we will not use this block
include/block_cache.h:    u_int hash_size;     /* Number of block cache hash buckets */
include/block_cache.h:    //默认type为该值BLKCACHE_UNCONFIGURED，表示block_cache没启用
include/block_cache.h:    u_int type;          /* Type of block cache (NVRAM or DRAM) */
include/block_cache.h:    uint64_t bytes_used; /* Bytes in the block cache */
include/block_cache.h:    //block_cache.full_target配置,默认值为0
include/block_cache.h:    uint32_t min_num_references; /* The per-block number of references triggering eviction. */
include/block_cache.h:    /* Histograms keeping track of number of references to each block */
include/block_cache.h:    uint32_t cache_references_removed_blocks[BLKCACHE_HIST_BUCKETS];
include/block_cache.h:    uint32_t cache_references_evicted_blocks[BLKCACHE_HIST_BUCKETS];
lsm/lsm_cursor.c:     * indefinitely: if a chunk grows twice as large as the configured size, block until it can be
lsm/lsm_cursor.c:         * Drop the LSM tree lock while we do this: if the cache is full, we may block while closing
lsm/lsm_manager.c:            WT_STAT_CONN_INCR(session, conn_close_blocked_lsm);
lsm/lsm_merge.c:     * We're doing advisory reads to fault the new trees into cache. Don't block if the cache is
lsm/lsm_tree.c:         * this step so that we don't block any operations that require
lsm/lsm_work_unit.c:     * Enable eviction on the live chunk so it doesn't block the cache. Future reads should direct
meta/meta_track.c:        if ((ret = __wt_block_manager_drop(session, trk->a, false)) != 0)
meta/meta_track.c:        if ((ret = __wt_block_manager_drop_object(session, trk->bstorage, trk->a, false)) != 0)
meta/meta_ckpt.c: *     Load the block information from the config string.
meta/meta_ckpt.c:     * Load block lists. Ignore any that have an id string that is not known.
meta/meta_ckpt.c:         * We have a valid entry. Load the block information.
meta/meta_ckpt.c:        blk_mod = &ckpt->backup_blocks[i];
meta/meta_ckpt.c:        ret = __wt_config_subgets(session, &v, "blocks", &b);
meta/meta_ckpt.c:  //    ->__wt_blkcache_write->__bm_write->__wt_block_write
meta/meta_ckpt.c:  //__wt_block_checkpoint->__ckpt_process进行checkpoint相关元数据持久化
meta/meta_ckpt.c:  //__wt_meta_checkpoint获取checkpoint信息，然后__wt_block_checkpoint_load加载checkpoint相关元数据
meta/meta_ckpt.c://__wt_meta_checkpoint获取checkpoint信息，然后__wt_block_checkpoint_load加载checkpoint相关元数据
meta/meta_ckpt.c: * __wt_meta_block_metadata --
meta/meta_ckpt.c: *     Build a version of the file's metadata for the block manager to store.
meta/meta_ckpt.c:    "read_timestamp=none,write_timestamp=off),block_allocation=best,"
meta/meta_ckpt.c:    "block_compressor=,cache_resident=false,checkpoint=,"
meta/meta_ckpt.c://encryption=%.*s,block_metadata_encrypted=%s,block_metadata=[%.*s]几个配置保存到ckpt->block_metadata
meta/meta_ckpt.c:__wt_meta_block_metadata(WT_SESSION_IMPL *session, const char *config, WT_CKPT *ckpt)
meta/meta_ckpt.c:     * encrypted because it contains private data (for example, column names). We pass the block
meta/meta_ckpt.c:      "encryption=%.*s,block_metadata_encrypted=%s,block_metadata=[%.*s]", (int)cval.len, cval.str,
meta/meta_ckpt.c:    WT_ERR(__wt_strndup(session, b->data, b->size, &ckpt->block_metadata));
meta/meta_ckpt.c:    //yang test ...........__wt_meta_block_metadata........block_metadata:encryption=(keyid=,name=),block_metadata_encrypted=false,
meta/meta_ckpt.c:    //block_metadata=[access_pattern_hint=none,allocation_size=4KB,app_metadata=,assert=(commit_timestamp=none,durable_timestamp=none,
meta/meta_ckpt.c:    //read_timestamp=none,write_timestamp=off),block_allocation=best,block_compressor=none,cache_resident=false,checkpoint=,
meta/meta_ckpt.c:    //printf("yang test ...........__wt_meta_block_metadata........block_metadata:%s\r\n", ckpt->block_metadata);
meta/meta_ckpt.c: *     Make sure that this set of block mods reflects the current valid backup identifiers. If so,
meta/meta_ckpt.c:        blk_mod = &ckpt->backup_blocks[i];
meta/meta_ckpt.c:         * Check the state of our block list array compared to the global one. There are
meta/meta_ckpt.c:        /* Set up the block list to point to the current information. */
meta/meta_ckpt.c: *     Copy the block mods from a source checkpoint to the destination checkpoint.
meta/meta_ckpt.c:          session, src_ckpt->backup_blocks[i].id_str, &dst_ckpt->backup_blocks[i].id_str));
meta/meta_ckpt.c:        WT_RET(__wt_buf_set(session, &dst_ckpt->backup_blocks[i].bitstring,
meta/meta_ckpt.c:          src_ckpt->backup_blocks[i].bitstring.data, src_ckpt->backup_blocks[i].bitstring.size));
meta/meta_ckpt.c:        dst_ckpt->backup_blocks[i].nbits = src_ckpt->backup_blocks[i].nbits;
meta/meta_ckpt.c:        dst_ckpt->backup_blocks[i].offset = src_ckpt->backup_blocks[i].offset;
meta/meta_ckpt.c:        dst_ckpt->backup_blocks[i].granularity = src_ckpt->backup_blocks[i].granularity;
meta/meta_ckpt.c:        dst_ckpt->backup_blocks[i].flags = src_ckpt->backup_blocks[i].flags;
meta/meta_ckpt.c: *     Load the block mods for a given checkpoint and set up all the information to store. Load from
meta/meta_ckpt.c://从元数据或者配置文件中加载信息存储到ckpt->block_metadata
meta/meta_ckpt.c:     * Load most recent checkpoint backup blocks to this checkpoint, either from metadata or from a
meta/meta_ckpt.c:        //encryption=%.*s,block_metadata_encrypted=%s,block_metadata=[%.*s]几个配置保存到ckpt->block_metadata
meta/meta_ckpt.c:        WT_RET(__wt_meta_block_metadata(session, config, ckpt));
meta/meta_ckpt.c:        WT_RET(__wt_strndup(session, base_ckpt->block_metadata, strlen(base_ckpt->block_metadata),
meta/meta_ckpt.c:          &ckpt->block_metadata));
meta/meta_ckpt.c:     * checkpoint's modified blocks from the block manager.
meta/meta_ckpt.c:    WT_ASSERT(session, config != NULL || (slot != 0 && ckptbase[slot - 1].block_metadata != NULL));
meta/meta_ckpt.c:     * a new checkpoint), and the block manager (which actually creates the checkpoint). All of that
meta/meta_ckpt.c:    /* Either load block mods from the config, or from the previous checkpoint. */
meta/meta_ckpt.c:    WT_ASSERT(session, ckpt->block_metadata != NULL);
meta/meta_ckpt.c:    read_timestamp=none,write_timestamp=off),block_allocation=best,block_compressor=,cache_resident=false,checkpoint=,
meta/meta_ckpt.c:            WT_ERR(__wt_meta_block_metadata(session, config, ckpt));
meta/meta_ckpt.c: //__wt_meta_checkpoint->__ckpt_last->__ckpt_load获取checkpoint信息，然后__wt_block_checkpoint_load加载checkpoint相关元数据
meta/meta_ckpt.c: *     Add in any modification block string needed, including an empty one.
meta/meta_ckpt.c:    for (i = 0, blk = &ckpt->backup_blocks[0]; i < WT_BLKINCR_MAX; ++i, ++blk)
meta/meta_ckpt.c:     * If the existing block modifications are not valid, there is nothing to do.
meta/meta_ckpt.c:     * We have at least one valid modified block list.
meta/meta_ckpt.c:    for (i = 0, blk = &ckpt->backup_blocks[0]; i < WT_BLKINCR_MAX; ++i, ++blk) {
meta/meta_ckpt.c:          "%s,blocks=%.*s)",
meta/meta_ckpt.c:    /* Add backup block modifications for any added checkpoint. */
meta/meta_ckpt.c:    /* Add backup block modifications for any added checkpoint. */
meta/meta_ckpt.c:    __wt_free(session, ckpt->block_metadata);
meta/meta_ckpt.c:    __wt_free(session, ckpt->block_checkpoint);
meta/meta_ckpt.c:        blk_mod = &ckpt->backup_blocks[i];
meta/meta_table.c:     * metadata, or they may try to read blocks that may have been freed from a file. Metadata
meta/meta_turtle.c:        WT_ERR(__wt_block_manager_create(session, key, allocsize));
meta/meta_turtle.c:access_pattern_hint=none,allocation_size=4KB,app_metadata=,assert=(commit_timestamp=none,durable_timestamp=none,read_timestamp=none,write_timestamp=off),block_allocation=best,block_compressor=,cache_resident=false,checksum=on,collator=,columns=,dictionary=0,encryption=(keyid=,name=),format=btree,huffman_key=,huffman_value=,id=0,ignore_in_memory_cache_size=false,internal_item_max=0,internal_key_max=0,internal_key_truncate=true,internal_page_max=4KB,key_format=S,key_gap=10,leaf_item_max=0,leaf_key_max=0,leaf_page_max=32KB,leaf_value_max=0,log=(enabled=true),memory_page_image_max=0,memory_page_max=5MB,os_cache_dirty_max=0,os_cache_max=0,prefix_compression=false,prefix_compression_min=4,readonly=false,split_deepen_min_child=0,split_deepen_per_child=0,split_pct=90,tiered_object=false,tiered_storage=(auth_token=,bucket=,bucket_prefix=,cache_directory=,local_retention=300,name=,object_target_size=0),value_format=S,verbose=[],version=(major=2,minor=1),write_timestamp_usage=none,checkpoint=(WiredTigerCheckpoint.11=(addr="018481e44910462d8581e454c359c08681e4126649ce808080e25fc0cfc0",order=11,time=1691501853,size=8192,newest_start_durable_ts=0,oldest_start_ts=0,newest_txn=2,newest_stop_durable_ts=0,newest_stop_ts=-1,newest_stop_txn=-11,prepare=0,write_gen=27,run_write_gen=23)),checkpoint_backup_info=,checkpoint_lsn=(4294967295,2147483647)
os_common/os_fhandle.c:         * We set the false flag to indicate a non-blocking background fsync, but there is no
os_common/os_fhandle.c:         * guarantee that it doesn't block. If we wanted to detect if it is blocking, adding a clock
os_common/os_fhandle.c:     * For now logging is the only type and statistic. This needs updating if block manager decides
os_posix/os_map.c:        /* Read in 2MB blocks every 1MB of data. */
os_posix/os_fs.c: *     as being clean. So a read of the blocks that were just written will likely return something
os_posix/os_fs.c:    WT_STAT_CONN_INCRV(session, block_byte_read_syscall, len);
os_posix/os_fs.c:        WT_STAT_CONN_INCRV(session, block_byte_read_mmap, len);
os_posix/os_fs.c:    WT_STAT_CONN_INCRV(session, block_byte_write_syscall, len);
os_posix/os_fs.c:        WT_STAT_CONN_INCRV(session, block_byte_write_mmap, len);
os_posix/os_fs.c:            WT_STAT_CONN_INCRV(session, block_remap_file_write, 1);
os_posix/os_fs.c:O_SYNC: requires that any write operations block until all data and all metadata have been written to persistent storage.
os_posix/os_fs.c:    cause aread() call to block until the data (and maybe metadata) being read has been flushed to disk (if necessary). 
os_posix/os_fs.c: * used over a direct-access (DAX) file system. If a new block is created and then the file is
os_posix/os_fs.c: * memory-mapped and the client writes to that block via mmap directly into storage (via DAX),
os_posix/os_fs.c: * prior to data being written. Therefore, the block may be reallocated or lost upon crash.
os_posix/os_fs.c: *     writing a new block beyond the current file size, we always unmap the file and then re-map it
os_posix/os_fs.c: *     before allowing any reads or writes via mmap into the new block. If we sync the file upon
os_posix/os_fs.c:    WT_STAT_CONN_INCRV(session, block_remap_file_resize, 1);
os_win/os_mtx_cond.c:    /* Initialize the condition variable to permit self-blocking. */
reconcile/rec_col.c:         * have to discard it from the backing file, otherwise we'll leak blocks on the checkpoint.
reconcile/rec_col.c:         * The first time we find an overflow record we never used, discard the underlying blocks,
reconcile/rec_child.c:     * underlying disk blocks and don't write anything in the internal page.
reconcile/rec_child.c:        return (__wt_ref_block_free(session, ref));
reconcile/rec_child.c:     * Deal with underlying disk blocks.
reconcile/rec_child.c:     * Globally visible truncate, discard the leaf page to the block manager and no cell needs to be
reconcile/rec_child.c:    WT_RET(__wt_ref_block_free(session, ref));
reconcile/rec_child.c:        WT_STAT_CONN_INCR(session, child_modify_blocked_page);
reconcile/rec_row.c://    ->__wt_blkcache_write->__bm_write->__wt_block_write
reconcile/rec_row.c://__wt_block_checkpoint->__ckpt_process进行checkpoint相关元数据持久化
reconcile/rec_row.c://__wt_meta_checkpoint获取checkpoint信息，然后__wt_block_checkpoint_load加载checkpoint相关元数据
reconcile/rec_row.c:             * blocks. We have a copy to build the key (the key was instantiated when we read the
reconcile/rec_row.c://__wt_meta_checkpoint获取checkpoint信息，然后__wt_block_checkpoint_load加载checkpoint相关元数据
reconcile/rec_row.c:            /* The first time we find an overflow record, discard the underlying blocks. */
reconcile/rec_row.c:                 * backing blocks. Don't worry about reuse, reusing keys from a row-store page
reconcile/rec_row.c:         * If the key is an overflow key that hasn't been removed, use the original backing blocks.
reconcile/rec_row.c:             * If we copied address blocks from the page rather than building the actual key, we
reconcile/rec_track.c:     * Discard any overflow records that aren't in-use, freeing underlying blocks.
reconcile/rec_track.c:     * Discard any overflow records that were just added, freeing underlying blocks.
reconcile/rec_visibility.c:         * blocks.
reconcile/rec_visibility.c:        WT_STAT_CONN_DATA_INCR(session, cache_eviction_blocked_remove_hs_race_with_checkpoint);
reconcile/rec_visibility.c:        WT_STAT_CONN_DATA_INCR(session, cache_eviction_blocked_no_ts_checkpoint_race_2);
reconcile/rec_visibility.c:            WT_STAT_CONN_DATA_INCR(session, cache_eviction_blocked_no_ts_checkpoint_race_4);
reconcile/rec_visibility.c:            WT_STAT_CONN_DATA_INCR(session, cache_eviction_blocked_no_ts_checkpoint_race_1);
reconcile/rec_visibility.c:        WT_STAT_CONN_DATA_INCR(session, cache_eviction_blocked_no_ts_checkpoint_race_3);
reconcile/rec_visibility.c:     * on-page cell is being written. This is because the value's backing overflow blocks aren't
reconcile/rec_visibility.c:     * the checkpoint doesn't include the overflow blocks so they're removed and future readers of
reconcile/rec_write.c:    if (r->multi_next > btree->rec_multiblock_max)
reconcile/rec_write.c:        btree->rec_multiblock_max = r->multi_next;
reconcile/rec_write.c:     * When threads perform eviction, don't cache block manager structures (even across calls), we
reconcile/rec_write.c:         * Clean up the underlying block manager memory too: it's not reconciliation, but threads
reconcile/rec_write.c:         * discarding reconciliation structures want to clean up the block manager's structures as
reconcile/rec_write.c:        if (session->block_manager_cleanup != NULL) {
reconcile/rec_write.c:            WT_RET(session->block_manager_cleanup(session));
reconcile/rec_write.c://    ->__wt_blkcache_write->__bm_write->__wt_block_write
reconcile/rec_write.c:     * adding code to write blocks based on the list of blocks resulting from a multiblock
reconcile/rec_write.c:    case WT_PM_REC_MULTIBLOCK: /* Multiple blocks */
reconcile/rec_write.c:     * We maintain a list of pages written for the root in order to free the backing blocks the next
reconcile/rec_write.c: *     Write a block, with optional diagnostic checks.
reconcile/rec_write.c://    ->__wt_blkcache_write->__bm_write->__wt_block_write
reconcile/rec_write.c://buf数据内容 = 包括page header + block header + 实际数据
reconcile/rec_write.c:    //数据内容，包括page header + block header + 实际数据
reconcile/rec_write.c:        //这里没有加头部自动是因为写磁盘的时候会自动加上头部长度WT_BLOCK_HEADER_BYTE_SIZE，参考__wt_block_write_size
reconcile/rec_write.c:     * underlying block manager.
reconcile/rec_write.c:    //__bm_write_size  //block size = WT_PAGE_HEADER_SIZE + WT_BLOCK_HEADER_SIZE + 实际数据
reconcile/rec_write.c:    //跳过PAGE_HEADER和block header，也就是指向真实data
reconcile/rec_write.c:     * (and have to tell the underlying block manager so it creates and writes the additional
reconcile/rec_write.c:     * have to resolve information about the blocks we're expecting to free as part of the
reconcile/rec_write.c:     * previous block (probable for append-centric workloads). If there are skipped updates and we
reconcile/rec_write.c:     * The largest key on the last block must sort before the current key, so we'll either find a
reconcile/rec_write.c:    //获取block size = WT_PAGE_HEADER_SIZE + WT_BLOCK_HEADER_SIZE + 实际数据corrected_page_size
reconcile/rec_write.c: *     Move a saved WT_UPDATE list from the per-page cache to a specific block's list.
reconcile/rec_write.c: *     Check if we've saved updates that belong to this block, and move any to the per-block
reconcile/rec_write.c:  WT_SESSION_IMPL *session, WT_RECONCILE *r, WT_REC_CHUNK *chunk, WT_MULTI *multi, bool last_block)
reconcile/rec_write.c:     * Check if we've saved updates that belong to this block, and move any to the per-block
reconcile/rec_write.c:     * This code requires a key be filled in for the next block (or the last block flag be set, if
reconcile/rec_write.c:     * there's no next block).
reconcile/rec_write.c:     * The last block gets all remaining saved updates.
reconcile/rec_write.c:    if (last_block) {
reconcile/rec_write.c:     * Get the saved update's key and compare it with the block's key range. If the saved update
reconcile/rec_write.c:     * list belongs with the block we're about to write, move it to the per-block memory. Check only
reconcile/rec_write.c:     * to the first update that doesn't go with the block, they must be in sorted order.
reconcile/rec_write.c:         * If there are updates that weren't moved to the block, shuffle them to the beginning of
reconcile/rec_write.c:     * We increment the block's write generation so it's easy to identify newer versions of blocks
reconcile/rec_write.c:     * during salvage. (It's common in WiredTiger, at least for the default block manager, for
reconcile/rec_write.c:     * multiple blocks to be internally consistent with identical first and last keys, so we need a
reconcile/rec_write.c:     * way to know the most recent state of the block. We could check which leaf is referenced by a
reconcile/rec_write.c:// 2. btree->block_header空间置为0
reconcile/rec_write.c:    /* Clear the memory owned by the block manager. */
reconcile/rec_write.c:    //block_header的空间置为0
reconcile/rec_write.c:    memset(WT_BLOCK_HEADER_REF(dsk), 0, btree->block_header);
reconcile/rec_write.c: *     Check if a previously written block can be reused.
reconcile/rec_write.c://判断image数据是否可以复用已有的block，长度和内容sum值一样
reconcile/rec_write.c:  WT_SESSION_IMPL *session, WT_RECONCILE *r, WT_MULTI *multi, WT_ITEM *image, bool last_block)
reconcile/rec_write.c:     * Ignore the last block of any reconciliation. Pages are written in the same block order every
reconcile/rec_write.c:     * time, so the last block written for a page is unlikely to match any previously written block
reconcile/rec_write.c:     * or block written in the future, (absent a point-update earlier in the page which didn't
reconcile/rec_write.c:    if (last_block)
reconcile/rec_write.c:     * Quit if evicting with no previously written block to compare against. (In other words, if
reconcile/rec_write.c:     * Quit if evicting and a previous check failed, once there's a miss no future block will match.
reconcile/rec_write.c:    /* Calculate the checksum for this block. */
reconcile/rec_write.c:     * Don't check for a block match when writing a page for compaction, the whole idea is to move
reconcile/rec_write.c:     * those blocks. Check after calculating the checksum, there's a possibility the calculated
reconcile/rec_write.c:     * Pages are written in the same block order every time, only check the appropriate slot.
reconcile/rec_write.c:    bool last_block, 
reconcile/rec_write.c:         * Don't increase the pre-compressed size on the last block, the last block might be tiny.
reconcile/rec_write.c:        if (last_block || compressed_size > max - ten_percent)
reconcile/rec_write.c: *     Write a disk block out for the split helper functions.
reconcile/rec_write.c: //    ->__wt_blkcache_write->__bm_write->__wt_block_write
reconcile/rec_write.c:  bool last_block)
reconcile/rec_write.c:     * If reconciliation requires multiple blocks and checkpoint is running we'll eventually fail,
reconcile/rec_write.c:    if (!last_block && WT_BTREE_SYNCING(btree) && !WT_SESSION_BTREE_SYNC(session))
reconcile/rec_write.c:    /* Check if there are saved updates that might belong to this block. */
reconcile/rec_write.c:        WT_RET(__rec_split_write_supd(session, r, chunk, multi, last_block));
reconcile/rec_write.c:    if (last_block && r->multi_next == 1 && __rec_is_checkpoint(session, r)) {
reconcile/rec_write.c:          session, r->supd_next == 0, "Attempting to write final block but further updates found");
reconcile/rec_write.c:     * If we wrote this block before, re-use it. Prefer a checksum of the compressed image. It's an
reconcile/rec_write.c:    //判断image数据是否可以复用已有的block，数据都是一样的，则直接跳过后面的write操作
reconcile/rec_write.c:          compressed_image == NULL ? &chunk->image : compressed_image, last_block))
reconcile/rec_write.c:          session, btree->maxintlpage, compressed_size, last_block, &btree->maxintlpage_precomp);
reconcile/rec_write.c:          session, btree->maxleafpage, compressed_size, last_block, &btree->maxleafpage_precomp);
reconcile/rec_write.c:     * block space used in the last reconciliation that is not being reused for this reconciliation.
reconcile/rec_write.c:         * If the page was re-written free the backing disk blocks used in the previous write
reconcile/rec_write.c:         * (unless the blocks were reused in this write). The page may instead have been a disk
reconcile/rec_write.c:         * wrong a few times, so use the existence of an address to confirm backing blocks we care
reconcile/rec_write.c:            WT_RET(__wt_btree_block_free(session, multi->addr.addr, multi->addr.size));
reconcile/rec_write.c:     * This routine would be trivial, and only walk a single page freeing any blocks written to
reconcile/rec_write.c:     * entirely consistent at that point (the underlying block manager is presumably going to do
reconcile/rec_write.c:     * some action to resolve the list of allocated/free/whatever blocks that are associated with
reconcile/rec_write.c:             * address blocks (if any).  The "if any" is for empty trees
reconcile/rec_write.c:        WT_RET(__wt_ref_block_free(session, ref));
reconcile/rec_write.c:    case WT_PM_REC_MULTIBLOCK: /* Multiple blocks */
reconcile/rec_write.c:                                * Discard the multiple replacement blocks.
reconcile/rec_write.c:                             * Discard the replacement leaf page's blocks.
reconcile/rec_write.c:            WT_RET(__wt_btree_block_free(session, mod->mod_replace.addr, mod->mod_replace.size));
reconcile/rec_write.c:         * If in-memory, or saving/restoring changes for this page and there's only one block,
reconcile/rec_write.c:         * there's nothing to write. Set up a single block as if to split, then use that disk image
reconcile/rec_write.c:            WT_STAT_DATA_INCR(session, rec_multiblock_internal);
reconcile/rec_write.c:            WT_STAT_DATA_INCR(session, rec_multiblock_leaf);
reconcile/rec_write.c:         * reconciliation we would fail to remove blocks that are being discarded.
reconcile/rec_write.c:     * Clear the address-reused flag from the multiblock reconciliation information (otherwise we
reconcile/rec_write.c:     * might think the backing block is being reused on a subsequent reconciliation where we want to
reconcile/rec_write.c:     * On error, discard blocks we've written, they're unreferenced by the tree. This is not a
reconcile/rec_write.c:     * question of correctness, we're avoiding block leaks.
reconcile/rec_write.c:     * Don't discard backing blocks marked for reuse, they remain part of a previous reconciliation.
reconcile/rec_write.c:                WT_TRET(__wt_btree_block_free(session, multi->addr.addr, multi->addr.size));
reconcile/rec_write.c:        //block size = WT_PAGE_HEADER_SIZE + WT_BLOCK_HEADER_SIZE + 实际数据sizep
reconcile/rec_write.c:        //拷贝真实数据，跳过page header + block header
reconcile/rec_write.c:        //总长度 = page header + block header + 实际数据长度
schema/schema_stat.c:        cst->u.dsrc_stats.block_size = filesize;
schema/schema_create.c: * __create_file_block_manager --
schema/schema_create.c: *     Create a new file in the block manager, and track it.
schema/schema_create.c:__create_file_block_manager(
schema/schema_create.c:    WT_RET(__wt_block_manager_create(session, filename, allocsize));
schema/schema_create.c:                WT_ERR(__create_file_block_manager(session, uri, filename, allocsize));
schema/schema_create.c:        WT_ERR(__create_file_block_manager(session, uri, filename, allocsize));
session/session_compact.c: * Compaction is the place where the underlying block manager becomes visible
session/session_compact.c: * block manager, this code is written with it in mind: other block managers
session/session_compact.c: * may need changes to support compaction, and a smart block manager might need
session/session_compact.c: * First, the default block manager cannot entirely own compaction because it
session/session_compact.c: * has no way to find a block after it moves other than a request from the
session/session_compact.c: * block manager so internal pages don't require updates to relocate blocks:
session/session_compact.c: * layer and the block manager.  The btree layer walks files, and asks the
session/session_compact.c: * block manager if rewriting a particular block would reduce the file
session/session_compact.c: * the original version of the block; once no checkpoint references a block, it
session/session_compact.c: * lots of available space.  If a block at the end of the file is referenced by
session/session_compact.c: * matter how many times we rewrite the block, the named checkpoint can't be
session/session_compact.c: * discarded and so the reference count on the original block will never go to
session/session_compact.c: * zero. What's worse, because the block manager doesn't reference count
session/session_compact.c: * blocks, it can't easily know this is the case, and so we'll waste a lot of
session/session_compact.c: * potentially many dirty blocks in the cache, and we want to write them out
session/session_compact.c: * and then discard previous checkpoints so we have as many blocks as possible
session/session_compact.c: * Compacting the object is done 10% at a time, that is, we try and move blocks
session/session_compact.c: * hard coded in the block manager).  The reason for this is because we are
session/session_compact.c: * walking the file in logical order, not block offset order, and we can fail
session/session_compact.c: * to compact a file if we write the wrong blocks first.
session/session_compact.c: * For example, imagine a file with 10 blocks in the first 10% of a file, 1,000
session/session_compact.c: * blocks in the 3rd quartile of the file, and 10 blocks in the last 10% of the
session/session_compact.c: * file.  If we were to rewrite blocks from more than the last 10% of the file,
session/session_compact.c: * and found the 1,000 blocks in the 3rd quartile of the file first, we'd copy
session/session_compact.c: * 10 of them without ever rewriting the blocks from the end of the file which
session/session_compact.c: * on.  Note the block manager uses a first-fit block selection algorithm
session/session_compact.c: * during compaction to maximize block movement.
session/session_compact.c: * The second and third checkpoints are because the block manager checkpoints
session/session_compact.c: * in two steps: blocks made available for reuse during a checkpoint are put on
session/session_compact.c: * information.  (Otherwise it is possible to allocate a rewritten block, crash
session/session_compact.c: * blocks allocated to write the checkpoint itself cannot be taken from the
session/session_compact.c: * blocks made available by the checkpoint.
session/session_compact.c: * To say it another way, the second checkpoint puts the blocks from the end of
session/session_compact.c: * for the second checkpoint, the blocks freed by compaction become available
session/session_compact.c: * for the third checkpoint, so the third checkpoint's blocks are written
session/session_compact.c:     * is done in the underlying block manager.
session/session_compact.c:             * through all the handles, and then we'll block until a checkpoint completes.
session/session_compact.c:     * The compaction thread should not block when the cache is full: it is holding locks blocking
session/session_api.c:Wiredtiger_begin_transaction_block.cpp (src\mongo\db\storage\wiredtiger):    invariantWTOK(_session->begin_transaction(_session, beginTxnConfigString.c_str()));
session/session_api.c:Wiredtiger_begin_transaction_block.cpp (src\mongo\db\storage\wiredtiger):    invariantWTOK(_session->begin_transaction(_session, config));
session/session_api.c:Wiredtiger_begin_transaction_block.cpp (src\mongo\db\storage\wiredtiger):        invariant(_session->rollback_transaction(_session, nullptr) == 0);
session/session_api.c:Wiredtiger_begin_transaction_block.cpp (src\mongo\db\storage\wiredtiger):    return wtRCToStatus(_session->timestamp_transaction(_session, readTSConfigString.c_str()));
session/session_api.c:wiredtiger/wiredtiger_begin_transaction_block_bm.cpp:        invariant(wtRCToStatus(_wtSession->create(_wtSession, "table:mytable", nullptr)).isOK());
session/session_api.c:    if (session->block_manager_cleanup != NULL)
session/session_api.c:        WT_TRET(session->block_manager_cleanup(session));
session/session_api.c: * __session_blocking_checkpoint --
session/session_api.c:__session_blocking_checkpoint(WT_SESSION_IMPL *session)
session/session_api.c:     * the checkpoint generation number changes, the checkpoint blocking us has completed.
session/session_api.c:        WT_RET(__session_blocking_checkpoint(session));
session/session_dhandle.c:         * want to block waiting to get exclusive access.
session/session_dhandle.c:        WT_STAT_CONN_INCR(session, dhandle_lock_blocked);
support/modify.c:        /* Step over the bytes before the current block. */
support/modify.c:         * If copying this block overlaps with the next one, we can't build the value in reverse
support/modify.c:    /* Step over the final unmodified block. */
support/modify.c:        /* Move the current unmodified block into place if necessary. */
support/mtx_rw.c: * __read_blocked --
support/mtx_rw.c:__read_blocked(WT_SESSION_IMPL *session)
support/mtx_rw.c:            __wt_cond_wait(session, l->cond_readers, 10 * WT_THOUSAND, __read_blocked);
support/mtx_rw.c:     * This write lock can only be granted if no readers or writers blocked on the lock, that is, if
support/mtx_rw.c: * __write_blocked --
support/mtx_rw.c:__write_blocked(WT_SESSION_IMPL *session)
support/mtx_rw.c:            __wt_cond_wait(session, l->cond_writers, 10 * WT_THOUSAND, __write_blocked);
support/scratch.c:     *    is offset in the buffer in order to skip over the leading data block page header. For
support/scratch.c:     * needed, overflow items use the data pointer to skip the leading data block page header
support/stat.c:  "block-manager: allocations requiring file extension",
support/stat.c:  "block-manager: blocks allocated",
support/stat.c:  "block-manager: blocks freed",
support/stat.c:  "block-manager: checkpoint size",
support/stat.c:  "block-manager: file allocation unit size",
support/stat.c:  "block-manager: file bytes available for reuse",
support/stat.c:  "block-manager: file magic number",
support/stat.c:  "block-manager: file major version number",
support/stat.c:  "block-manager: file size in bytes",
support/stat.c:  "block-manager: minor version number",
support/stat.c:  "cache: checkpoint blocked page eviction",
support/stat.c:  "cache: checkpoint of history store file blocked non-history store page eviction",
support/stat.c:  "cache: hazard pointer blocked page eviction",
support/stat.c:  "compression: number of blocks with compress ratio greater than 64",
support/stat.c:  "compression: number of blocks with compress ratio smaller than 16",
support/stat.c:  "compression: number of blocks with compress ratio smaller than 2",
support/stat.c:  "compression: number of blocks with compress ratio smaller than 32",
support/stat.c:  "compression: number of blocks with compress ratio smaller than 4",
support/stat.c:  "compression: number of blocks with compress ratio smaller than 64",
support/stat.c:  "compression: number of blocks with compress ratio smaller than 8",
support/stat.c:  "reconciliation: internal page multi-block writes",
support/stat.c:  "reconciliation: leaf page multi-block writes",
support/stat.c:  "reconciliation: maximum blocks required for a page",
support/stat.c:    stats->block_extension = 0;
support/stat.c:    stats->block_alloc = 0;
support/stat.c:    stats->block_free = 0;
support/stat.c:    stats->block_checkpoint_size = 0;
support/stat.c:    stats->block_reuse_bytes = 0;
support/stat.c:    stats->block_magic = 0;
support/stat.c:    stats->block_major = 0;
support/stat.c:    stats->block_size = 0;
support/stat.c:    stats->block_minor = 0;
support/stat.c:    stats->cache_eviction_blocked_checkpoint_hs = 0;
support/stat.c:    stats->cache_eviction_blocked_no_ts_checkpoint_race_1 = 0;
support/stat.c:    stats->cache_eviction_blocked_no_ts_checkpoint_race_2 = 0;
support/stat.c:    stats->cache_eviction_blocked_no_ts_checkpoint_race_3 = 0;
support/stat.c:    stats->cache_eviction_blocked_no_ts_checkpoint_race_4 = 0;
support/stat.c:    stats->cache_eviction_blocked_remove_hs_race_with_checkpoint = 0;
support/stat.c:    stats->rec_multiblock_internal = 0;
support/stat.c:    stats->rec_multiblock_leaf = 0;
support/stat.c:    stats->rec_multiblock_max = 0;
support/stat.c:    to->block_extension += from->block_extension;
support/stat.c:    to->block_alloc += from->block_alloc;
support/stat.c:    to->block_free += from->block_free;
support/stat.c:    to->block_checkpoint_size += from->block_checkpoint_size;
support/stat.c:    to->block_reuse_bytes += from->block_reuse_bytes;
support/stat.c:    if (from->block_magic > to->block_magic)
support/stat.c:        to->block_magic = from->block_magic;
support/stat.c:    if (from->block_major > to->block_major)
support/stat.c:        to->block_major = from->block_major;
support/stat.c:    to->block_size += from->block_size;
support/stat.c:    if (from->block_minor > to->block_minor)
support/stat.c:        to->block_minor = from->block_minor;
support/stat.c:    to->cache_eviction_blocked_checkpoint_hs += from->cache_eviction_blocked_checkpoint_hs;
support/stat.c:    to->cache_eviction_blocked_no_ts_checkpoint_race_1 +=
support/stat.c:      from->cache_eviction_blocked_no_ts_checkpoint_race_1;
support/stat.c:    to->cache_eviction_blocked_no_ts_checkpoint_race_2 +=
support/stat.c:      from->cache_eviction_blocked_no_ts_checkpoint_race_2;
support/stat.c:    to->cache_eviction_blocked_no_ts_checkpoint_race_3 +=
support/stat.c:      from->cache_eviction_blocked_no_ts_checkpoint_race_3;
support/stat.c:    to->cache_eviction_blocked_no_ts_checkpoint_race_4 +=
support/stat.c:      from->cache_eviction_blocked_no_ts_checkpoint_race_4;
support/stat.c:    to->cache_eviction_blocked_remove_hs_race_with_checkpoint +=
support/stat.c:      from->cache_eviction_blocked_remove_hs_race_with_checkpoint;
support/stat.c:    to->rec_multiblock_internal += from->rec_multiblock_internal;
support/stat.c:    to->rec_multiblock_leaf += from->rec_multiblock_leaf;
support/stat.c:    if (from->rec_multiblock_max > to->rec_multiblock_max)
support/stat.c:        to->rec_multiblock_max = from->rec_multiblock_max;
support/stat.c:    to->block_extension += WT_STAT_READ(from, block_extension);
support/stat.c:    to->block_alloc += WT_STAT_READ(from, block_alloc);
support/stat.c:    to->block_free += WT_STAT_READ(from, block_free);
support/stat.c:    to->block_checkpoint_size += WT_STAT_READ(from, block_checkpoint_size);
support/stat.c:    to->block_reuse_bytes += WT_STAT_READ(from, block_reuse_bytes);
support/stat.c:    if ((v = WT_STAT_READ(from, block_magic)) > to->block_magic)
support/stat.c:        to->block_magic = v;
support/stat.c:    if ((v = WT_STAT_READ(from, block_major)) > to->block_major)
support/stat.c:        to->block_major = v;
support/stat.c:    to->block_size += WT_STAT_READ(from, block_size);
support/stat.c:    if ((v = WT_STAT_READ(from, block_minor)) > to->block_minor)
support/stat.c:        to->block_minor = v;
support/stat.c:    to->cache_eviction_blocked_checkpoint_hs +=
support/stat.c:      WT_STAT_READ(from, cache_eviction_blocked_checkpoint_hs);
support/stat.c:    to->cache_eviction_blocked_no_ts_checkpoint_race_1 +=
support/stat.c:      WT_STAT_READ(from, cache_eviction_blocked_no_ts_checkpoint_race_1);
support/stat.c:    to->cache_eviction_blocked_no_ts_checkpoint_race_2 +=
support/stat.c:      WT_STAT_READ(from, cache_eviction_blocked_no_ts_checkpoint_race_2);
support/stat.c:    to->cache_eviction_blocked_no_ts_checkpoint_race_3 +=
support/stat.c:      WT_STAT_READ(from, cache_eviction_blocked_no_ts_checkpoint_race_3);
support/stat.c:    to->cache_eviction_blocked_no_ts_checkpoint_race_4 +=
support/stat.c:      WT_STAT_READ(from, cache_eviction_blocked_no_ts_checkpoint_race_4);
support/stat.c:    to->cache_eviction_blocked_remove_hs_race_with_checkpoint +=
support/stat.c:      WT_STAT_READ(from, cache_eviction_blocked_remove_hs_race_with_checkpoint);
support/stat.c:    to->rec_multiblock_internal += WT_STAT_READ(from, rec_multiblock_internal);
support/stat.c:    to->rec_multiblock_leaf += WT_STAT_READ(from, rec_multiblock_leaf);
support/stat.c:    if ((v = WT_STAT_READ(from, rec_multiblock_max)) > to->rec_multiblock_max)
support/stat.c:        to->rec_multiblock_max = v;
support/stat.c:  "block-cache: cached blocks updated",
support/stat.c:  "block-cache: cached bytes updated",
support/stat.c:  "block-cache: evicted blocks",
support/stat.c:  "block-cache: file size causing bypass",
support/stat.c:  "block-cache: lookups",
support/stat.c:  "block-cache: number of blocks not evicted due to overhead",
support/stat.c:  "block-cache: number of bypasses because no-write-allocate setting was on",
support/stat.c:  "block-cache: number of bypasses due to overhead on put",
support/stat.c:  "block-cache: number of bypasses on get",
support/stat.c:  "block-cache: number of bypasses on put because file is too small",
support/stat.c:  "block-cache: number of eviction passes",
support/stat.c:  "block-cache: number of hits",
support/stat.c:  "block-cache: number of misses",
support/stat.c:  "block-cache: number of put bypasses on checkpoint I/O",
support/stat.c:  "block-cache: removed blocks",
support/stat.c:  "block-cache: total blocks",
support/stat.c:  "block-cache: total blocks inserted on read path",
support/stat.c:  "block-cache: total blocks inserted on write path",
support/stat.c:  "block-cache: total bytes",
support/stat.c:  "block-cache: total bytes inserted on read path",
support/stat.c:  "block-cache: total bytes inserted on write path",
support/stat.c:  "block-manager: blocks pre-loaded",
support/stat.c:  "block-manager: blocks read",
support/stat.c:  "block-manager: blocks written",
support/stat.c:  "block-manager: bytes read",
support/stat.c:  "block-manager: bytes read via memory map API",
support/stat.c:  "block-manager: bytes read via system call API",
support/stat.c:  "block-manager: bytes written",
support/stat.c:  "block-manager: bytes written for checkpoint",
support/stat.c:  "block-manager: bytes written via memory map API",
support/stat.c:  "block-manager: bytes written via system call API",
support/stat.c:  "block-manager: mapped blocks read",
support/stat.c:  "block-manager: mapped bytes read",
support/stat.c:  "block-manager: number of times the file was remapped because it changed size via fallocate or truncate",
support/stat.c:  "block-manager: number of times the region was remapped via write",
support/stat.c:  "cache: checkpoint blocked page eviction",
support/stat.c:  "cache: checkpoint of history store file blocked non-history store page eviction",
support/stat.c:  "cache: hazard pointer blocked page eviction",
support/stat.c:  "thread-yield: connection close blocked waiting for transaction state stabilization",
support/stat.c:  "thread-yield: page acquire busy blocked",
support/stat.c:  "thread-yield: page acquire eviction blocked",
support/stat.c:  "thread-yield: page acquire locked blocked",
support/stat.c:  "thread-yield: page acquire read blocked",
support/stat.c:    stats->block_cache_blocks_update = 0;
support/stat.c:    stats->block_cache_bytes_update = 0;
support/stat.c:    stats->block_cache_blocks_evicted = 0;
support/stat.c:    stats->block_cache_bypass_filesize = 0;
support/stat.c:    stats->block_cache_lookups = 0;
support/stat.c:    stats->block_cache_not_evicted_overhead = 0;
support/stat.c:    stats->block_cache_bypass_writealloc = 0;
support/stat.c:    stats->block_cache_bypass_overhead_put = 0;
support/stat.c:    stats->block_cache_bypass_get = 0;
support/stat.c:    stats->block_cache_bypass_put = 0;
support/stat.c:    stats->block_cache_eviction_passes = 0;
support/stat.c:    stats->block_cache_hits = 0;
support/stat.c:    stats->block_cache_misses = 0;
support/stat.c:    stats->block_cache_bypass_chkpt = 0;
support/stat.c:    stats->block_cache_blocks_removed = 0;
support/stat.c:    stats->block_cache_blocks = 0;
support/stat.c:    stats->block_cache_blocks_insert_read = 0;
support/stat.c:    stats->block_cache_blocks_insert_write = 0;
support/stat.c:    stats->block_cache_bytes = 0;
support/stat.c:    stats->block_cache_bytes_insert_read = 0;
support/stat.c:    stats->block_cache_bytes_insert_write = 0;
support/stat.c:    stats->block_preload = 0;
support/stat.c:    stats->block_read = 0;
support/stat.c:    stats->block_write = 0;
support/stat.c:    stats->block_byte_read = 0;
support/stat.c:    stats->block_byte_read_mmap = 0;
support/stat.c:    stats->block_byte_read_syscall = 0;
support/stat.c:    stats->block_byte_write = 0;
support/stat.c:    stats->block_byte_write_checkpoint = 0;
support/stat.c:    stats->block_byte_write_mmap = 0;
support/stat.c:    stats->block_byte_write_syscall = 0;
support/stat.c:    stats->block_map_read = 0;
support/stat.c:    stats->block_byte_map_read = 0;
support/stat.c:    stats->block_remap_file_resize = 0;
support/stat.c:    stats->block_remap_file_write = 0;
support/stat.c:    stats->cache_eviction_blocked_checkpoint_hs = 0;
support/stat.c:    stats->cache_eviction_blocked_no_ts_checkpoint_race_1 = 0;
support/stat.c:    stats->cache_eviction_blocked_no_ts_checkpoint_race_2 = 0;
support/stat.c:    stats->cache_eviction_blocked_no_ts_checkpoint_race_3 = 0;
support/stat.c:    stats->cache_eviction_blocked_no_ts_checkpoint_race_4 = 0;
support/stat.c:    stats->cache_eviction_blocked_remove_hs_race_with_checkpoint = 0;
support/stat.c:    stats->txn_release_blocked = 0;
support/stat.c:    stats->conn_close_blocked_lsm = 0;
support/stat.c:    stats->dhandle_lock_blocked = 0;
support/stat.c:    stats->page_index_slot_ref_blocked = 0;
support/stat.c:    stats->prepared_transition_blocked_page = 0;
support/stat.c:    stats->page_busy_blocked = 0;
support/stat.c:    stats->page_forcible_evict_blocked = 0;
support/stat.c:    stats->page_locked_blocked = 0;
support/stat.c:    stats->page_read_blocked = 0;
support/stat.c:    stats->page_del_rollback_blocked = 0;
support/stat.c:    stats->child_modify_blocked_page = 0;
support/stat.c:    to->block_cache_blocks_update += WT_STAT_READ(from, block_cache_blocks_update);
support/stat.c:    to->block_cache_bytes_update += WT_STAT_READ(from, block_cache_bytes_update);
support/stat.c:    to->block_cache_blocks_evicted += WT_STAT_READ(from, block_cache_blocks_evicted);
support/stat.c:    to->block_cache_bypass_filesize += WT_STAT_READ(from, block_cache_bypass_filesize);
support/stat.c:    to->block_cache_lookups += WT_STAT_READ(from, block_cache_lookups);
support/stat.c:    to->block_cache_not_evicted_overhead += WT_STAT_READ(from, block_cache_not_evicted_overhead);
support/stat.c:    to->block_cache_bypass_writealloc += WT_STAT_READ(from, block_cache_bypass_writealloc);
support/stat.c:    to->block_cache_bypass_overhead_put += WT_STAT_READ(from, block_cache_bypass_overhead_put);
support/stat.c:    to->block_cache_bypass_get += WT_STAT_READ(from, block_cache_bypass_get);
support/stat.c:    to->block_cache_bypass_put += WT_STAT_READ(from, block_cache_bypass_put);
support/stat.c:    to->block_cache_eviction_passes += WT_STAT_READ(from, block_cache_eviction_passes);
support/stat.c:    to->block_cache_hits += WT_STAT_READ(from, block_cache_hits);
support/stat.c:    to->block_cache_misses += WT_STAT_READ(from, block_cache_misses);
support/stat.c:    to->block_cache_bypass_chkpt += WT_STAT_READ(from, block_cache_bypass_chkpt);
support/stat.c:    to->block_cache_blocks_removed += WT_STAT_READ(from, block_cache_blocks_removed);
support/stat.c:    to->block_cache_blocks += WT_STAT_READ(from, block_cache_blocks);
support/stat.c:    to->block_cache_blocks_insert_read += WT_STAT_READ(from, block_cache_blocks_insert_read);
support/stat.c:    to->block_cache_blocks_insert_write += WT_STAT_READ(from, block_cache_blocks_insert_write);
support/stat.c:    to->block_cache_bytes += WT_STAT_READ(from, block_cache_bytes);
support/stat.c:    to->block_cache_bytes_insert_read += WT_STAT_READ(from, block_cache_bytes_insert_read);
support/stat.c:    to->block_cache_bytes_insert_write += WT_STAT_READ(from, block_cache_bytes_insert_write);
support/stat.c:    to->block_preload += WT_STAT_READ(from, block_preload);
support/stat.c:    to->block_read += WT_STAT_READ(from, block_read);
support/stat.c:    to->block_write += WT_STAT_READ(from, block_write);
support/stat.c:    to->block_byte_read += WT_STAT_READ(from, block_byte_read);
support/stat.c:    to->block_byte_read_mmap += WT_STAT_READ(from, block_byte_read_mmap);
support/stat.c:    to->block_byte_read_syscall += WT_STAT_READ(from, block_byte_read_syscall);
support/stat.c:    to->block_byte_write += WT_STAT_READ(from, block_byte_write);
support/stat.c:    to->block_byte_write_checkpoint += WT_STAT_READ(from, block_byte_write_checkpoint);
support/stat.c:    to->block_byte_write_mmap += WT_STAT_READ(from, block_byte_write_mmap);
support/stat.c:    to->block_byte_write_syscall += WT_STAT_READ(from, block_byte_write_syscall);
support/stat.c:    to->block_map_read += WT_STAT_READ(from, block_map_read);
support/stat.c:    to->block_byte_map_read += WT_STAT_READ(from, block_byte_map_read);
support/stat.c:    to->block_remap_file_resize += WT_STAT_READ(from, block_remap_file_resize);
support/stat.c:    to->block_remap_file_write += WT_STAT_READ(from, block_remap_file_write);
support/stat.c:    to->cache_eviction_blocked_checkpoint_hs +=
support/stat.c:      WT_STAT_READ(from, cache_eviction_blocked_checkpoint_hs);
support/stat.c:    to->cache_eviction_blocked_no_ts_checkpoint_race_1 +=
support/stat.c:      WT_STAT_READ(from, cache_eviction_blocked_no_ts_checkpoint_race_1);
support/stat.c:    to->cache_eviction_blocked_no_ts_checkpoint_race_2 +=
support/stat.c:      WT_STAT_READ(from, cache_eviction_blocked_no_ts_checkpoint_race_2);
support/stat.c:    to->cache_eviction_blocked_no_ts_checkpoint_race_3 +=
support/stat.c:      WT_STAT_READ(from, cache_eviction_blocked_no_ts_checkpoint_race_3);
support/stat.c:    to->cache_eviction_blocked_no_ts_checkpoint_race_4 +=
support/stat.c:      WT_STAT_READ(from, cache_eviction_blocked_no_ts_checkpoint_race_4);
support/stat.c:    to->cache_eviction_blocked_remove_hs_race_with_checkpoint +=
support/stat.c:      WT_STAT_READ(from, cache_eviction_blocked_remove_hs_race_with_checkpoint);
support/stat.c:    to->txn_release_blocked += WT_STAT_READ(from, txn_release_blocked);
support/stat.c:    to->conn_close_blocked_lsm += WT_STAT_READ(from, conn_close_blocked_lsm);
support/stat.c:    to->dhandle_lock_blocked += WT_STAT_READ(from, dhandle_lock_blocked);
support/stat.c:    to->page_index_slot_ref_blocked += WT_STAT_READ(from, page_index_slot_ref_blocked);
support/stat.c:    to->prepared_transition_blocked_page += WT_STAT_READ(from, prepared_transition_blocked_page);
support/stat.c:    to->page_busy_blocked += WT_STAT_READ(from, page_busy_blocked);
support/stat.c:    to->page_forcible_evict_blocked += WT_STAT_READ(from, page_forcible_evict_blocked);
support/stat.c:    to->page_locked_blocked += WT_STAT_READ(from, page_locked_blocked);
support/stat.c:    to->page_read_blocked += WT_STAT_READ(from, page_read_blocked);
support/stat.c:    to->page_del_rollback_blocked += WT_STAT_READ(from, page_del_rollback_blocked);
support/stat.c:    to->child_modify_blocked_page += WT_STAT_READ(from, child_modify_blocked_page);
txn/txn_rollback_to_stable.c:        tag = "reconciled replace block";
txn/txn_rollback_to_stable.c:        tag = "reconciled multi block";
txn/txn.c:     * We're between transactions, if we need to block for eviction, it's a good time to do so.
txn/txn.c:     * We're between transactions, if we need to block for eviction, it's a good time to do so.
txn/txn.c:     * adjacent malloc block; we'd like to be able to assert that in checkpoint cursor transactions
txn/txn.c:     * the checkpoint cursor close function. If an adjacent malloc block, that might not be true.
txn/txn.c:        WT_STAT_CONN_INCR(session, txn_release_blocked);
txn/txn.c: * __wt_txn_is_blocking --
txn/txn.c: *     Return an error if this transaction is likely blocking eviction because of a pinned
txn/txn.c:__wt_txn_is_blocking(WT_SESSION_IMPL *session)
txn/txn_ckpt.c:     * Unblock updates -- we can figure out that any updates to clean pages after this point are too
txn/txn_ckpt.c:        WT_ERR(__wt_block_manager_named_size(session, WT_HS_FILE, &hs_size));
txn/txn_ckpt.c: * does enough I/O it may be called upon to perform slow operations for the block manager.
txn/txn_ckpt.c:              "checkpoint %s blocked by hot backup: it would delete an existing named checkpoint, "
txn/txn_ckpt.c:        /* Clean up block manager information. */
txn/txn_ckpt.c:    WT_ASSERT(session, ckpt_itr->block_metadata != NULL);
txn/txn_ckpt.c:     * blocks for just-created files, but it's not just a good idea. The reason is because deleting
txn/txn_ckpt.c:     * If you (1) create a physical checkpoint for an empty file which writes blocks, (2) start
txn/txn_ckpt.c:    /* Tell the block manager that a file checkpoint is starting. */
txn/txn_ckpt.c:    //设置状态block->ckpt_state = WT_CKPT_INPROGRESS;
txn/txn_ckpt.c:    /* Resolved the checkpoint for the block manager in the error path. */
txn/txn_ckpt.c: *     purposes. The reason for this option is finding operations that can block while waiting for a
txn/txn_recover.c:    /* Reset the cursor so it doesn't block eviction. */
txn/txn_recover.c:     * block eviction during recovery.
txn/txn_recover.c:        WT_ERR(__wt_block_manager_named_size(session, WT_HS_FILE, &hs_size));
utilities/util_list.c:static int list_init_block(WT_SESSION *, const char *, WT_BLOCK *);
utilities/util_list.c: * list_init_block --
utilities/util_list.c: *     Initialize a dummy block structure for a file.
utilities/util_list.c:list_init_block(WT_SESSION *session, const char *key, WT_BLOCK *block)
utilities/util_list.c:    WT_CLEAR(*block);
utilities/util_list.c:        block->allocsize = (uint32_t)cval.val;
utilities/util_list.c:    WT_BLOCK _block, *block;
utilities/util_list.c:    block = &_block;
utilities/util_list.c:    if ((ret = list_init_block(session, key, block)) != 0)
utilities/util_list.c:        /* Decode the checkpoint block. */
utilities/util_list.c:        if ((ret = __wt_block_ckpt_decode(session, block, ckpt->raw.data, ckpt->raw.size, &ci)) ==
utilities/util_list.c:            (void)util_err(session, ret, "__wt_block_ckpt_decode");
utilities/util_verify.c:      "verify [-s] [-t] [-c] [-d dump_address | dump_blocks | dump_layout | dump_offsets=#,# | "
utilities/util_verify.c:    bool do_not_clear_txn_id, dump_address, dump_blocks, dump_layout, dump_pages, read_corrupt,
utilities/util_verify.c:    do_not_clear_txn_id = dump_address = dump_blocks = dump_layout = dump_pages = read_corrupt =
utilities/util_verify.c:            else if (strcmp(__wt_optarg, "dump_blocks") == 0)
utilities/util_verify.c:                dump_blocks = true;
utilities/util_verify.c:    if (do_not_clear_txn_id || read_corrupt || dump_address || dump_blocks || dump_layout ||
utilities/util_verify.c:          strlen("dump_blocks,") + strlen("dump_layout,") + strlen("dump_pages,") +
utilities/util_verify.c:               dump_blocks ? "dump_blocks," : "", dump_layout ? "dump_layout," : "",
